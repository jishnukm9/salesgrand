from django.shortcuts import render, redirect, reverse
from django.http import (
    HttpResponseNotFound,
    HttpResponseRedirect,
    HttpResponse,
    FileResponse,
)
from django.core.files.storage import FileSystemStorage
from django.core.files.base import ContentFile
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User
from django.db.models import F, Q
from .models import *
from .forms import *
import math
from urllib.request import urlopen
from datetime import date, datetime, timedelta
import io
import xlsxwriter
from django.conf import settings
from .senseutils.utils import (
    whatsapp,
    generate_unique_id,
    publitio_file_upload,
    sendEmail,
    func_generate_invoice_qrcode,
)
import os
from pathlib import Path
from django.core.cache import cache
from django.contrib import messages
from django.db import IntegrityError
from django.http import JsonResponse
from django.http import QueryDict
from django.db.models import Count, Sum
from collections import defaultdict
from .decorators import (
    no_fieldengineer,
    no_branchadmin,
    no_franchiseadmin,
    no_technician,
    no_admin,
)
import pandas as pd
import pdfkit
from publitio import PublitioAPI
from .globalvar import custom_variables
from django.template.loader import get_template
from io import BytesIO
from barcode import EAN13
import base64
from PIL import Image, ImageDraw, ImageFont
import barcode
from barcode.writer import ImageWriter
from django.utils import timezone
from .accountsutils import coa, addaccounts
from django.contrib.auth.decorators import user_passes_test
from functools import partial
from .constants import *
import re
from django.utils import timezone
from collections import OrderedDict
from django.core.mail import BadHeaderError, send_mail
from django.http import HttpResponse, HttpResponseRedirect
from core.globalvar import custom_variables
from social.models import *
from dateutil.relativedelta import relativedelta
from django.contrib.auth import logout
from django.db.models import F, FloatField
from num2words import num2words
from django.views.decorators.cache import never_cache
from .ledgerbook import ledgercli
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import mm
from reportlab.pdfgen import canvas
from reportlab.lib.utils import ImageReader
from io import BytesIO
import logging
import time
import json
from django.db.models import Sum
import time



performance_logger = logging.getLogger('performance')
BASE_DIR = Path(__file__).resolve().parent.parent
GLOBAL_VARIABLES = custom_variables(None)





def func_create_customer_ledger(cust_data,unique_id,request):

    ########################################
    #creating ledger for customer
    data = CoASubAccounts()
    ledgername = "ACCOUNTS RECEIVABLE"
    ledgerobj = AccountLedger.objects.filter(name=ledgername).first()
    title = f"{cust_data.firstname} {cust_data.lastname} {unique_id}"
    data.head_root = ledgerobj
    gstring = ledgername.replace(" ", "_")
    data.gstring = gstring
    data.title = title
    data.branch = request.user.userprofile.branch
    data.description = f"{cust_data.firstname} {cust_data.lastname} {unique_id}"
    data.is_adminonly = True
    if not CoASubAccounts.objects.filter(title=title).first():
        data.save()

        customer_objects = Customers.objects.filter(unique_id=unique_id).first()
        customer_objects.customer_ledger = CoASubAccounts.objects.filter(title=title).first()
        customer_objects.save()
    #########################################

    return 0




def func_create_supplier_ledger(supp_data,unique_id,request):

    ########################################
    #creating ledger for customer
    data = CoASubAccounts()
    ledgername = "ACCOUNTS PAYABLE"
    ledgerobj = AccountLedger.objects.filter(name=ledgername).first()
    title = f"{supp_data.name} {unique_id}"
    data.head_root = ledgerobj
    gstring = ledgername.replace(" ", "_")
    data.gstring = gstring
    data.title = title
    data.branch = request.user.userprofile.branch
    data.description = f"{supp_data.name} {unique_id}"
    data.is_adminonly = True
    if not CoASubAccounts.objects.filter(title=title).first():
        data.save()

        supplier_objects = Suppliers.objects.filter(id=int(unique_id)).first()
        supplier_objects.supplier_ledger = CoASubAccounts.objects.filter(title=title).first()
        supplier_objects.save()
    #########################################

    return 0



def func_get_sub_ledgers(request,subledgername):

    if subledgername == "Purchase":
        purchase_subledger = CoASubAccounts.objects.filter(Q(title="Purchase") & Q(is_adminonly=True)).first()
        if not purchase_subledger:
            data = CoASubAccounts()
            ledgername = "PURCHASE ACCOUNT"
            ledgerobj = AccountLedger.objects.filter(name=ledgername).first()
            title = f"Purchase"
            data.head_root = ledgerobj
            gstring = ledgername.replace(" ", "_")
            data.gstring = gstring
            data.title = title
            data.branch = request.user.userprofile.branch
            data.description = title
            data.is_adminonly = True
            data.save()

            purchase_subledger = CoASubAccounts.objects.filter(Q(title="Purchase") & Q(is_adminonly=True)).first()
            ledger = purchase_subledger
        else:
            ledger = purchase_subledger

    elif subledgername == "Sales":
        sale_subledger = CoASubAccounts.objects.filter(Q(title="Sales") & Q(is_adminonly=True)).first()
        if not sale_subledger:
            data = CoASubAccounts()
            ledgername = "SALES ACCOUNT"
            ledgerobj = AccountLedger.objects.filter(name=ledgername).first()
            title = f"Sales"
            data.head_root = ledgerobj
            gstring = ledgername.replace(" ", "_")
            data.gstring = gstring
            data.title = title
            data.branch =  request.user.userprofile.branch
            data.description = title
            data.is_adminonly = True
            data.save()

            sale_subledger = CoASubAccounts.objects.filter(Q(title="Sales") & Q(is_adminonly=True)).first()
            ledger = sale_subledger
        else:
            ledger = sale_subledger

    elif subledgername == "Card":

        card_subledger = CoASubAccounts.objects.filter(Q(title="Card") & Q(is_adminonly=True)).first()
        if not card_subledger:
            data = CoASubAccounts()
            ledgername = "CASH ACCOUNT"
            ledgerobj = AccountLedger.objects.filter(name=ledgername).first()
            title = f"Card"
            data.head_root = ledgerobj
            gstring = ledgername.replace(" ", "_")
            data.gstring = gstring
            data.title = title
            data.branch =  request.user.userprofile.branch
            data.description = title
            data.is_adminonly = True
            data.save()

            card_subledger = CoASubAccounts.objects.filter(Q(title="Card") & Q(is_adminonly=True)).first()
            ledger = card_subledger
        else:
            ledger = card_subledger

    elif subledgername == "UPI":

        upi_subledger = CoASubAccounts.objects.filter(Q(title="UPI") & Q(is_adminonly=True)).first()
        if not upi_subledger:
            data = CoASubAccounts()
            ledgername = "CASH ACCOUNT"
            ledgerobj = AccountLedger.objects.filter(name=ledgername).first()
            title = f"UPI"
            data.head_root = ledgerobj
            gstring = ledgername.replace(" ", "_")
            data.gstring = gstring
            data.title = title
            data.branch = request.user.userprofile.branch
            data.description = title
            data.is_adminonly = True
            data.save()

            upi_subledger = CoASubAccounts.objects.filter(Q(title="UPI") & Q(is_adminonly=True)).first()
            ledger = upi_subledger
        else:
            ledger = upi_subledger

    elif subledgername == "Bank":

        bank_subledger = CoASubAccounts.objects.filter(Q(title="Bank") & Q(is_adminonly=True)).first()
        if not bank_subledger:
            data = CoASubAccounts()
            ledgername = "CASH ACCOUNT"
            ledgerobj = AccountLedger.objects.filter(name=ledgername).first()
            title = f"Bank"
            data.head_root = ledgerobj
            gstring = ledgername.replace(" ", "_")
            data.gstring = gstring
            data.title = title
            data.branch =  request.user.userprofile.branch
            data.description = title
            data.is_adminonly = True
            data.save()

            bank_subledger = CoASubAccounts.objects.filter(Q(title="Bank") & Q(is_adminonly=True)).first()
            ledger = bank_subledger
        else:
            ledger = bank_subledger

    elif subledgername == 'Cash':
        cash_subledger = CoASubAccounts.objects.filter(Q(title="Cash") & Q(is_adminonly=True)).first()
        if not cash_subledger:
            data = CoASubAccounts()
            ledgername = "CASH ACCOUNT"
            ledgerobj = AccountLedger.objects.filter(name=ledgername).first()
            title = f"Cash"
            data.head_root = ledgerobj
            gstring = ledgername.replace(" ", "_")
            data.gstring = gstring
            data.title = title
            data.branch =  request.user.userprofile.branch
            data.description = title
            data.is_adminonly = True
            data.save()

            cash_subledger = CoASubAccounts.objects.filter(Q(title="Cash") & Q(is_adminonly=True)).first()
            ledger = cash_subledger
        else:
            ledger = cash_subledger

    elif subledgername == 'Service':
        service_subledger = CoASubAccounts.objects.filter(Q(title="Service") & Q(is_adminonly=True)).first()
        if not service_subledger:
            data = CoASubAccounts()
            ledgername = "SERVICES ACCOUNT"
            ledgerobj = AccountLedger.objects.filter(name=ledgername).first()
            title = f"Service"
            data.head_root = ledgerobj
            gstring = ledgername.replace(" ", "_")
            data.gstring = gstring
            data.title = title
            data.branch = request.user.userprofile.branch
            data.description = title
            data.is_adminonly = True
            data.save()

            service_subledger = CoASubAccounts.objects.filter(Q(title="Service") & Q(is_adminonly=True)).first()
            ledger = service_subledger
        else:
            ledger = service_subledger

    elif subledgername == 'Purchase Return':
        purchase_return_subledger = CoASubAccounts.objects.filter(Q(title="Purchase Return") & Q(is_adminonly=True)).first()
        if not purchase_return_subledger:
            data = CoASubAccounts()
            ledgername = "PURCHASE ACCOUNT"
            ledgerobj = AccountLedger.objects.filter(name=ledgername).first()
            title = f"Purchase Return"
            data.head_root = ledgerobj
            gstring = ledgername.replace(" ", "_")
            data.gstring = gstring
            data.title = title
            data.branch =  request.user.userprofile.branch
            data.description = title
            data.is_adminonly = True
            data.save()

            purchase_return_subledger = CoASubAccounts.objects.filter(Q(title="Purchase Return") & Q(is_adminonly=True)).first()
            ledger = purchase_return_subledger
        else:
            ledger = purchase_return_subledger

    elif subledgername == 'Sales Return':
        sales_return_subledger = CoASubAccounts.objects.filter(Q(title="Sales Return") & Q(is_adminonly=True)).first()
        if not sales_return_subledger:
            data = CoASubAccounts()
            ledgername = "SALES ACCOUNT"
            ledgerobj = AccountLedger.objects.filter(name=ledgername).first()
            title = f"Sales Return"
            data.head_root = ledgerobj
            gstring = ledgername.replace(" ", "_")
            data.gstring = gstring
            data.title = title
            data.branch =  request.user.userprofile.branch
            data.description = title
            data.is_adminonly = True
            data.save()

            sales_return_subledger = CoASubAccounts.objects.filter(Q(title="Sales Return") & Q(is_adminonly=True)).first()
            ledger = sales_return_subledger
        else:
            ledger = sales_return_subledger

    else:
        ledger = None

    return ledger


#for checking length of the items in form
def check_status(string):
    pattern = re.compile(r"^status")
    return bool(pattern.match(string))

def check_status_common(string, attribute):
    # Create a regex pattern using the attribute variable
    pattern = re.compile(rf"^{re.escape(attribute)}")
    return bool(pattern.match(string))



# This is a function for checking if the current user has permission to access the requested url ,
# Role and Permissions are defined in constants.py
def check_permission(user, page):
    has_permission = True
    if "All" in user.userprofile.get_permissions():

        if page == "Serviceform":
            has_permission = False
        else:
            has_permission = True
    elif page not in user.userprofile.get_permissions():
        has_permission = False

    return has_permission


# This function retrieve the root COA from subcoa
def get_coa_root(subcoa):
    coa_list = CoASubAccounts.objects.all()
    # identify the coa as the coa list contains slight different set from the ledger-cli
    gstring = ""
    root_coa = ""
    for item in coa_list:
        if item.title.strip() == subcoa.strip():
            # sub coa saved in the DB
            gstring = item.gstring
    if not gstring:
        # Primary COA defined in the coa.py
        # from subcoa contains space, whereas in coa.py doesnt have space
        # replace the sapce with underscore
        gstring = subcoa.replace(" ", "_")
    if gstring:
        try:
            gstring_dict = getattr(coa, gstring)
            root_coa = gstring_dict["root"]["ledger-cli"]
            root_coa_level1 = gstring_dict["name"]
           
        except:
            root_coa = None
            root_coa_level1 = None
        if root_coa != None and root_coa_level1 != None:
            return root_coa, root_coa_level1
        else:
            return None, None
    # if nothing retrived from the above, return None
    return None, None


# Coming soon url
@login_required
def comingSoon(request):
    context = {}
    return render(request, "comingsoon.html", context)


# Access denied url
@login_required
def access_denied(request):
    context = {}
    return render(request, "accessdenied.html", context)


# prduct functions start here
# Add product form
@user_passes_test(
    partial(check_permission, page="Products"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def productForm(request):
    user = request.user
    catagory = Catagories.objects.filter(branch=request.user.userprofile.branch)
    type = Type.objects.filter(branch=request.user.userprofile.branch)
    brand = Brand.objects.filter(branch=request.user.userprofile.branch)
    packing = Packing.objects.filter(branch=request.user.userprofile.branch)
    subcatagory = SubCatagories.objects.filter(branch=request.user.userprofile.branch)
    tax = Tax.objects.filter(branch=request.user.userprofile.branch)

    context = {
        "catagory": catagory,
        "type": type,
        "brand": brand,
        "packing": packing,
        "subcatagory": subcatagory,
        "tax": tax,
    }

    return render(request, "addproduct.html", context)


# Product List function
@user_passes_test(
    partial(check_permission, page="Products"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def products(request):
    user = request.user
    if user.is_superuser:
        data = Products.objects.all().order_by("pk")
    else:
        data = Products.objects.filter(branch=user.userprofile.branch).order_by("pk")
    context = {
        "data": data,
    }
    return render(request, "products.html", context)





def func_calculate_amount_without_tax(amount,tax):
    output = (float(amount)/(1+float(tax)/100))
    return round(output,2)

# Function to save product
@login_required
def addProduct(request):
    data = Products()
    data.name = request.POST["name"]
    catagoryname = request.POST["catagory"]
    data.catagory = Catagories.objects.filter(
        Q(name=catagoryname) & Q(branch=request.user.userprofile.branch)
    ).first()
    subcatagoryname = request.POST["subcatagory"]

    data.subcatagory = SubCatagories.objects.filter(
        Q(name=subcatagoryname) & Q(branch=request.user.userprofile.branch)
    ).first()
    brandname = request.POST["brand"]
    data.brand = Brand.objects.filter(
        Q(branch=request.user.userprofile.branch) & Q(name=brandname)
    ).first()
    type = request.POST["type"]
    data.type = Type.objects.filter(
        Q(name=type) & Q(branch=request.user.userprofile.branch)
    ).first()
    packingname = request.POST["packing"]
    data.packing = Packing.objects.filter(
        Q(name=packingname) & Q(branch=request.user.userprofile.branch)
    ).first()
    data.HSN = request.POST["hsn"]

    ####### 9-9-2024 ######

    salegst = Tax.objects.filter(id=int(request.POST["salesgst"])).first()
    purchasegst = Tax.objects.filter(id=int(request.POST["purchasegst"])).first()
    price = request.POST["price"]
    sellingprice = request.POST["sellingprice"]

    price = func_calculate_amount_without_tax(float(price),float(purchasegst.percentage))
    sellingprice = func_calculate_amount_without_tax(float(sellingprice),(float(salegst.percentage)))

    #######################

    data.price = price
    data.sellingprice = sellingprice
   
    data.purchasegst = purchasegst
    
    data.salegst = salegst
    data.mrp = request.POST["mrp"]
    data.mop = request.POST["mop"]
    data.branch = request.user.userprofile.branch

    try:
        data.save()
    except IntegrityError as e:
        messages.error(request, "Product already exists.")
        return redirect("productform")
    except:
        messages.error(request, "An error occured.")
        return redirect("productform")

    # Add the same product in the stock as well with zero quantity
    if request.user.is_superuser:

        stock = Stock()
        productname = request.POST["name"]
        stock.name = Products.objects.filter(
            Q(name=productname) & Q(branch=request.user.userprofile.branch)
        ).first()

        stock.quantity = 0
        stock.purchaserate = float(request.POST["price"])
        stock.salerate = float(request.POST["sellingprice"])
        stock.save()

    else:
        stock = BranchStock()
        productname = request.POST["name"]
        stock.name = Products.objects.filter(
            Q(name=productname) & Q(branch=request.user.userprofile.branch)
        ).first()
        stock.branch = request.user.userprofile.branch
        stock.purchaserate = float(request.POST["price"])
        stock.salerate = float(request.POST["sellingprice"])
        stock.quantity = 0
        stock.save()

    stocktr = StockTransaction()
    prod = Products.objects.filter(
        Q(name=productname) & Q(branch=request.user.userprofile.branch)
    ).first()
    stocktr.product = prod
    stocktr.initial_quantity = 0
    try:
        stocktr.reference_number  = f'{prod.id}'
        stocktr.transaction_category  = 'Product Entry'
    except:
        stocktr.reference_number  = 'NA'
        stocktr.transaction_category  = 'Product Entry'
    stocktr.quantity = 0
    stocktr.transactiontype = "Add"
    stocktr.branch = request.user.userprofile.branch
    stocktr.save()

    return HttpResponseRedirect("/products")



def func_calculate_amount_with_tax(amount,tax):
    output = (float(amount)+(float(amount)*(float(tax)/100)))
    return round(output,2)

# Product Update form
@never_cache
@login_required
def updateProductForm(request, id):
    user = request.user
    product = Products.objects.get(id=id)
    catagories = Catagories.objects.filter(branch=request.user.userprofile.branch)
    producttypes = Type.objects.filter(branch=request.user.userprofile.branch)
    brands = Brand.objects.filter(branch=request.user.userprofile.branch)
    packing = Packing.objects.filter(branch=request.user.userprofile.branch)
    subcatagories = SubCatagories.objects.filter(branch=request.user.userprofile.branch)
    tax = Tax.objects.filter(branch=request.user.userprofile.branch)

    ####### 9-9-2024 #########

    purchase_price_with_tax = func_calculate_amount_with_tax(float(product.price),float(product.purchasegst.percentage))

    selling_price_with_tax = func_calculate_amount_with_tax(float(product.sellingprice),float(product.salegst.percentage))

    ##########################
    context = {
        "product": product,
        "catagories": catagories,
        "brands": brands,
        "subcatagories": subcatagories,
        "producttypes": producttypes,
        "packing": packing,
        "tax": tax,
        "purchase_price_with_tax":purchase_price_with_tax,
        "selling_price_with_tax":selling_price_with_tax
    }
    return render(request, "productedit.html", context)


# Function to update product
@login_required
def updateProduct(request, id):
    if request.method == "POST":
        product = Products.objects.get(id=id)
        product.name = request.POST.get("name")
        product.catagory = Catagories.objects.filter(
            Q(name=request.POST.get("catagory"))
            & Q(branch=request.user.userprofile.branch)
        ).first()
        product.subcatagory = SubCatagories.objects.filter(
            Q(name=request.POST.get("subcatagory"))
            & Q(branch=request.user.userprofile.branch)
        ).first()
        product.brand = Brand.objects.get(id=request.POST.get("brand"))
        product.type = Type.objects.get(id=request.POST.get("type"))
        product.packing = Packing.objects.get(id=request.POST.get("packing"))
        product.HSN = request.POST.get("hsn")

        ####### 9-9-2024 ######

        salegst = Tax.objects.filter(id=int(request.POST["salesgst"])).first()
        purchasegst = Tax.objects.filter(id=int(request.POST["purchasegst"])).first()
        price = request.POST["price"]
        sellingprice = request.POST["sellingprice"]

        price = func_calculate_amount_without_tax(float(price),float(purchasegst.percentage))
        sellingprice = func_calculate_amount_without_tax(float(sellingprice),(float(salegst.percentage)))

        #######################

        product.price = price
        product.sellingprice = sellingprice

        product.purchasegst = purchasegst
        product.salegst = salegst


        product.mrp = request.POST["mrp"]
        product.mop = request.POST["mop"]

        try:
            product.save()
        except IntegrityError as e:
            messages.error(request, "Product already exists.")
            return redirect(reverse("updateproductform", kwargs={"id": id}))
        except ValidationError as valerr:
            messages.error(
                request,
                "Cannot update Product entry as it is referenced by Sale,Purchase or BranchPurchase entries.",
            )
            return redirect(reverse("updateproductform", kwargs={"id": id}))
        except Exception as exx:
            messages.error(
                request,
                "Cannot update Product entry as it is referenced by Sale,Purchase or BranchPurchase entries.",
            )
            return redirect(reverse("updateproductform", kwargs={"id": id}))

    return redirect("products")


@login_required
def deleteProduct(request, id):

    try:
        product = Products.objects.get(id=id)
        product.delete()
    except ValidationError as valerr:
        messages.error(
            request,
            "Cannot delete Product entry as it is referenced by Sale,Purchase or BranchPurchase entries.",
        )
        return redirect("products")
    except Exception as exx:
        messages.error(
            request,
            "Cannot delete Product entry as it is referenced by Sale,Purchase or BranchPurchase entries.",
        )
        return redirect("products")

    return redirect("products")


# Ajax call function
# This function take product name as input and return product details
@login_required
def get_product_details(request):

    user = request.user
    if request.method == "POST":
        received_data = QueryDict(request.body)
        productname = received_data.get("productname")
        product_obj = Products.objects.filter(
            Q(name=productname) & Q(branch=request.user.userprofile.branch)
        ).first()
        resp = {}
        if product_obj:
            resp = {
                "unitprice":round(product_obj.price,2),
                "sellingprice": round(product_obj.sellingprice,2),
                "salegst": product_obj.salegst.name,
                "purchasegst": product_obj.purchasegst.name,
                "mop": product_obj.mop,
                "mrp": product_obj.mrp,
            }
            if user.is_superuser:
                product_stock = Stock.objects.filter(name__id=product_obj.id).first()
                available_qty = product_stock.quantity
                resp["available_qty"] = available_qty
            else:
                product_stock = BranchStock.objects.filter(
                    Q(name__id=product_obj.id) & Q(branch=user.userprofile.branch)
                ).first()
                available_qty = product_stock.quantity
                resp["available_qty"] = available_qty

    return JsonResponse(resp)


# Ajax call function
# This function take product Id as input and return product details
@login_required
def get_product_details_by_id(request):
    user = request.user
    if request.method == "POST":
        received_data = QueryDict(request.body)
        prod_id = received_data.get("productid")
        transfer_id = received_data.get("transferid")
        product_obj = Products.objects.filter(id=int(prod_id)).first()
        resp = {}
        if product_obj:
            resp = {
                "name": product_obj.name,
                "catagory": product_obj.catagory.name,
                "subcatagory": product_obj.subcatagory.name,
                "brand": product_obj.brand.name,
                "type": product_obj.type.name,
                "packing": product_obj.packing.name,
                "hsn": product_obj.HSN,
                "unitprice": product_obj.price,
                "sellingprice": product_obj.sellingprice,
                "salegst": product_obj.salegst.name,
                "purchasegst": product_obj.purchasegst.name,
                "mop": product_obj.mop,
                "mrp": product_obj.mrp,
                "transferid": transfer_id,
            }

    return JsonResponse(resp)


# Ajax call function
# This function take barcode as input and return product details
@login_required
def get_product_details_by_barcode(request):
    user = request.user
    if request.method == "POST":
        received_data = QueryDict(request.body)
        barcode = received_data.get("barcode")
        if user.is_superuser:
            product_obj = Purchase.objects.filter(
                Q(barcodenumber=barcode) & Q(branch=request.user.userprofile.branch)
            ).first()
        else:
            product_obj = BranchPurchase.objects.filter(
                Q(barcodenumber=barcode) & Q(branch=request.user.userprofile.branch)
            ).first()
        try:
            product = product_obj.name
        except:
            return JsonResponse({"Response": "Product not found"})

        resp = {"Response": {}}
        if product_obj:
            resp["Response"] = {
                "unitprice": product_obj.price,
                "sellingprice": product_obj.sellingprice,
                "salegst": product_obj.salegst,
                "purchasegst": product_obj.purchasegst,
                "mop": product_obj.mop,
                "mrp": product_obj.mrp,
                "product": product.name,
            }
            if user.is_superuser:
                product_stock = Stock.objects.filter(name__name=product.name).first()
                available_qty = product_stock.quantity
                resp["Response"]["available_qty"] = available_qty
            else:
                product_stock = BranchStock.objects.filter(
                    Q(name__name=product.name) & Q(branch=user.userprofile.branch)
                ).first()
                available_qty = product_stock.quantity
                resp["Response"]["available_qty"] = available_qty

    return JsonResponse(resp)


# Ajax call function
# This function take _ as input and return product details
@login_required
def get_product_details_by_product(request):
    user = request.user
    if request.method == "POST":
        received_data = QueryDict(request.body)
        product = received_data.get("product")
        branch = user.userprofile.branch

        product_obj = Products.objects.filter(
            Q(name=product) & Q(branch=branch)
        ).first()

        if not product_obj:
            return JsonResponse({"Response": "Product not found"})

        resp = {}

        resp["Response"] = {
            "unitprice": product_obj.price,
            "sellingprice": product_obj.sellingprice,
            "salegst": product_obj.salegst.name,
            "purchasegst": product_obj.purchasegst.name,
            "mop": product_obj.mop,
            "mrp": product_obj.mrp,
            "product": product_obj.name,
        }
        if user.is_superuser:
            product_stock = Stock.objects.filter(name=product_obj).first()
            available_qty = product_stock.quantity
            resp["Response"]["available_qty"] = available_qty
        else:
            product_stock = BranchStock.objects.filter(
                Q(name=product_obj) & Q(branch=user.userprofile.branch)
            ).first()
            available_qty = product_stock.quantity
            resp["Response"]["available_qty"] = available_qty

    return JsonResponse(resp)


# Ajax call function
# This function take category and return all its sub category
@login_required
def get_subcategory_by_category(request):
    if request.method == "POST":
        received_data = QueryDict(request.body)
        category = received_data.get("category")
        category = Catagories.objects.filter(
            Q(name=category) & Q(branch=request.user.userprofile.branch)
        ).first()
        subcategory_list = (
            SubCatagories.objects.filter(
                Q(catagory=category) & Q(branch=request.user.userprofile.branch)
            )
            .values_list("name")
            .distinct()
        )
        subcategory_list = [item[0] for item in subcategory_list]

        response_data = {"subcategory": subcategory_list}
    return JsonResponse(response_data)


@login_required
def get_subcategory_by_category_id(request):
    if request.method == "POST":
        received_data = QueryDict(request.body)
        category = received_data.get("category")
        category = Catagories.objects.filter(
            Q(id=int(category)) & Q(branch=request.user.userprofile.branch)
        ).first()
        subcategory_list = (
            SubCatagories.objects.filter(
                Q(catagory=category) & Q(branch=request.user.userprofile.branch)
            )
            .values_list("name", "id")
            .distinct()
        )

        subcategory_list = [
            {"name": item[0], "id": item[1]} for item in subcategory_list
        ]

        response_data = {"subcategory": subcategory_list}
    return JsonResponse(response_data)


# end of product functions


# Catagories functions start here
@user_passes_test(
    partial(check_permission, page="Category"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def catagories(request):
    user = request.user
    if user.is_superuser:
        data = Catagories.objects.all().order_by("-pk")
    else:
        data = Catagories.objects.filter(branch=user.userprofile.branch).order_by("-pk")
    context = {
        "data": data,
    }
    return render(request, "catagories.html", context)


@user_passes_test(
    partial(check_permission, page="Category"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def catagoryForm(request):
    data = CatagoriesForm()
    context = {
        "form": data,
    }
    return render(request, "addcatagory.html", context)


@login_required
def addCatagory(request):
    if request.method == "POST":
        name = request.POST.get("name")
        data = Catagories()
        data.name = name
        data.branch = request.user.userprofile.branch
        try:
            data.save()
        except IntegrityError as e:
            messages.error(request, "Catagory already exists.")
            return redirect("catagoryform")
    return HttpResponseRedirect("/catagories")


@login_required
def addCatagoryModal(request):
    if request.method == "POST":
        name = request.POST.get("name")
        data = Catagories()
        data.name = name
        data.branch = request.user.userprofile.branch
        try:
            data.save()
        except IntegrityError as e:
            messages.error(request, "Catagory already exists.")
            return HttpResponseRedirect("/productform")
    return HttpResponseRedirect("/productform")


@login_required
def addCatagoryModalAjax(request):

    received_data = QueryDict(request.body)
    catagory = received_data.get("catagory")

    data = Catagories()
    data.name = catagory
    data.branch = request.user.userprofile.branch

    try:
        data.save()
        catid = (
            Catagories.objects.filter(
                Q(name=catagory) & Q(branch=request.user.userprofile.branch)
            )
            .first()
            .id
        )
        resp = {"catagory": catagory, "id": catid}
    except IntegrityError as e:
        # messages.error(request, "Catagory already exists.")
        resp = "error"

    return JsonResponse({"Response": resp})


@user_passes_test(
    partial(check_permission, page="Category"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def updateCatagoryForm(request, id):
    catagory = Catagories.objects.get(id=id)
    context = {
        "catagory": catagory,
    }
    return render(request, "catagoryedit.html", context)


@login_required
def updateCatagory(request, id):
    if request.method == "POST":
        catagory = Catagories.objects.get(id=id)
        catagory.name = request.POST.get("name")
        try:
            catagory.save()
        except IntegrityError as e:
            messages.error(request, "Catagory already exists.")
            return redirect(reverse("updatecatagoryform", kwargs={"id": id}))
    return redirect("catagories")


# end of catagory functions


# sub Catagories functions starts here


@user_passes_test(
    partial(check_permission, page="Subcategory"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def subCatagories(request):
    user = request.user
    if user.is_superuser:
        data = SubCatagories.objects.all().order_by("-pk")
    else:
        data = SubCatagories.objects.filter(branch=user.userprofile.branch).order_by(
            "-pk"
        )
    context = {"data": data}
    return render(request, "subcatagories.html", context)


@user_passes_test(
    partial(check_permission, page="Subcategory"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def subCatagoryForm(request):
    data = SubCatagoriesForm()
    category = Catagories.objects.filter(branch=request.user.userprofile.branch)
    context = {
        "form": data,
        "catagory_list": category,
    }
    return render(request, "addsubcatagory.html", context)


@login_required
def addSubCatagory(request):
    if request.method == "POST":
        data = SubCatagories()
        catagory = Catagories.objects.get(id=request.POST.get("catagory"))
        data.name = request.POST.get("name")
        data.catagory = catagory
        data.branch = request.user.userprofile.branch
        try:
            data.save()
        except IntegrityError as e:
            messages.error(request, "SubCatagory already exists.")
            return redirect("subcatagoryform")
    return HttpResponseRedirect("/subcatagories")


@login_required
def addSubCatagoryModal(request):
    if request.method == "POST":
        data = SubCatagories()
        catagory = Catagories.objects.get(id=int(request.POST.get("catagory")))
        data.name = request.POST.get("name")
        data.catagory = catagory
        data.branch = request.user.userprofile.branch
        try:
            data.save()
        except IntegrityError as e:
            messages.error(request, "SubCatagory already exists.")
            return HttpResponseRedirect("/productform")
    return HttpResponseRedirect("/productform")


@login_required
def addSubCatagoryModalAjax(request):
    received_data = QueryDict(request.body)
    sub_catagory = received_data.get("subCatagory")
    catid = received_data.get("catId")

    data = SubCatagories()
    catagory = Catagories.objects.get(id=int(catid))
    data.name = sub_catagory
    data.catagory = catagory
    data.branch = request.user.userprofile.branch

    try:
        data.save()
        resp = {"SubCatagory": sub_catagory}
    except IntegrityError as e:
        messages.error(request, "SubCatagory already exists.")
        resp = "error"

    return JsonResponse({"Response": resp})


@user_passes_test(
    partial(check_permission, page="Subcategory"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def updateSubCatagoryForm(request, id):
    user = request.user
    subcatagory = SubCatagories.objects.get(id=id)
    catagories = Catagories.objects.filter(branch=request.user.userprofile.branch)
    context = {
        "subcatagory": subcatagory,
        "catagory_list": catagories,
    }
    return render(request, "subcatagoryedit.html", context)


@login_required
def updateSubCatagory(request, id):
    if request.method == "POST":
        subcatagory = SubCatagories.objects.get(id=id)
        subcatagory.name = request.POST.get("name")
        subcatagory.catagory = Catagories.objects.get(id=request.POST.get("catagory"))
        try:
            subcatagory.save()
        except IntegrityError as e:
            messages.error(request, "SubCatagory already exists.")
            return redirect(reverse("updatesubcatagoryform", kwargs={"id": id}))
    return redirect("subcatagories")


# end of sub catagory functions


# Supplier functions starts here


@user_passes_test(
    partial(check_permission, page="Supplier"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def supplier(request):
    user = request.user
    if user.is_superuser:
        data = Suppliers.objects.all().order_by("-pk")
    else:
        data = Suppliers.objects.filter(branch=user.userprofile.branch).order_by("-pk")
    context = {
        "data": data,
    }
    return render(request, "supplier.html", context)


@user_passes_test(
    partial(check_permission, page="Supplier"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def supplierForm(request):
    data = SupplierForm()
    context = {
        "form": data,
        "user": request.user,
    }
    return render(request, "addsupplier.html", context)


@login_required
def addSupplier(request, page):
    if request.method == "POST":
        name = request.POST.get("name")
        gst = request.POST.get("gst")
        contact = request.POST.get("contact")
        address = request.POST.get("address")
        data = Suppliers()
        data.name = name
    
        if gst:
            if gst != '':
                existing_supplier = Suppliers.objects.filter(gst=gst).exists()
                if existing_supplier:
                    messages.error(request, "A supplier with this VAT number already exists!")
                    return redirect('supplierform')
                else:
                    data.gst = gst
        if contact:
            data.contact = contact
        if address:
            data.address = address
        data.branch = request.user.userprofile.branch
        try:
            data.save()

            func_create_supplier_ledger(data, data.id, request)

        except IntegrityError as e:
            messages.error(request, "Supplier already exists.")
            if page == "purchase":
                products = Products.objects.filter(
                    branch=request.user.userprofile.branch
                )
                suppliers = Suppliers.objects.filter(
                    branch=request.user.userprofile.branch
                )
                tax = Tax.objects.filter(branch=request.user.userprofile.branch)

                data1 = PurchaseForm()
                context = {
                    "products": products,
                    "suppliers": suppliers,
                    "tax": tax,
                    "added_supplier": "",
                }
                return render(request, "addpurchase.html", context)
            else:
                return redirect("supplierform")


    if page == "purchase":
        products = Products.objects.filter(branch=request.user.userprofile.branch)
        added_supplier = Suppliers.objects.all().order_by("-id").first().name
        suppliers = Suppliers.objects.all()
        suppliers = [
            sup
            for sup in Suppliers.objects.filter(branch=request.user.userprofile.branch)
            if sup.name != added_supplier
        ]
        tax = Tax.objects.filter(branch=request.user.userprofile.branch)
        data1 = PurchaseForm()
        context = {
            "products": products,
            "suppliers": suppliers,
            "tax": tax,
            "added_supplier": added_supplier,
        }
        return render(request, "addpurchase.html", context)
    else:
        return HttpResponseRedirect("/supplier")


# SG-46
@never_cache
@login_required
def addsupplierfrompurchase(request):

    received_data = QueryDict(request.body)
    name = received_data.get("name")
    phone = received_data.get("phone")
    gstin = received_data.get("gstin")
    address = received_data.get("address")
    branch = request.user.userprofile.branch

    data = Suppliers()
    data.name = name
    data.gst = gstin
    data.contact = phone
    data.address = address
    data.branch = branch

    existing_supplier = Suppliers.objects.filter(gst=gstin).exists()
    if existing_supplier and gstin != "":
        resp="exist_error_gst"
    else:
        try:
            data.save()
            resp = {
                "name": name,
                "gstin": gstin,
                "phone": phone,
                "address": address,
                "id": Suppliers.objects.filter(Q(name=name) & Q(branch=branch)).first().id,
            }
            func_create_supplier_ledger(data, data.id, request)
        except IntegrityError as e:
            resp = "exist_error"
        except:
            resp = "error"

    return JsonResponse({"Response": resp})


@never_cache
@login_required
def updateSupplierForm(request, id):
    supplier = Suppliers.objects.get(id=id)
    context = {
        "supplier": supplier,
    }
    return render(request, "supplieredit.html", context)


@login_required
def updateSupplier(request, id):
    if request.method == "POST":
        supplier = Suppliers.objects.get(id=id)
        supplier.name = request.POST.get("name")
        gst = request.POST.get("gst")
        contact = request.POST.get("contact")
        address = request.POST.get("address")
        if gst:
            supplier.gst = gst
        if contact:
            supplier.contact = contact
        if address:
            supplier.address = address
        try:
            supplier.save()
        except IntegrityError as e:
            messages.error(request, "Supplier already exists.")
            return redirect(reverse("updatesupplierform", kwargs={"id": id}))
    return redirect("supplier")


# end of supplier functions


# Brand


@user_passes_test(
    partial(check_permission, page="Brand"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def brand(request):
    user = request.user
    if user.is_superuser:
        data = Brand.objects.all().order_by("-pk")
    else:
        data = Brand.objects.filter(branch=user.userprofile.branch).order_by("-pk")
    context = {
        "data": data,
    }
    return render(request, "brand.html", context)


@user_passes_test(
    partial(check_permission, page="Brand"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def brandForm(request):
    data = BrandForm()
    context = {
        "form": data,
    }
    return render(request, "addbrand.html", context)


@login_required
def addBrand(request):
    if request.method == "POST":
        name = request.POST.get("name")
        data = Brand()
        data.name = name
        data.branch = request.user.userprofile.branch
        try:
            data.save()
        except IntegrityError as e:
            messages.error(request, "Brand already exists.")
            return redirect("brandform")
    return HttpResponseRedirect("/brand")


@login_required
def addBrandModal(request):
    if request.method == "POST":
        name = request.POST.get("name")
        data = Brand()
        data.name = name
        data.branch = request.user.userprofile.branch
        try:
            data.save()
        except IntegrityError as e:
            messages.error(request, "Brand already exists.")
            return HttpResponseRedirect("/productform")
    return HttpResponseRedirect("/productform")


@login_required
def addBrandModalAjax(request):

    request_dict = QueryDict(request.body)
    brandname = request_dict.get("brandName")

    name = brandname
    data = Brand()
    data.name = brandname
    data.branch = request.user.userprofile.branch
    try:
        data.save()
        resp = {"Brand": brandname}
    except IntegrityError as e:
        resp = "error"
    return JsonResponse({"Response": resp})


@user_passes_test(
    partial(check_permission, page="Brand"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def updateBrandForm(request, id):
    brand = Brand.objects.get(id=id)
    context = {"brand": brand}
    return render(request, "brandedit.html", context)


@login_required
def updateBrand(request, id):
    if request.method == "POST":
        brand = Brand.objects.get(id=id)
        brand.name = request.POST.get("name")
        try:
            brand.save()
        except IntegrityError as e:
            messages.error(request, "Brand already exists.")
            return redirect(reverse("updatebrandform", kwargs={"id": id}))
    return redirect("brand")


# end of brand functions


# Packing
@user_passes_test(
    partial(check_permission, page="Packing"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def packing(request):
    user = request.user
    if user.is_superuser:
        data = Packing.objects.all().order_by("-pk")
    else:
        data = Packing.objects.filter(branch=user.userprofile.branch).order_by("-pk")
    context = {
        "data": data,
    }
    return render(request, "packing.html", context)


@user_passes_test(
    partial(check_permission, page="Packing"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def packingForm(request):
    data = PackingForm()
    context = {
        "form": data,
    }
    return render(request, "addpacking.html", context)


@login_required
def addPacking(request):
    if request.method == "POST":
        name = request.POST.get("name")
        data = Packing()
        data.name = name
        data.branch = request.user.userprofile.branch
        try:
            data.save()
        except IntegrityError as e:
            messages.error(request, "Packing already exists.")
            return redirect("packingform")
    return HttpResponseRedirect("/packing")


@login_required
def addPackingModal(request):
    if request.method == "POST":
        name = request.POST.get("name")
        data = Packing()
        data.name = name
        data.branch = request.user.userprofile.branch
        try:
            data.save()
        except IntegrityError as e:
            messages.error(request, "Packing already exists.")
            return HttpResponseRedirect("/productform")
    return HttpResponseRedirect("/productform")


@login_required
def addPackingModalAjax(request):

    request_dict = QueryDict(request.body)
    packing_name = request_dict.get("packingName")

    data = Packing()
    data.name = packing_name
    data.branch = request.user.userprofile.branch
    try:
        data.save()
        resp = {"Packing": packing_name}
    except IntegrityError as e:
        resp = "error"
    return JsonResponse({"Response": resp})

@never_cache
@login_required
def updatePackingForm(request, id):
    packing = Packing.objects.get(id=id)
    context = {
        "packing": packing,
    }
    return render(request, "packingedit.html", context)


@login_required
def updatePacking(request, id):
    if request.method == "POST":
        packing = Packing.objects.get(id=id)
        packing.name = request.POST.get("name")
        try:
            packing.save()
        except IntegrityError as e:
            messages.error(request, "Packing already exists.")
            return redirect(reverse("updatepackingform", kwargs={"id": id}))
    return redirect("packing")


# end of packing functions


# Tax


@user_passes_test(
    partial(check_permission, page="Tax"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def tax(request):
    user = request.user
    if user.is_superuser:
        data = Tax.objects.all().order_by("-pk")
    else:
        data = Tax.objects.filter(branch=user.userprofile.branch).order_by("-pk")
    context = {
        "data": data,
    }
    return render(request, "tax.html", context)


@user_passes_test(
    partial(check_permission, page="Tax"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def taxForm(request):
    data = TaxForm()
    context = {
        "form": data,
    }
    return render(request, "addtax.html", context)


@login_required
def addTax(request):
    if request.method == "POST":
        name = request.POST.get("name")
        percentage = request.POST.get("percentage")
        data = Tax()
        data.name = name
        data.percentage = percentage
        data.branch = request.user.userprofile.branch
        try:
            data.save()
        except IntegrityError as e:
            messages.error(request, "Tax already exists.")
            return redirect("taxform")
    return HttpResponseRedirect("/tax")


@login_required
def addTaxModal(request):
    if request.method == "POST":
        name = request.POST.get("name")
        percentage = request.POST.get("percentage")
        data = Tax()
        data.name = name
        data.percentage = percentage
        data.branch = request.user.userprofile.branch
        try:
            data.save()
        except IntegrityError as e:
            messages.error(request, "Tax already exists.")
            return HttpResponseRedirect("/productform")
    return HttpResponseRedirect("/productform")


@login_required
def addPurchaseTaxModalAjax(request):
    # if request.method == 'POST':
    request_dict = QueryDict(request.body)
    name = request_dict.get("taxName")
    percentage = request_dict.get("taxNumber")
    data = Tax()
    data.name = name
    data.percentage = percentage
    data.branch = request.user.userprofile.branch
    try:
        data.save()
        taxid = (
            Tax.objects.filter(Q(name=name) & Q(branch=request.user.userprofile.branch))
            .first()
            .id
        )
        resp = {"Tax": name, "Percentage": percentage, "Id": taxid}
    except IntegrityError as e:
        # messages.error(request, "Tax already exists.")
        resp = "error"
    return JsonResponse({"Response": resp})


@login_required
def addSaleTaxModalAjax(request):
    # if request.method == 'POST':
    request_dict = QueryDict(request.body)
    name = request_dict.get("taxName")
    percentage = request_dict.get("taxNumber")
    data = Tax()
    data.name = name
    data.percentage = percentage
    data.branch = request.user.userprofile.branch
    try:
        data.save()
        taxid = (
            Tax.objects.filter(Q(name=name) & Q(branch=request.user.userprofile.branch))
            .first()
            .id
        )
        resp = {"Tax": name, "Percentage": percentage, "Id": taxid}
    except IntegrityError as e:
        # messages.error(request, "Tax already exists.")
        resp = "error"
    return JsonResponse({"Response": resp})


@user_passes_test(
    partial(check_permission, page="Tax"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def updateTaxForm(request, id):
    tax = Tax.objects.get(id=id)
    context = {
        "tax": tax,
    }
    return render(request, "taxedit.html", context)


@login_required
def updateTax(request, id):
    if request.method == "POST":
        tax = Tax.objects.get(id=id)
        tax.name = request.POST.get("name")
        tax.percentage = request.POST.get("percentage")
        try:
            tax.save()
        except IntegrityError as e:
            messages.error(request, "Tax already exists.")
            return redirect(reverse("updatetaxform", kwargs={"id": id}))
        except ValidationError as valerr:
            messages.error(
                request,
                "Cannot update Tax entry as it is referenced by Sale,Purchase or BranchPurchase entries.",
            )
            return redirect(reverse("updatetaxform", kwargs={"id": id}))
        except Exception as exx:
            messages.error(
                request,
                "Cannot update Tax entry as it is referenced by Sale,Purchase or BranchPurchase entries.",
            )
            return redirect(reverse("updatetaxform", kwargs={"id": id}))
    return redirect("tax")


@login_required
def deleteTax(request, id):

    try:
        tax = Tax.objects.get(id=id)
        tax.delete()
    except ValidationError as valerr:
        messages.error(
            request, "Cannot delete Tax entry as it is referenced by Product entries."
        )
        return redirect("tax")
    except Exception as exx:
        messages.error(
            request, "Cannot delete Tax entry as it is referenced by Product entries."
        )
        return redirect("tax")

    return redirect("tax")


# end of tax functions


# Type


@user_passes_test(
    partial(check_permission, page="Type"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def type(request):
    user = request.user
    if user.is_superuser:
        data = Type.objects.all().order_by("-pk")
    else:
        data = Type.objects.filter(branch=user.userprofile.branch).order_by("-pk")
    context = {
        "data": data,
    }
    return render(request, "type.html", context)


@user_passes_test(
    partial(check_permission, page="Type"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def typeForm(request):
    data = TypeForm()
    context = {
        "form": data,
    }
    return render(request, "addtype.html", context)


@login_required
def addType(request):
    if request.method == "POST":
        name = request.POST.get("name")
        data = Type()
        data.name = name
        data.branch = request.user.userprofile.branch
        try:
            data.save()
        except IntegrityError as e:
            messages.error(request, "Type already exists.")
            return redirect("typeform")
    return HttpResponseRedirect("/type")


@login_required
def addTypeModal(request):
    if request.method == "POST":
        name = request.POST.get("name")
        data = Type()
        data.name = name
        data.branch = request.user.userprofile.branch
        try:
            data.save()
        except IntegrityError as e:
            messages.error(request, "Type already exists.")
            return HttpResponseRedirect("/productform")
    return HttpResponseRedirect("/productform")


@login_required
def addTypeModalAjax(request):

    request_dict = QueryDict(request.body)
    type_name = request_dict.get("typeName")

    data = Type()
    data.name = type_name
    data.branch = request.user.userprofile.branch
    try:
        data.save()
        resp = {"Type": type_name}
    except IntegrityError as e:
        resp = "error"
    return JsonResponse({"Response": resp})


@never_cache
@login_required
def updateTypeForm(request, id):
    type = Type.objects.get(id=id)
    context = {
        "type": type,
    }
    return render(request, "typeedit.html", context)


@login_required
def updateType(request, id):
    if request.method == "POST":
        type = Type.objects.get(id=id)
        type.name = request.POST.get("name")
        try:
            type.save()
        except IntegrityError as e:
            messages.error(request, "Type already exists.")
            return redirect(reverse("updatetypeform", kwargs={"id": id}))
    return redirect("type")


# end of type functions


# Branch


@user_passes_test(
    partial(check_permission, page="Branch"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def branch(request):
    data = Branch.objects.filter(
        Q(branchtype="Own") | Q(branchtype="Franchise")
    ).order_by("-pk")
    context = {
        "data": data,
    }
    return render(request, "branch.html", context)


@user_passes_test(
    partial(check_permission, page="Branch"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def branchForm(request):
    data = BranchForm()
    context = {"form": data}
    return render(request, "addbranch.html", context)


@login_required
def addBranch(request, page):
    user = request.user
    if request.method == "POST":
        name = request.POST.get("name")
        branchtype = request.POST.get("branchtype")
        phone = request.POST.get("phone")
        address = request.POST.get("address")
        category = request.POST["branchcategory"]
        gstin = request.POST["gstin"]
        data = Branch()
        data.name = name
        data.branchtype = branchtype
        data.phone = phone
        data.address = address
        data.branchcategory = category
        data.gstin = gstin

        create_ledger = ledgercli.LedgerBook(name)
        create_ledger.create_ledger()

        try:
            data.save()
        except IntegrityError as e:
            messages.error(
                request, f"Branch/External Customer with the same name already exists."
            )
            return redirect("branchform")
        except:
            messages.error(request, f"Something went wrong.")
            return redirect("branchform")

    if page == "sale":
        products = Products.objects.filter(branch=user.userprofile.branch)
        added_branch = (
            Branch.objects.filter(Q(branchtype="Franchise") | Q(branchtype="External"))
            .order_by("-id")
            .first()
        )
        branches = Branch.objects.filter(
            Q(branchtype="Franchise") | Q(branchtype="External")
        )
        branches = [
            br
            for br in Branch.objects.filter(
                Q(branchtype="Franchise") | Q(branchtype="External")
            )
            if br != added_branch
        ]
        tax = Tax.objects.filter(branch=request.user.userprofile.branch)
        data1 = PurchaseForm()
        invoicenumber = UniqueIdGenerator.objects.filter(model="Invoice").last()
        invoicenumber = (
            str(invoicenumber.prefix)
            + f'-{str(date.today().year)[2:]}{datetime.now().strftime("%m")}'
            + str(invoicenumber.uniqueid)
        )
        context = {
            "products": products,
            "customers": branches,
            "tax": tax,
            "invoice_number": invoicenumber,
            "added_customer": added_branch,
        }
        return render(request, "addsale.html", context)
    else:
        return HttpResponseRedirect("/branch")


@user_passes_test(
    partial(check_permission, page="Branch"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def updateBranchForm(request, id):
    branch = Branch.objects.get(id=id)
    context = {"branch": branch}
    return render(request, "branchedit.html", context)


@login_required
def updateBranch(request, id):
    if request.method == "POST":
        branch = Branch.objects.get(id=id)
        branch.name = request.POST.get("name")
        branchtype = request.POST.get("branchtype")
        phone = request.POST.get("phone")
        address = request.POST.get("address")
        category = request.POST["branchcategory"]
        gstin = request.POST["gstin"]
        branch.branchtype = branchtype
        branch.phone = phone
        branch.address = address
        branch.branchcategory = category
        branch.gstin = gstin

        try:
            branch.save()
        except IntegrityError as e:
            messages.error(
                request, f"Branch/External customer with the same name already exists."
            )
            return redirect(reverse("updatebranchform", kwargs={"id": id}))
        except:
            messages.error(request, f"Something went wrong.")
            return redirect(reverse("updatebranchform", kwargs={"id": id}))
    return redirect(reverse("updatebranchform", kwargs={"id": id}))


# this is the function for ajax , ajax send the branch and this function will return
# all the users in that branch in a list , this is for the customer list filter functionality
@login_required
def get_user_by_branch(request):
    if request.method == "POST":
        received_data = QueryDict(request.body)
        branch = received_data.get("branch")
        branch = Branch.objects.filter(name=branch).first()
        user = [i.user.username for i in UserProfile.objects.filter(branch=branch)]
        response_data = {
            "message": "User details fetched successfully.",
            "added_by": user,
        }
        return JsonResponse(response_data)


# end of branch functions

# external customers function starts here


@login_required
def externalcustomers(request):

    data = Branch.objects.filter(branchtype="External")

    context = {"data": data}
    return render(request, "externalcustomers.html", context)


@never_cache
@login_required
def updateexternalcustomerform(request, id):
    branch = Branch.objects.get(id=id)
    context = {"branch": branch}
    return render(request, "externalcustomeredit.html", context)


@login_required
def updateexternalcustomer(request, id):
    if request.method == "POST":
        branch = Branch.objects.get(id=id)
        branch.name = request.POST.get("name")
        branchtype = request.POST.get("branchtype")
        phone = request.POST.get("phone")
        address = request.POST.get("address")
        category = request.POST["branchcategory"]
        gstin = request.POST["gstin"]
        branch.branchtype = branchtype
        branch.phone = phone
        branch.address = address
        branch.branchcategory = category
        branch.gstin = gstin
        try:
            branch.save()
        except IntegrityError as e:
            messages.error(
                request, f"Branch/External customer with the same name already exists."
            )
            return redirect(reverse("updateexternalcustomerform", kwargs={"id": id}))
        except:
            messages.error(request, f"Something went wrong.")
            return redirect(reverse("updateexternalcustomerform", kwargs={"id": id}))
    return redirect(reverse("updateexternalcustomerform", kwargs={"id": id}))


# end of external customers


# purchase functions starts here
@user_passes_test(
    partial(check_permission, page="Purchaselist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def purchase(request):
    currentuser = request.user
    if currentuser.is_superuser:
        homebranch = Branch.objects.get(name="WAREHOUSE")

        # data_purchase = Purchase.objects.filter(branch=homebranch).order_by('-pk')

        data_purchase = Purchase.objects.filter(
            Q(branch=homebranch)
            & ~Q(purchase_type="transfer")
            & ~Q(purchase_type="stockadd")
        ).order_by("-pk")

        # data_branch_purchase = BranchPurchase.objects.all.order_by('-pk')

        data_branch_purchase = BranchPurchase.objects.filter(
            ~Q(purchase_type="transfer") & ~Q(purchase_type="stockadd")
        ).order_by("-pk")
        data = []
        for item in data_purchase:
            dic = {}
            dic["purchaseid"] = item.purchaseid
            dic["invoicenumber"] = item.invoicenumber
            dic["invoicedate"] = item.invoicedate
            dic["supplier"] = item.supplier
            dic["totalbillingamount"] = item.totalbillingamount
            dic["amountrecieved"] = item.amountrecieved
            dic["duebalance"] = item.duebalance
            dic["branch"] = request.user.userprofile.branch
            dic["createddate"] = item.createddate
            data.append(dic)
        for item in data_branch_purchase:
            dic = {}
            dic["purchaseid"] = item.purchaseid
            dic["invoicenumber"] = item.invoicenumber
            dic["invoicedate"] = item.invoicedate
            dic["supplier"] = item.supplier
            dic["externalsupplier"] = item.externalsupplier
            dic["totalbillingamount"] = item.totalbillingamount
            dic["amountrecieved"] = item.amountrecieved
            dic["duebalance"] = item.duebalance
            dic["branch"] = item.branch
            dic["createddate"] = item.createddate
            data.append(dic)
        purchaseid_set = set()
        datafinal = [
            purchase
            for purchase in data
            if (
                purchase["purchaseid"] not in purchaseid_set
                and not purchaseid_set.add(purchase["purchaseid"])
            )
        ]
        datafinal = sorted(datafinal, key=lambda x: x["createddate"], reverse=True)
    else:
        homebranch = UserProfile.objects.get(user=currentuser).branch
        data = BranchPurchase.objects.filter(
            Q(branch=homebranch)
            & ~Q(purchase_type="transfer")
            & ~Q(purchase_type="stockadd")
        ).order_by("-pk")
        # data = BranchPurchase.objects.filter(branch=homebranch).order_by('-pk')
        purchaseid_set = set()
        datafinal = [
            purchase
            for purchase in data
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

    context = {"data": datafinal, "user": currentuser}
    return render(request, "purchase.html", context)






# purchase functions starts here
@user_passes_test(
    partial(check_permission, page="Purchaselist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def purchase_payable(request):
    currentuser = request.user
    if currentuser.is_superuser:
        homebranch = Branch.objects.get(name="WAREHOUSE")

        # data_purchase = Purchase.objects.filter(branch=homebranch).order_by('-pk')

        data_purchase = Purchase.objects.filter(
            Q(branch=homebranch)
            & ~Q(purchase_type="transfer")
            & ~Q(purchase_type="stockadd")
            & Q(amountrecieved__lt=F("totalbillingamount"))
        ).order_by("-pk")

        # data_branch_purchase = BranchPurchase.objects.all.order_by('-pk')

        data_branch_purchase = BranchPurchase.objects.filter(
            ~Q(purchase_type="transfer") & ~Q(purchase_type="stockadd")  & Q(amountrecieved__lt=F("totalbillingamount"))
        ).order_by("-pk")
        data = []
        for item in data_purchase:
            dic = {}
            dic["purchaseid"] = item.purchaseid
            dic["invoicenumber"] = item.invoicenumber
            dic["invoicedate"] = item.invoicedate
            dic["supplier"] = item.supplier
            dic["totalbillingamount"] = item.totalbillingamount
            dic["amountrecieved"] = item.amountrecieved
            dic["duebalance"] = item.duebalance
            dic["branch"] = request.user.userprofile.branch
            dic["createddate"] = item.createddate
            data.append(dic)
        for item in data_branch_purchase:
            dic = {}
            dic["purchaseid"] = item.purchaseid
            dic["invoicenumber"] = item.invoicenumber
            dic["invoicedate"] = item.invoicedate
            dic["supplier"] = item.supplier
            dic["externalsupplier"] = item.externalsupplier
            dic["totalbillingamount"] = item.totalbillingamount
            dic["amountrecieved"] = item.amountrecieved
            dic["duebalance"] = item.duebalance
            dic["branch"] = item.branch
            dic["createddate"] = item.createddate
            data.append(dic)
        purchaseid_set = set()
        datafinal = [
            purchase
            for purchase in data
            if (
                purchase["purchaseid"] not in purchaseid_set
                and not purchaseid_set.add(purchase["purchaseid"])
            )
        ]
        datafinal = sorted(datafinal, key=lambda x: x["createddate"], reverse=True)
    else:
        homebranch = UserProfile.objects.get(user=currentuser).branch
        data = BranchPurchase.objects.filter(
            Q(branch=homebranch)
            & ~Q(purchase_type="transfer")
            & ~Q(purchase_type="stockadd")
             & Q(amountrecieved__lt=F("totalbillingamount"))
        ).order_by("-pk")
        # data = BranchPurchase.objects.filter(branch=homebranch).order_by('-pk')
        purchaseid_set = set()
        datafinal = [
            purchase
            for purchase in data
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

    context = {"data": datafinal, "user": currentuser}
    return render(request, "purchasepayable.html", context)



@user_passes_test(
    partial(check_permission, page="Purchaselist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def bulkStockList(request):
    currentuser = request.user
    if currentuser.is_superuser:
        homebranch = Branch.objects.get(name="WAREHOUSE")

        # data_purchase = Purchase.objects.filter(branch=homebranch).order_by('-pk')

        data_purchase = Purchase.objects.filter(
            Q(branch=homebranch) & Q(purchase_type="stockadd")
        ).order_by("-pk")

        # data_branch_purchase = BranchPurchase.objects.all.order_by('-pk')

        data_branch_purchase = BranchPurchase.objects.filter(
            purchase_type="stockadd"
        ).order_by("-pk")
        data = []
        for item in data_purchase:
            dic = {}
            dic["purchaseid"] = item.purchaseid
            dic["invoicenumber"] = item.invoicenumber
            dic["invoicedate"] = item.invoicedate
            dic["supplier"] = item.supplier
            dic["totalbillingamount"] = item.totalbillingamount
            dic["amountrecieved"] = item.amountrecieved
            dic["duebalance"] = item.duebalance
            dic["branch"] = request.user.userprofile.branch
            dic["createddate"] = item.createddate
            data.append(dic)
        for item in data_branch_purchase:
            dic = {}
            dic["purchaseid"] = item.purchaseid
            dic["invoicenumber"] = item.invoicenumber
            dic["invoicedate"] = item.invoicedate
            dic["supplier"] = item.supplier
            dic["externalsupplier"] = item.externalsupplier
            dic["totalbillingamount"] = item.totalbillingamount
            dic["amountrecieved"] = item.amountrecieved
            dic["duebalance"] = item.duebalance
            dic["branch"] = item.branch
            dic["createddate"] = item.createddate
            data.append(dic)
        purchaseid_set = set()
        datafinal = [
            purchase
            for purchase in data
            if (
                purchase["purchaseid"] not in purchaseid_set
                and not purchaseid_set.add(purchase["purchaseid"])
            )
        ]
        datafinal = sorted(datafinal, key=lambda x: x["createddate"], reverse=True)
    else:
        homebranch = UserProfile.objects.get(user=currentuser).branch
        data = BranchPurchase.objects.filter(
            Q(branch=homebranch) & Q(purchase_type="stockadd")
        ).order_by("-pk")
        # data = BranchPurchase.objects.filter(branch=homebranch).order_by('-pk')
        purchaseid_set = set()
        datafinal = [
            purchase
            for purchase in data
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

    context = {"data": datafinal, "user": currentuser}
    return render(request, "bulkstocklist.html", context)


@user_passes_test(
    partial(check_permission, page="Purchaseview"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def bulkStockView(request, pid):

    currentuser = request.user
    if currentuser.is_superuser:
        data = Purchase.objects.filter(purchaseid=pid)
        if not data:
            data = BranchPurchase.objects.filter(purchaseid=pid)
    else:
        data = BranchPurchase.objects.filter(purchaseid=pid)

    # Fetch the common fields from the DB
    for item in data:

        invoicenumber = item.invoicenumber
        invoicedate = item.invoicedate
        if item.branch.name == "WAREHOUSE":
            supplier = item.supplier
        else:
            supplier = item.externalsupplier

        totalamount = item.totalamount
        purchaseid = item.purchaseid
        branch = item.branch
        totalbillingamount = item.totalbillingamount
        amountrecieved = item.amountrecieved
        duebalance = item.duebalance
        discount = item.discount
        discountmethod = item.discountmethod
        paymentmode = item.paymentmode
        totaltax = item.totaltax

        if item.invoice_copy:
            invoice_copy = GLOBAL_VARIABLES["current_host"] + item.invoice_copy.url
        else:
            invoice_copy = ""

        if currentuser.is_superuser:
            pass
        else:
            saleid = item.saleid
        break

    if totaltax == None or totaltax == "":
        totaltax = 0

    context = {
        "totaltax": totaltax,
        "invoicenumber": invoicenumber,
        "invoicedate": invoicedate,
        "supplier": supplier,
        "totalamount": totalamount,
        "purchaseid": purchaseid,
        "branch": branch,
        "data": data,
        "tatalbillingamount": totalbillingamount,
        "amountrecieved": amountrecieved,
        "duebalance": duebalance,
        "discount": discount,
        "discountmethod": discountmethod,
        "paymentmode": paymentmode,
        "invoice_copy": invoice_copy,
        "user": currentuser,
    }
    if currentuser.is_superuser:
        pass
    else:
        context["saleid"] = saleid
    return render(request, "bulkstockview.html", context)


@user_passes_test(
    partial(check_permission, page="Purchaselist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def transferedStockList(request):
    currentuser = request.user
    if currentuser.is_superuser:
        homebranch = Branch.objects.get(name="WAREHOUSE")

        # data_purchase = Purchase.objects.filter(branch=homebranch).order_by('-pk')

        data_purchase = Purchase.objects.filter(
            Q(branch=homebranch) & Q(purchase_type="transfer")
        ).order_by("-pk")

        # data_branch_purchase = BranchPurchase.objects.all.order_by('-pk')

        data_branch_purchase = BranchPurchase.objects.filter(
            purchase_type="transfer"
        ).order_by("-pk")
        data = []
        for item in data_purchase:
            dic = {}
            dic["purchaseid"] = item.purchaseid
            dic["invoicenumber"] = item.invoicenumber
            dic["invoicedate"] = item.invoicedate
            dic["supplier"] = item.supplier
            dic["totalbillingamount"] = item.totalbillingamount
            dic["amountrecieved"] = item.amountrecieved
            dic["duebalance"] = item.duebalance
            dic["branch"] = request.user.userprofile.branch
            dic["createddate"] = item.createddate
            data.append(dic)
        for item in data_branch_purchase:
            dic = {}
            dic["purchaseid"] = item.purchaseid
            dic["invoicenumber"] = item.invoicenumber
            dic["invoicedate"] = item.invoicedate
            dic["supplier"] = item.supplier
            dic["externalsupplier"] = item.externalsupplier
            dic["totalbillingamount"] = item.totalbillingamount
            dic["amountrecieved"] = item.amountrecieved
            dic["duebalance"] = item.duebalance
            dic["branch"] = item.branch
            dic["createddate"] = item.createddate
            data.append(dic)
        purchaseid_set = set()
        datafinal = [
            purchase
            for purchase in data
            if (
                purchase["purchaseid"] not in purchaseid_set
                and not purchaseid_set.add(purchase["purchaseid"])
            )
        ]
        datafinal = sorted(datafinal, key=lambda x: x["createddate"], reverse=True)
    else:
        homebranch = UserProfile.objects.get(user=currentuser).branch
        data = BranchPurchase.objects.filter(
            Q(branch=homebranch) & Q(purchase_type="transfer")
        ).order_by("-pk")
        # data = BranchPurchase.objects.filter(branch=homebranch).order_by('-pk')
        purchaseid_set = set()
        datafinal = [
            purchase
            for purchase in data
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

    context = {"data": datafinal, "user": currentuser}
    return render(request, "transferedstocklist.html", context)


@user_passes_test(
    partial(check_permission, page="Purchaseview"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def transferedStockView(request, pid):
    currentuser = request.user
    if currentuser.is_superuser:
        data = Purchase.objects.filter(purchaseid=pid)
        if not data:
            data = BranchPurchase.objects.filter(purchaseid=pid)
    else:
        data = BranchPurchase.objects.filter(purchaseid=pid)
    # Fetch the common fields from the DB
    for item in data:
        invoicenumber = item.invoicenumber
        invoicedate = item.invoicedate
        if item.supplier == None:
            supplier = item.externalsupplier
        else:
            supplier = item.supplier
        totalamount = item.totalamount
        purchaseid = item.purchaseid
        branch = item.branch
        totalbillingamount = item.totalbillingamount
        amountrecieved = item.amountrecieved
        duebalance = item.duebalance
        discount = item.discount
        discountmethod = item.discountmethod
        paymentmode = item.paymentmode
        totaltax = item.totaltax

        if item.invoice_copy:
            invoice_copy = GLOBAL_VARIABLES["current_host"] + item.invoice_copy.url
        else:
            invoice_copy = ""

        if currentuser.is_superuser:
            pass
        else:
            saleid = item.saleid
        break

    if totaltax == None or totaltax == "":
        totaltax = 0

    context = {
        "totaltax": totaltax,
        "invoicenumber": invoicenumber,
        "invoicedate": invoicedate,
        "supplier": supplier,
        "totalamount": totalamount,
        "purchaseid": purchaseid,
        "branch": branch,
        "data": data,
        "tatalbillingamount": totalbillingamount,
        "amountrecieved": amountrecieved,
        "duebalance": duebalance,
        "discount": discount,
        "discountmethod": discountmethod,
        "paymentmode": paymentmode,
        "invoice_copy": invoice_copy,
        "user": currentuser,
    }
    if currentuser.is_superuser:
        pass
    else:
        context["saleid"] = saleid
    return render(request, "transferedstockview.html", context)


# Detailed view of purchase based on the purchase id
@user_passes_test(
    partial(check_permission, page="Purchaseview"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def purchaseview(request, pid):
    currentuser = request.user
    if currentuser.is_superuser:
        data = Purchase.objects.filter(purchaseid=pid)
        if not data:
            data = BranchPurchase.objects.filter(purchaseid=pid)
    else:
        data = BranchPurchase.objects.filter(purchaseid=pid)
    # Fetch the common fields from the DB
    for item in data:
        invoicenumber = item.invoicenumber
        invoicedate = item.invoicedate
        if item.supplier == None:
            supplier = item.externalsupplier
        else:
            supplier = item.supplier
        totalamount = item.totalamount
        purchaseid = item.purchaseid
        branch = item.branch
        totalbillingamount = item.totalbillingamount
        amountrecieved = item.amountrecieved
        duebalance = item.duebalance
        discount = item.discount
        discountmethod = item.discountmethod
        paymentmode = item.paymentmode
        totaltax = item.totaltax

        if item.invoice_copy:
            invoice_copy = GLOBAL_VARIABLES["current_host"] + item.invoice_copy.url
        else:
            invoice_copy = ""

        if currentuser.is_superuser:
            pass
        else:
            saleid = item.saleid
        break

    if totaltax == None or totaltax == "":
        totaltax = 0

    context = {
        "totaltax": totaltax,
        "invoicenumber": invoicenumber,
        "invoicedate": invoicedate,
        "supplier": supplier,
        "totalamount": totalamount,
        "purchaseid": purchaseid,
        "branch": branch,
        "data": data,
        "tatalbillingamount": totalbillingamount,
        "amountrecieved": amountrecieved,
        "duebalance": duebalance,
        "discount": discount,
        "discountmethod": discountmethod,
        "paymentmode": paymentmode,
        "invoice_copy": invoice_copy,
        "user": currentuser,
    }
    if currentuser.is_superuser:
        pass
    else:
        context["saleid"] = saleid
    return render(request, "purchaseview.html", context)


# Purchase form for adding new purchase
@user_passes_test(
    partial(check_permission, page="Purchaseform"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def purchaseForm(request):
    user = request.user
    products = Products.objects.filter(branch=user.userprofile.branch)
    suppliers = Suppliers.objects.filter(branch=user.userprofile.branch)
    tax = Tax.objects.filter(branch=user.userprofile.branch)
    paymentmode = PaymentMode.objects.all()
    data1 = PurchaseForm()
    context = {
        "products": products,
        "suppliers": suppliers,
        "tax": tax,
        "added_supplier": "",
        "paymentmode": paymentmode,
    }
    return render(request, "addpurchasenew.html", context)


# Ajax function
# This function generate new purchase barcode and return the generated barcode
@login_required
def generate_purchase_barcode(request):
    barcode_number = generate_unique_id("PurchaseBarcode", "PBC")[3::]
    resp = {
        "barcode": barcode_number,
    }
    return JsonResponse(resp)


def func_generate_purchase_pdf(request, id, action):
    # Fetch the common fields from the DB
    currentuser = request.user

    if currentuser.is_superuser:
        # get a list of dictionaries of given values
        data = Purchase.objects.filter(purchaseid=id).values(
            "name", "barcodenumber", "price", "purchasegst", "salegst", "totalquantity"
        )
        purchase = Purchase.objects.filter(purchaseid=id).first()

        if not purchase:
            # get a list of dictionaries of given values
            data = BranchPurchase.objects.filter(purchaseid=id).values(
                "name",
                "barcodenumber",
                "price",
                "purchasegst",
                "salegst",
                "totalquantity",
            )
            purchase = BranchPurchase.objects.filter(purchaseid=id).first()

    else:
        # get a list of dictionaries of given values
        data = BranchPurchase.objects.filter(purchaseid=id).values(
            "name", "barcodenumber", "price", "purchasegst", "salegst", "totalquantity"
        )
        purchase = BranchPurchase.objects.filter(purchaseid=id).first()

    invoicenumber = purchase.invoicenumber
    invoicedate = purchase.invoicedate
    if purchase.supplier == None:
        supplier = purchase.externalsupplier
    else:
        supplier = purchase.supplier
    purchase_type = purchase.paymentmode
    totalbillingamount = purchase.totalbillingamount
    totalamount = purchase.totalamount
    purchaseid = purchase.purchaseid
    branch = purchase.branch
    amountrecieved = purchase.amountrecieved
    duebalance = purchase.duebalance
    discount = purchase.discount
    discountmethod = purchase.discountmethod

    if purchase.totaltax == None or purchase.totaltax == "":
        totaltax = 0
    else:
        totaltax = purchase.totaltax
    data_list = []
    for item in data:
        data_dict = {
            "name": Products.objects.filter(Q(id=item["name"]) & Q(branch=branch))
            .first()
            .name,
            "barcodenumber": item["barcodenumber"],
            "price": item["price"],
            "purchasegst": item["purchasegst"],
            "salegst": item["salegst"],
            "totalquantity": item["totalquantity"],
        }
        data_list.append(data_dict)

    company = request.user.userprofile.company
    company_name = company.company_name
    if branch.name == "WAREHOUSE":
        address_line1 = company.address_line1
        address_line2 = company.address_line2
        address_line3 = company.address_line3
        phone = ""
    else:
        address_line1 = branch.address
        phone = branch.phone
        address_line2 = ""
        address_line3 = ""

    logo = company.logo_url

    context = {
        "invoicenumber": invoicenumber,
        "invoicedate": invoicedate,
        "supplier": supplier,
        "type": purchase_type,
        "totalbillingamount": totalbillingamount,
        "totalamount": totalamount,
        "purchaseid": purchaseid,
        "branch": branch,
        "data": data_list,
        "amountrecieved": amountrecieved,
        "duebalance": duebalance,
        "discount": discount,
        "discountmethod": discountmethod,
        "id": id,
        "company_name": company_name,
        "address_line1": address_line1,
        "address_line2": address_line2,
        "address_line3": address_line3,
        # 'logo':logo,
        "logo": GLOBAL_VARIABLES["current_host"] + logo.url,
        "totaltax": totaltax,
        "phone": phone,
        "current_user": currentuser,
        "current_host": str(request.get_host()),
    }
    try:
        PAGESIZE = PageSize.objects.filter(active=True).first().size
    except:
        PAGESIZE = "A4"
    # create a template object
    template = get_template("purchasepdf.html")
    # render the context dictionary values
    html = template.render(context)
    options = {"quiet": "", "encoding": "UTF-8", "page-size": PAGESIZE}
    css = os.path.join(BASE_DIR, "core", "static", "css", "purchasepdf.css")
    # generate the pdf from html
    pdf = pdfkit.from_string(html, False, options=options, css=css)
    response = HttpResponse(content_type="application/pdf")
    if action == "download":
        response["Content-Disposition"] = (
            f'attachment; filename="Purchase_Invoice_{date.today()}.pdf"'
        )
    else:
        response["Content-Disposition"] = (
            f'inline; filename="Purchase_Invoice_{date.today()}.pdf"'
        )
    response.write(pdf)
    return response


def compress_image(imagefile):
    image = Image.open(imagefile)
    image_io = io.BytesIO()
    image.save(image_io, format="PNG", optimize=True, quality=30)
    image_content = ContentFile(image_io.getvalue(), name=imagefile.name)
    return image_content










# This function add purchase details entered by superadmin in (warehouse) Purchase Modal
@login_required
def addPurchase(request):



    check_status_with_constant = partial(check_status_common, attribute="quantity")
    length_count = list(filter(check_status_with_constant, request.POST.keys()))


    # return redirect('purchase')

    data = Purchase()
    currentuser = request.user
    if currentuser.is_superuser:
        branch = "WAREHOUSE"
    else:
        branch = UserProfile.objects.get(user=currentuser).branch

    lastPurchaseId = data.unique_id = generate_unique_id("Purchase", "PR")
    try:
        copy = request.FILES["copy"]
    except:
        copy = None

    fs = FileSystemStorage()
    if copy:

        # Process the image to reduce its size
        copy = compress_image(copy)

        filename = fs.save(copy.name, copy)
        uploaded_file_url = fs.url(filename)
    

    for i in range(1, ((len(length_count)+1))):
        i = str(i)
        productname = request.POST.get("name" + i)
        if not productname:
            continue  # Assuming no product supplied in the html form.
        if copy:
            data.invoice_copy = filename
        data.invoicenumber = request.POST["invoicenumber"]
        data.paymentmode = request.POST.get("paymentmode")
        invoicedate = request.POST.get("invoicedate")
        if invoicedate != None and invoicedate != "":
            invoicedate = datetime.strptime(invoicedate, "%d-%m-%Y").strftime(
                "%Y-%m-%d"
            )

        data.invoicedate = invoicedate
        supplierform = request.POST.get("supplier")
        data.supplier = Suppliers.objects.get(
            Q(name=supplierform) & Q(branch=request.user.userprofile.branch)
        )
        data.purchaseid = (
            lastPurchaseId  # Purchase ID will get incremented by 1 for each purchase
        )
        data.name = Products.objects.filter(
            Q(name=productname) & Q(branch=request.user.userprofile.branch)
        ).first()

        if request.POST["barcode" + i]:
            data.barcodenumber = request.POST["barcode" + i]

        price = request.POST["price" + i]
        data.price = price
        sellingprice = request.POST["sellingprice" + i]
        data.sellingprice = sellingprice
        purchasegst = request.POST["purchasegst" + i]
        data.purchasegst = purchasegst
        salegst = request.POST["salegst" + i]
        data.salegst = salegst
        productquantity = request.POST["quantity" + i]
        data.totalquantity = productquantity
        data.branch = Branch.objects.get(name=branch)
        data.totalamount = float(
            request.POST["totalamount"]
        )  # changed request.POST['netamount'] to request.POST['totalamount'] to total amount 11-07-2023
        data.totaltax = float(request.POST["totaltax"])
        data.totalbillingamount = float(request.POST["totalbillingamount"])
        try:
            if request.POST["recieved"] == "":
                data.amountrecieved = 0
            else:
                data.amountrecieved = float(request.POST["recieved"])
        except:
            data.amountrecieved = 0
        data.duebalance = float(request.POST["duebalance"])

        if request.POST["mrp" + i]:
            data.mrp = float(request.POST["mrp" + i])

        if request.POST["mop" + i]:
            data.mop = float(request.POST["mop" + i])

        if request.POST["discount"]:
            data.discount = float(request.POST["discount"])
        else:
            data.discount = 0

        data.discountmethod = request.POST["discountmethod"]
        data.pk = None  # if the primary key is not marked None, only the last row will be saved
        data.save()
        productid = (
            Products.objects.filter(
                Q(name=productname) & Q(branch=request.user.userprofile.branch)
            )
            .first()
            .id
        )
        # stock table has to be updated with the product count
        # if the product is not there in the stock, create the entry else update the stock quantity.
        stock = Stock()

        if Stock.objects.filter(name_id=productid):
            # Stock.objects.filter(name_id=productid).update(quantity=F('quantity')+ productquantity)
            stock = Stock.objects.filter(name_id=productid).first()
            qty = stock.quantity

            stock.quantity = int(qty) + int(productquantity)
            stock.salerate = float(sellingprice)
            stock.purchaserate = float(price)
            stock.save()

        else:
            stock.name = Products.objects.filter(
                Q(name=productname) & Q(branch=request.user.userprofile.branch)
            ).first()
            stock.quantity = int(productquantity)
            stock.salerate = float(sellingprice)
            stock.purchaserate = float(price)
            stock.save()

        strans_obj = StockTransaction.objects.filter(
            Q(
                product=Products.objects.filter(
                    Q(id=productid) & Q(branch=request.user.userprofile.branch)
                ).first()
            )
            & Q(branch=request.user.userprofile.branch)
        ).first()
        if strans_obj:
            stocktr = StockTransaction()
            stocktr.product = Products.objects.filter(
                Q(id=productid) & Q(branch=request.user.userprofile.branch)
            ).first()
            stocktr.initial_quantity = strans_obj.initial_quantity
            stocktr.quantity = int(productquantity)
            stocktr.transactiontype = "Add"
            stocktr.branch = request.user.userprofile.branch
            stocktr.created_date = invoicedate
            try:
                stocktr.reference_number  = request.POST["invoicenumber"]
                stocktr.transaction_category  = 'Purchase Entry'
            except:
                stocktr.reference_number  = 'NA'
                stocktr.transaction_category  = 'Purchase Entry'
            stocktr.save()
        else:
            stocktr = StockTransaction()
            stocktr.product = Products.objects.filter(
                Q(id=productid) & Q(branch=request.user.userprofile.branch)
            ).first()
            stocktr.initial_quantity = 0
            stocktr.quantity = int(productquantity)
            stocktr.transactiontype = "Add"
            stocktr.branch = request.user.userprofile.branch
            stocktr.created_date = invoicedate
            try:
                stocktr.reference_number  = request.POST["invoicenumber"]
                stocktr.transaction_category  = 'Purchase Entry'
            except:
                stocktr.reference_number  = 'NA'
                stocktr.transaction_category  = 'Purchase Entry'
            stocktr.save()

    if float(request.POST["recieved"]) != 0:
        transaction = Transaction()
        transaction.transactionid = lastPurchaseId
        transaction.amount = float(request.POST["recieved"])
        transaction.transactiontype = "purchase"
        transaction.paymentmode = request.POST["paymentmode"]
        transaction.branch = request.user.userprofile.branch
        transaction.invoice_number = request.POST["invoicenumber"]
        transaction.accounts = request.POST.get("supplier")
        transaction.remarks = ""
        transaction.subledger = func_get_sub_ledgers(request,'Purchase')
        transaction.transactiondate = invoicedate
        
        transaction.save()

    financial_statement = addaccounts.AccountStatement()
    

    ledger_params = {
        "invoicenumber": data.invoicenumber,
        "invoicedate": invoicedate,
        "totalbillingamount": data.totalbillingamount,
        "customer_or_vendor": supplierform,
        "userbranch": data.branch,
        "amountrecieved": data.amountrecieved,
        "duebalance": data.duebalance,
        "paymentmode":request.POST.get("paymentmode")
    }

    financial_statement.add_ledger("Purchase", ledger_params)

    cashbook_params = {
        "userbranch": data.branch,
        "amountrecieved": data.amountrecieved,
        "paymentmode": data.paymentmode,
        "invoicedate": invoicedate,
        "branch_wid":request.user.userprofile.branch,
        'subledger' : func_get_sub_ledgers(request,'Purchase')
    }

    # purchase_ledger = ledgercli.LedgerBook(data.branch)

    # params = {
    #     "billdate": invoicedate,
    #     "billno": data.invoicenumber,
    #     "totalamount": data.totalbillingamount,
    #     "mode": data.paymentmode,
    #     "amountpaid": data.amountrecieved,
    #     "supplier": supplierform,
    #     "duebalance": data.duebalance,
    # }

    # purchase_ledger.post_purchase(**params)

    financial_statement.add_cashbook("Purchase", cashbook_params)

    return HttpResponseRedirect("/purchase")


# @user_passes_test(partial(check_permission, page="Bulkpurchaseform"),login_url='/accessdenied/',redirect_field_name=None)
@never_cache
@login_required
def addBulkPurchaseForm(request):
    if request.method == "POST":
        stock_or_purchase = request.POST.get("stockpurchase")
        # if not stock_or_purchase:
        csv = request.FILES.get("multipurchase")
        if csv == None or csv == "":
            return render(
                request,
                "addmultipurchase.html",
                {
                    "error": ["No entries added"],
                },
            )
        df = pd.read_csv(csv)
        bill_total = {}
        for i, j in enumerate(df["Bill Number"]):

            product = Products.objects.filter(
                Q(id=int(df["Product Id"][i]))
                & Q(branch=request.user.userprofile.branch)
            ).first()
            if not product:
                continue
            bill_no = df["Bill Number"][i]
            total_amount = (
                product.price
                + (product.price * (float(product.purchasegst.percentage) / 100))
            ) * int(df["Quantity"][i])
            total_tax = (
                product.price * (float(product.purchasegst.percentage) / 100)
            ) * int(df["Quantity"][i])
            if bill_no not in bill_total.keys():
                bill_total[bill_no] = {}
                bill_total[bill_no]["total"] = total_amount
                bill_total[bill_no]["total_tax"] = total_tax
                bill_total[bill_no]["purchase_id"] = generate_unique_id(
                    "Purchase", "PR"
                )
                bill_total[bill_no]["supplier_id"] = [df["Supplier Id"][i]]
                bill_total[bill_no]["payment_mode"] = [df["Payment Mode"][i]]
                bill_total[bill_no]["discount"] = [df["Discount"][i]]
                bill_total[bill_no]["amount_paid"] = [df["Amount Paid"][i]]
            else:
                bill_total[bill_no]["total"] += total_amount
                bill_total[bill_no]["total_tax"] += total_tax
                bill_total[bill_no]["supplier_id"].append(df["Supplier Id"][i])
                bill_total[bill_no]["payment_mode"].append(df["Payment Mode"][i])
                bill_total[bill_no]["discount"].append(df["Discount"][i])
                bill_total[bill_no]["amount_paid"].append(df["Amount Paid"][i])

        not_saved = []
        saved = []
        bill_no_list = []
        for i, j in enumerate(df["Bill Number"]):

            try:
                if request.user.is_superuser:
                    purchase_modal = Purchase()
                else:
                    purchase_modal = BranchPurchase()
                product = Products.objects.filter(
                    Q(id=int(df["Product Id"][i]))
                    & Q(branch=request.user.userprofile.branch)
                ).first()
                supplier = Suppliers.objects.filter(
                    Q(id=int(df["Supplier Id"][i]))
                    & Q(branch=request.user.userprofile.branch)
                ).first()
                if not supplier:
                    not_saved.append(
                        f"invalid supplier, supplier id : {df['Supplier Id'][i]} , Row number {i+1},Bill Number {df['Bill Number'][i]} not saved"
                    )
                    continue
                if not product:
                    not_saved.append(
                        f"invalid product, product id : {df['Product Id'][i]} , Row number {i+1},Bill Number {df['Bill Number'][i]} not saved "
                    )
                    continue
                if len(set(bill_total[df["Bill Number"][i]]["supplier_id"])) != 1:
                    not_saved.append(
                        f"Different supplier id in same bill number , Row number {i+1},Bill Number {df['Bill Number'][i]} not saved "
                    )
                    continue

                if len(set(bill_total[df["Bill Number"][i]]["payment_mode"])) != 1:
                    not_saved.append(
                        f"Different Payment mode in same bill number , Row number {i+1},Bill Number {df['Bill Number'][i]} not saved "
                    )
                    continue
                if len(set(bill_total[df["Bill Number"][i]]["discount"])) != 1:
                    not_saved.append(
                        f"Different Discount in same bill number , Row number {i+1},Bill Number {df['Bill Number'][i]} not saved "
                    )
                    continue
                if len(set(bill_total[df["Bill Number"][i]]["amount_paid"])) != 1:
                    not_saved.append(
                        f"Different Amount Paid in same bill number , Row number {i+1},Bill Number {df['Bill Number'][i]} not saved "
                    )
                    continue
                saved.append(
                    f"Row number {i+1},Bill Number {df['Bill Number'][i]} saved successfully"
                )
                purchase_modal.name = product
                purchase_modal.paymentmode = df["Payment Mode"][i]
                if request.user.is_superuser:
                    purchase_modal.supplier = supplier
                else:
                    purchase_modal.externalsupplier = supplier
                purchase_modal.invoicenumber = df["Bill Number"][i]
                purchase_modal.invoicedate = datetime.strptime(
                    df["Bill Date"][i], "%d-%m-%Y"
                ).strftime("%Y-%m-%d")
                purchase_modal.barcodenumber = generate_unique_id(
                    "PurchaseBarcode", "PBC"
                )[3::]
                purchase_modal.totalquantity = int(df["Quantity"][i])
                purchase_modal.price = product.price
                purchase_modal.sellingprice = product.sellingprice
                purchase_modal.purchasegst = product.purchasegst
                purchase_modal.salegst = product.salegst
                purchase_modal.purchaseid = bill_total[df["Bill Number"][i]][
                    "purchase_id"
                ]
                purchase_modal.branch = request.user.userprofile.branch
                purchase_modal.totalamount = bill_total[df["Bill Number"][i]]["total"]
                purchase_modal.totaltax = bill_total[df["Bill Number"][i]]["total_tax"]
                purchase_modal.totalbillingamount = bill_total[df["Bill Number"][i]][
                    "total"
                ]
                if df["Amount Paid"][i] == "Full":
                    purchase_modal.amountrecieved = bill_total[df["Bill Number"][i]][
                        "total"
                    ]
                    purchase_modal.duebalance = 0
                else:
                    purchase_modal.amountrecieved = float(df["Amount Paid"][i])
                    purchase_modal.duebalance = bill_total[df["Bill Number"][i]][
                        "total"
                    ] - float(df["Amount Paid"][i])
                purchase_modal.discount = float(df["Discount"][i])
                purchase_modal.discountmethod = "Flat"
                purchase_modal.mrp = product.mrp
                purchase_modal.mop = product.mop
                purchase_modal.save()

                ###################### Adding in stock#####################
                if request.user.is_superuser:
                    stock = Stock()
                    if Stock.objects.filter(name=product):
                        stock = Stock.objects.filter(name=product).first()
                        qty = stock.quantity

                        stock.quantity = int(qty) + int(df["Quantity"][i])
                        stock.save()

                    else:
                        stock.name = Products.objects.filter(
                            Q(name=product) & Q(branch=request.user.userprofile.branch)
                        ).first()
                        stock.quantity = int(df["Quantity"][i])
                        stock.save()
                else:
                    stock = BranchStock()
                    if BranchStock.objects.filter(
                        Q(name=product) & Q(branch=request.user.userprofile.branch)
                    ):
                        stock = BranchStock.objects.filter(
                            Q(name=product) & Q(branch=request.user.userprofile.branch)
                        ).first()
                        qty = stock.quantity
                        stock.quantity = int(qty) + int(df["Quantity"][i])
                        stock.save()
                    else:
                        stock.name = Products.objects.filter(
                            Q(name=product) & Q(branch=request.user.userprofile.branch)
                        ).first()
                        stock.quantity = int(df["Quantity"][i])
                        stock.branch = request.user.userprofile.branch
                        stock.save()

                ######## Adding in stock transaction ###########
                strans_obj = StockTransaction.objects.filter(
                    Q(product=product) & Q(branch=request.user.userprofile.branch)
                ).first()
                stocktr = StockTransaction()
                stocktr.product = Products.objects.filter(
                    Q(id=product.id) & Q(branch=request.user.userprofile.branch)
                ).first()
                if strans_obj:
                    stocktr.initial_quantity = strans_obj.initial_quantity
                else:
                    stocktr.initial_quantity = 0
                stocktr.quantity = int(df["Quantity"][i])
                stocktr.transactiontype = "Add"
                stocktr.branch = request.user.userprofile.branch
                stocktr.created_date = datetime.strptime(
                    df["Bill Date"][i], "%d-%m-%Y"
                ).strftime("%Y-%m-%d")
                try:
                    stocktr.reference_number  = df["Bill Number"][i]
                    stocktr.transaction_category  = 'Bulk Purchase Entry'
                except:
                    stocktr.reference_number  = 'NA'
                    stocktr.transaction_category  = 'Bulk Purchase Entry'
                stocktr.save()

                ########### Adding in accounts ################

                if df["Bill Number"][i] not in bill_no_list:
                    if df["Amount Paid"][i] == "Full":
                        amount_received = bill_total[df["Bill Number"][i]]["total"]
                    else:
                        amount_received = float(df["Amount Paid"][i])
                    bill_total[df["Bill Number"][i]]["total"]
                    financial_statement = addaccounts.AccountStatement()
                    ledger_params = {
                        "invoicenumber": df["Bill Number"][i],
                        "invoicedate": datetime.strptime(
                            df["Bill Date"][i], "%d-%m-%Y"
                        ).strftime("%Y-%m-%d"),
                        "totalbillingamount": bill_total[df["Bill Number"][i]]["total"],
                        "customer_or_vendor": supplier.name,
                        "userbranch": request.user.userprofile.branch,
                        "amountrecieved": amount_received,
                        "duebalance": bill_total[df["Bill Number"][i]]["total"]
                        - amount_received,
                        "paymentmode": df["Payment Mode"][i],
                    }
                    financial_statement.add_ledger("Purchase", ledger_params)



                    cashbook_params = {
                        "userbranch": request.user.userprofile.branch,
                        "amountrecieved": amount_received,
                        "paymentmode": df["Payment Mode"][i],
                        "invoicedate": datetime.strptime(
                            df["Bill Date"][i], "%d-%m-%Y"
                        ).strftime("%Y-%m-%d"),
                        "branch_wid":request.user.userprofile.branch,
                        'subledger' : func_get_sub_ledgers(request,'Purchase')
                    }
                    financial_statement.add_cashbook("Purchase", cashbook_params)
                    bill_no_list.append(df["Bill Number"][i])

            except:
                not_saved.append(f"can't import {product} {df['Bill Number'][i]}")
        if len(not_saved) == 0:
            return render(
                request,
                "addmultipurchase.html",
                {"response": ["Entries added successfully"]},
            )
        else:
            return render(
                request, "addmultipurchase.html", {"error": not_saved, "saved": saved}
            )

    return render(request, "addmultipurchase.html")


@login_required
def downloadBulkPurchaseFormCsv(request):
    current_directory = os.path.dirname(os.path.abspath(__file__))
    csv_filepath = os.path.join(
        current_directory, "static", "files", "AddMultiplePurchaseEntries.csv"
    )
    response = FileResponse(open(csv_filepath, "rb"), content_type="text/csv")
    response["Content-Disposition"] = (
        'attachment; filename="AddMultiplePurchaseEntries.csv"'
    )
    return response


@login_required
def addBulkStock(request):
    if request.method == "POST":
        csv = request.FILES.get("multipurchase")
        if csv == None or csv == "":
            return render(
                request,
                "addmultipurchase.html",
                {
                    "error": ["No entries added"],
                },
            )

        df = pd.read_csv(csv)

        not_saved = []
        saved = []
        bill_no_list = []
        for i, j in enumerate(df["Product Id"]):

            # try:
            if request.user.is_superuser:
                purchase_modal = Purchase()
            else:
                purchase_modal = BranchPurchase()
            product = Products.objects.filter(
                Q(id=int(df["Product Id"][i]))
                & Q(branch=request.user.userprofile.branch)
            ).first()

            if not product:
                not_saved.append(
                    f"invalid product, product id : {df['Product Id'][i]} , Row number {i+1} not saved "
                )
                continue

            purchase_modal.name = product
            # purchase_modal.paymentmode = df['Payment Mode'][i]
            # if request.user.is_superuser:
            #     purchase_modal.supplier = supplier
            # else:
            #     purchase_modal.externalsupplier = supplier
            # purchase_modal.invoicenumber = generate_unique_id('', "PR")
            # purchase_modal.invoicedate = datetime.strptime(df['Bill Date'][i], "%d-%m-%Y").strftime("%Y-%m-%d")
            purchase_modal.barcodenumber = generate_unique_id("PurchaseBarcode", "PBC")[
                3::
            ]
            purchase_modal.totalquantity = int(df["Quantity"][i])
            purchase_modal.price = product.price
            purchase_modal.sellingprice = product.sellingprice
            purchase_modal.purchasegst = product.purchasegst
            purchase_modal.salegst = product.salegst
            purchase_modal.purchase_type = "stockadd"
            purchase_modal.purchaseid = generate_unique_id("Purchase", "PR")
            purchase_modal.branch = request.user.userprofile.branch
            purchase_modal.totalamount = 0
            purchase_modal.totaltax = 0
            purchase_modal.totalbillingamount = 0
            purchase_modal.amountrecieved = 0
            purchase_modal.duebalance = 0
            purchase_modal.discount = 0
            # purchase_modal.discountmethod = 'Flat'
            purchase_modal.mrp = product.mrp
            purchase_modal.mop = product.mop
            purchase_modal.save()

            saved.append(
                f"Row number {i+1},Product Id {df['Product Id'][i]} saved successfully"
            )

            ###################### Adding in stock#####################
            if request.user.is_superuser:
                stock = Stock()
                if Stock.objects.filter(name=product):
                    stock = Stock.objects.filter(name=product).first()
                    qty = stock.quantity

                    stock.quantity = int(qty) + int(df["Quantity"][i])
                    stock.save()

                else:
                    stock.name = Products.objects.filter(
                        Q(name=product) & Q(branch=request.user.userprofile.branch)
                    ).first()
                    stock.quantity = int(df["Quantity"][i])
                    stock.save()
            else:
                stock = BranchStock()
                if BranchStock.objects.filter(
                    Q(name=product) & Q(branch=request.user.userprofile.branch)
                ):
                    stock = BranchStock.objects.filter(
                        Q(name=product) & Q(branch=request.user.userprofile.branch)
                    ).first()
                    qty = stock.quantity
                    stock.quantity = int(qty) + int(df["Quantity"][i])
                    stock.save()
                else:
                    stock.name = Products.objects.filter(
                        Q(name=product) & Q(branch=request.user.userprofile.branch)
                    ).first()
                    stock.quantity = int(df["Quantity"][i])
                    stock.branch = request.user.userprofile.branch
                    stock.save()

            ######## Adding in stock transaction ###########
            strans_obj = StockTransaction.objects.filter(
                Q(product=product) & Q(branch=request.user.userprofile.branch)
            ).first()
            stocktr = StockTransaction()
            stocktr.product = Products.objects.filter(
                Q(id=product.id) & Q(branch=request.user.userprofile.branch)
            ).first()
            if strans_obj:
                stocktr.initial_quantity = strans_obj.initial_quantity
            else:
                stocktr.initial_quantity = 0
            stocktr.quantity = int(df["Quantity"][i])
            stocktr.transactiontype = "Add"
            stocktr.branch = request.user.userprofile.branch
            try:
                stocktr.reference_number  = df["Product Id"][i]
                stocktr.transaction_category  = 'Bulk Stock Entry'
            except:
                stocktr.reference_number  = 'NA'
                stocktr.transaction_category  = 'Bulk Stock Entry'
            stocktr.save()

            # except:
            #     not_saved.append(f"can't import {product}, product id : {df['Product Id'][i]}")
        if len(not_saved) == 0:
            return render(
                request,
                "addbulkstock.html",
                {"response": ["Entries added successfully"]},
            )
        else:
            return render(
                request, "addbulkstock.html", {"error": not_saved, "saved": saved}
            )
    return render(request, "addbulkstock.html")


@login_required
def downloadBulkStockFormCsv(request):
    current_directory = os.path.dirname(os.path.abspath(__file__))
    csv_filepath = os.path.join(
        current_directory, "static", "files", "AddMultipleStockEntries.csv"
    )
    response = FileResponse(open(csv_filepath, "rb"), content_type="text/csv")
    response["Content-Disposition"] = (
        'attachment; filename="AddMultipleStockEntries.csv"'
    )
    return response


# This function add purchase details entered by brand admins in BranchPurchase Modal
@login_required
def addBranchPurchase(request):

    start_time = time.time()


    #checking if invoice number already exists
    if BranchPurchase.objects.filter(invoicenumber=request.POST["invoicenumber"]).exists():
        messages.error(request, "Note : Invoice Number Already Exists")
        return redirect('purchaseform')
    
    check_status_with_constant = partial(check_status_common, attribute="quantity")
    length_count = list(filter(check_status_with_constant, request.POST.keys()))

    data = BranchPurchase()
    ledger = Ledger()
    cashbook = CashBook()
    currentuser = request.user

    if currentuser.is_superuser:
        branch = "WAREHOUSE"
    else:
        branch = UserProfile.objects.get(user=currentuser).branch

    lastPurchaseId = data.unique_id = generate_unique_id("Purchase", "PR")

    try:
        copy = request.FILES["copy"]
    except:
        copy = None
    fs = FileSystemStorage()
    if copy:

        copy = compress_image(copy)
        filename = fs.save(copy.name, copy)
        uploaded_file_url = fs.url(filename)

    supplier_ledger = None
    for i in range(1, ((len(length_count)+1))):
        i = str(i)
        productname = request.POST.get("name" + i)

        if not productname:
            continue  # Assuming no product supplied in the html form.

        # if not request.POST['barcode' + i ]:
        #     continue

        if copy:
            data.invoice_copy = filename
            
        data.invoicenumber = request.POST["invoicenumber"]
        data.paymentmode = request.POST.get("paymentmode")
        invoicedate = request.POST.get("invoicedate")

        if invoicedate != None and invoicedate != "":
            invoicedate = datetime.strptime(invoicedate, "%d-%m-%Y").strftime(
                "%Y-%m-%d"
            )

        data.invoicedate = invoicedate
        supplierform = request.POST.get("supplier")
        data.supplier = None
        data.externalsupplier = Suppliers.objects.get(
            Q(name=supplierform) & Q(branch=request.user.userprofile.branch)
        )

        try:
            sup_obj = Suppliers.objects.get(
            Q(name=supplierform) & Q(branch=request.user.userprofile.branch)
        )
            if sup_obj:
                ledger_title = f"{sup_obj.name} {sup_obj.id}"
                sup_ledger = CoASubAccounts.objects.filter(Q(title=ledger_title)&Q(is_adminonly=True)).first()
                data.supplier_ledger = sup_ledger
                supplier_ledger = sup_ledger
        except:
            pass


        data.purchaseid = (
            lastPurchaseId  # Purchase ID will get incremented by 1 for each purchase
        )
        data.name = Products.objects.filter(
            Q(name=productname) & Q(branch=request.user.userprofile.branch)
        ).first()

        if request.POST["barcode" + i]:
            data.barcodenumber = request.POST["barcode" + i]

        price = request.POST["price" + i]
        data.price = price
        sellingprice = request.POST["sellingprice" + i]
        data.sellingprice = sellingprice
        purchasegst = request.POST["purchasegst" + i]
        data.purchasegst = purchasegst
        salegst = request.POST["salegst" + i]
        data.salegst = salegst
        productquantity = request.POST["quantity" + i]
        data.totalquantity = productquantity
        data.branch = request.user.userprofile.branch
        data.totalamount = float(
            request.POST["totalamount"]
        )  # changed request.POST['netamount'] to request.POST['totalamount'] to total amount 11-07-2023
        data.totaltax = float(request.POST["totaltax"])
        data.totalbillingamount = float(request.POST["totalbillingamount"])
        data.amountrecieved = float(request.POST["recieved"])
        data.duebalance = float(request.POST["duebalance"])

        if request.POST["mrp" + i]:
            data.mrp = float(request.POST["mrp" + i])

        if request.POST["mop" + i]:
            data.mop = float(request.POST["mop" + i])

        if request.POST["discount"]:
            data.discount = float(request.POST["discount"])
        else:
            data.discount = 0

        data.discountmethod = request.POST["discountmethod"]
        data.pk = None  # if the primary key is not marked None, only the last row will be saved
        data.save()

        productid = (
            Products.objects.filter(
                Q(name=productname) & Q(branch=request.user.userprofile.branch)
            )
            .first()
            .id
        )

        # stock table has to be updated with the product count
        # if the product is not there in the stock, create the entry else update the stock quantity.
        stock = BranchStock()
        if BranchStock.objects.filter(
            Q(name_id=productid) & Q(branch=request.user.userprofile.branch)
        ):
            # BranchStock.objects.filter(Q(name_id=productid)&Q(branch=request.user.userprofile.branch)).update(quantity=F('quantity')+ productquantity)

            stock = BranchStock.objects.filter(
                Q(name_id=productid) & Q(branch=request.user.userprofile.branch)
            ).first()
            qty = stock.quantity
            stock.quantity = int(qty) + int(productquantity)
            stock.salerate = float(sellingprice)
            stock.purchaserate = float(price)
            stock.save()
        else:
            stock.name = Products.objects.filter(
                Q(name=productname) & Q(branch=request.user.userprofile.branch)
            ).first()
            stock.quantity = int(productquantity)
            stock.branch = request.user.userprofile.branch
            stock.salerate = float(sellingprice)
            stock.purchaserate = float(price)
            stock.save()

        strans_obj = StockTransaction.objects.filter(
            Q(
                product=Products.objects.filter(
                    Q(name=productname) & Q(branch=request.user.userprofile.branch)
                ).first()
            )
            & Q(branch=request.user.userprofile.branch)
        ).first()
        if strans_obj:
            stocktr = StockTransaction()
            stocktr.product = Products.objects.filter(
                Q(name=productname) & Q(branch=request.user.userprofile.branch)
            ).first()
            stocktr.initial_quantity = strans_obj.initial_quantity
            stocktr.quantity = int(productquantity)
            stocktr.transactiontype = "Add"
            stocktr.branch = request.user.userprofile.branch
            stocktr.created_date = invoicedate
            try:
                stocktr.reference_number  = request.POST["invoicenumber"]
                stocktr.transaction_category  = 'Branch Purchase Entry'
            except:
                stocktr.reference_number  = 'NA'
                stocktr.transaction_category  = 'Branch Purchase Entry'
            stocktr.save()
        else:
            stocktr = StockTransaction()
            stocktr.product = Products.objects.filter(
                Q(name=productname) & Q(branch=request.user.userprofile.branch)
            ).first()
            stocktr.initial_quantity = 0
            stocktr.quantity = int(productquantity)
            stocktr.transactiontype = "Add"
            stocktr.branch = request.user.userprofile.branch
            stocktr.created_date = invoicedate
            try:
                stocktr.reference_number  = request.POST["invoicenumber"]
                stocktr.transaction_category  = 'Branch Purchase Entry'
            except:
                stocktr.reference_number  = 'NA'
                stocktr.transaction_category  = 'Branch Purchase Entry'
            stocktr.save()

    if float(request.POST["recieved"]) != 0:
        transaction = Transaction()
        transaction.transactionid = lastPurchaseId
        transaction.amount = float(request.POST["recieved"])
        transaction.transactiontype = "purchase"
        transaction.paymentmode = request.POST["paymentmode"]
        transaction.branch = request.user.userprofile.branch
        transaction.invoice_number = request.POST["invoicenumber"]
        transaction.accounts = request.POST.get("supplier")
        transaction.remarks = ""
        transaction.transactiondate = invoicedate
        transaction.subledger = func_get_sub_ledgers(request,'Purchase')
        transaction.save()

    financial_statement = addaccounts.AccountStatement()

    ledger_params = {
        "invoicenumber": data.invoicenumber,
        "invoicedate": invoicedate,
        "totalbillingamount": data.totalbillingamount,
        "customer_or_vendor": supplierform,
        "userbranch": data.branch,
        "amountrecieved": data.amountrecieved,
        "duebalance": data.duebalance,
        "paymentmode":request.POST.get("paymentmode")
    }

    financial_statement.add_ledger("Purchase", ledger_params)


    

    cashbook_params = {
        "userbranch": data.branch,
        "amountrecieved": data.amountrecieved,
        "paymentmode": data.paymentmode,
        "invoicedate": invoicedate,
        "branch_wid":request.user.userprofile.branch,
         'subledger' : func_get_sub_ledgers(request,'Purchase')
    }

    financial_statement.add_cashbook("Purchase", cashbook_params)

    general_ledger_params = {
        "invoicenumber": data.invoicenumber,
        "invoicedate": invoicedate,
        'voucherid':data.purchaseid,
        "totalbillingamount": data.totalbillingamount,
        "description": f"Purchase of from {supplierform}",
        "userbranch": data.branch,
        "amountrecieved": data.amountrecieved,
        "duebalance": data.duebalance,
        "paymentmode":request.POST.get("paymentmode"),
        "supplier":supplier_ledger
    }

    financial_statement.add_generalledger("Purchase", general_ledger_params)

    # purchase_ledger = ledgercli.LedgerBook(data.branch)

    # params = {
    #     "billdate": invoicedate,
    #     "billno": data.invoicenumber,
    #     "mode": data.paymentmode,
    #     "amountpaid": data.amountrecieved,
    #     "totalamount": data.totalbillingamount,
    #     "supplier": supplierform,
    #     "duebalance": data.duebalance,
    # }

    # purchase_ledger.post_purchase(**params)

    # return func_generate_purchase_pdf(request,lastPurchaseId,'view')
    # Your code here
    end_time = time.time()

    execution_time = end_time - start_time

    return redirect(reverse("purchaseview", kwargs={"pid": lastPurchaseId}))


# Form to edit Purchase due ampounts
@user_passes_test(
    partial(check_permission, page="Purchasedueform"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def purchaseDueForm(request, purchaseid):
    currentuser = request.user
    if currentuser.is_superuser:
        purchase = Purchase.objects.filter(purchaseid=purchaseid).first()
    else:
        purchase = BranchPurchase.objects.filter(purchaseid=purchaseid).first()
    today = date.today()
    paymentmodes = PaymentMode.objects.all()
    context = {
        "purchasedata": purchase,
        "datetoday": today,
        "paymentmodes": paymentmodes,
    }
    return render(request, "purchasedueform.html", context)


# Fucntion to save purchase due changes
@login_required
def addPurchaseDue(request):
    currentuser = request.user
    if request.method == "POST":
        purchaseid = request.POST.get("purchaseid")
        totalbillingamount = request.POST.get("totalbillingamount")
        amountrecieved = request.POST.get("amountrecieved")
        duebalance = request.POST.get("duebalance")
        paymentmode = request.POST.get("paymentmode")

        if currentuser.is_superuser:
            purchase_obj = Purchase.objects.filter(purchaseid=purchaseid).first()

            purchases = Purchase.objects.filter(purchaseid=purchaseid)
            for purchase in purchases:
                purchase.amountrecieved = float(purchase.amountrecieved) + float(
                    amountrecieved
                )
                purchase.duebalance = float(purchase.duebalance) - float(amountrecieved)
                purchase.save()
        else:
            purchase_obj = BranchPurchase.objects.filter(purchaseid=purchaseid).first()
            purchases = BranchPurchase.objects.filter(purchaseid=purchaseid)
            for purchase in purchases:
                purchase.amountrecieved = float(purchase.amountrecieved) + float(
                    amountrecieved
                )
                purchase.duebalance = float(purchase.duebalance) - float(amountrecieved)
                purchase.save()

        transaction = Transaction()
        transaction.transactionid = purchaseid
        transaction.amount = float(amountrecieved)
        transaction.transactiontype = "purchase"
        transaction.paymentmode = paymentmode
        transaction.branch = request.user.userprofile.branch
        transaction.invoice_number = purchase_obj.invoicenumber
        transaction.transactiondate = datetime.now()

        if purchase_obj.supplier == None:
            transaction.accounts = purchase_obj.externalsupplier.name
        else:
            transaction.accounts = purchase_obj.supplier.name
        transaction.subledger = func_get_sub_ledgers(request,'Purchase')
        transaction.remarks = ""
        transaction.save()

        supplier_ledger = purchase_obj.supplier_ledger

    financial_statement = addaccounts.AccountStatement()

    ledger_params = {
        "invoicenumber": transaction.invoice_number,
        "amountreceived": float(amountrecieved),
        "customer_or_vendor": transaction.accounts,
        "userbranch": transaction.branch,
        "paymentmode":request.POST.get("paymentmode")
    }

    financial_statement.add_ledger("PurchaseDue", ledger_params)

    general_ledger_params = {
        "invoicenumber": transaction.invoice_number,
        "voucherid": purchaseid,
        "amountreceived": float(amountrecieved),
        "description": f"Purchase from {transaction.accounts}",
        "userbranch": transaction.branch,
        "paymentmode":request.POST.get("paymentmode"),
        "supplier":supplier_ledger
    }

    financial_statement.add_generalledger("PurchaseDue", general_ledger_params)

    cashbook_params = {
        "userbranch": transaction.branch,
        "amountrecieved": float(amountrecieved),
        "paymentmode": paymentmode,
        "invoicedate": date.today(),
        "branch_wid":request.user.userprofile.branch,
         'subledger' : func_get_sub_ledgers(request,'Purchase')
    }

    financial_statement.add_cashbook("Purchase", cashbook_params)

    # purchase_ledger = ledgercli.LedgerBook(transaction.branch)

    # params = {
    #     "billdate": date.today(),
    #     "billno": transaction.invoice_number,
    #     "mode": paymentmode,
    #     "amountpaid": float(amountrecieved),
    #     "supplier": transaction.accounts,
    #     "duebalance": purchase.duebalance,
    # }

    # purchase_ledger.post_purchase_due(**params)

    return redirect("purchase")


@login_required
def BranchPurchaseStatusUpdate(request):
    if request.method == "POST":
        saleid = request.POST["saleid"]
        status = request.POST["status"]
        sales = Sale.objects.filter(saleid=saleid)

        if sales:
            for sale in sales:
                sale.status = status
                sale.save()

        branchpurchase = BranchPurchase.objects.filter(saleid=saleid)
        if branchpurchase:
            for purchase in branchpurchase:
                purchase.status = status
                purchase.save()

    return redirect("purchase")


# # function which generates pdf of purchase details
@user_passes_test(
    partial(check_permission, page="Purchasepdf"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def generate_purchase_pdf(request, id, action):
    # Fetch the common fields from the DB
    currentuser = request.user

    if currentuser.is_superuser:
        # get a list of dictionaries of given values
        data = Purchase.objects.filter(purchaseid=id).values(
            "name", "barcodenumber", "price", "purchasegst", "salegst", "totalquantity"
        )
        purchase = Purchase.objects.filter(purchaseid=id).first()

        if not purchase:
            # get a list of dictionaries of given values
            data = BranchPurchase.objects.filter(purchaseid=id).values(
                "name",
                "barcodenumber",
                "price",
                "purchasegst",
                "salegst",
                "totalquantity",
            )
            purchase = BranchPurchase.objects.filter(purchaseid=id).first()

    else:
        # get a list of dictionaries of given values
        data = BranchPurchase.objects.filter(purchaseid=id).values(
            "name", "barcodenumber", "price", "purchasegst", "salegst", "totalquantity"
        )
        purchase = BranchPurchase.objects.filter(purchaseid=id).first()

    invoicenumber = purchase.invoicenumber
    invoicedate = purchase.invoicedate
    if purchase.supplier == None:
        supplier = purchase.externalsupplier
    else:
        supplier = purchase.supplier
    purchase_type = purchase.paymentmode
    totalbillingamount = purchase.totalbillingamount
    totalamount = purchase.totalamount
    purchaseid = purchase.purchaseid
    branch = purchase.branch
    amountrecieved = purchase.amountrecieved
    duebalance = purchase.duebalance
    discount = purchase.discount
    discountmethod = purchase.discountmethod

    if purchase.totaltax == None or purchase.totaltax == "":
        totaltax = 0
    else:
        totaltax = purchase.totaltax
    data_list = []
    for item in data:
        data_dict = {
            "name": Products.objects.filter(Q(id=item["name"]) & Q(branch=branch))
            .first()
            .name,
            "barcodenumber": item["barcodenumber"],
            "price": item["price"],
            "purchasegst": item["purchasegst"],
            "salegst": item["salegst"],
            "totalquantity": item["totalquantity"],
        }
        data_list.append(data_dict)

    company = request.user.userprofile.company
    company_name = company.company_name
    if branch.name == "WAREHOUSE":
        address_line1 = company.address_line1
        address_line2 = company.address_line2
        address_line3 = company.address_line3
        phone = ""
    else:
        address_line1 = branch.address
        phone = branch.phone
        address_line2 = ""
        address_line3 = ""

    logo = company.logo_url

    context = {
        "invoicenumber": invoicenumber,
        "invoicedate": invoicedate,
        "supplier": supplier,
        "type": purchase_type,
        "totalbillingamount": totalbillingamount,
        "totalamount": totalamount,
        "purchaseid": purchaseid,
        "branch": branch,
        "data": data_list,
        "amountrecieved": amountrecieved,
        "duebalance": duebalance,
        "discount": discount,
        "discountmethod": discountmethod,
        "id": id,
        "company_name": company_name,
        "address_line1": address_line1,
        "address_line2": address_line2,
        "address_line3": address_line3,
        # 'logo':logo,
        "logo": GLOBAL_VARIABLES["current_host"] + logo.url,
        "totaltax": totaltax,
        "phone": phone,
        "current_user": currentuser,
        "current_host": str(request.get_host()),
    }
    try:
        PAGESIZE = PageSize.objects.filter(active=True).first().size
    except:
        PAGESIZE = "A4"
    # create a template object
    template = get_template("purchasepdf.html")

    html = template.render(context)
    options = {"quiet": "", "encoding": "UTF-8", "page-size": PAGESIZE}
    css = os.path.join(BASE_DIR, "core", "static", "css", "purchasepdf.css")
    pdf = pdfkit.from_string(html, False, options=options, css=css)
    response = HttpResponse(content_type="application/pdf")


    if action == "download":
        response["Content-Disposition"] = (
            f'attachment; filename="Purchase_Invoice_{date.today()}.pdf"'
        )
    else:
        response["Content-Disposition"] = (
            f'inline; filename="Purchase_Invoice_{date.today()}.pdf"'
        )
    response.write(pdf)
    return response


def func_blackhource_encoder(price):
 
    price_string = str(round(price))
    num_list = ["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"]
    letter_list = ["B", "L", "A", "C", "K", "H", "O", "R", "S", "E"]
    price_string = list(price_string)
    blackhorse_code = ""
    for num in price_string:
        if num in num_list:
            index = num_list.index(num)
            blackhorse_code += letter_list[index]
    return blackhorse_code


def create_composite_image_purchase(
    barcode_image_bytes="",
    company_name="",
    date=None,
    sellingprice="",
    mrp="",
    purchaseprice="",
    productname=""
):
    # Load the barcode image
    barcode_image = Image.open(BytesIO(barcode_image_bytes))

    # Create a new image for the composite. The size might need adjustments.
    # This assumes the barcode image's width and a fixed height addition for text.
    composite_image = Image.new(
        "RGB", (barcode_image.width, barcode_image.height + 100), "white"
    )
    composite_image.paste(barcode_image, (0, 50))  # Offset by 100 pixels from the top

    # Prepare to draw text
    draw = ImageDraw.Draw(composite_image)

    font_path = os.path.join(
        BASE_DIR, "core", "static", "fonts", "Roboto", "Roboto-Regular.ttf"
    )
    font_size = 40
    font = ImageFont.truetype(font_path, font_size)
    font2 = ImageFont.truetype(font_path, 25)
    font3 = ImageFont.truetype(font_path, 20)

    

    selling_price = f"Selling Price : {sellingprice}"
    mrp = f"MRP : {mrp}"
    p_code = func_blackhource_encoder(purchaseprice)

    draw.text((120, 10), company_name, fill="black", font=font)
    draw.text((60, 185), productname, fill="black", font=font3)
    draw.text((60, 207), selling_price, fill="black", font=font2)
    draw.text((60, 232), mrp, fill="black", font=font2)
    draw.text((60, 254), p_code, fill="black", font=font2)
    

    # Save or return the image
    byte_io = BytesIO()
    composite_image.save(byte_io, "PNG",dpi=(203, 203))
    return byte_io.getvalue()



def create_barcode_pdf(barcodetype=None,
                       date=None,
                       mobile=None,
                       customer=None,
                       problem=None,
                       sr_no=None,
                       barcode_number=None,
                            company_name=None,
                              product_name=None, 
                              sellingprice=None,
                                mrp=None,
                                  purchaseprice=None,
                                    barcode_image_bytes=None):
    buffer = BytesIO()
    
    # Keep the page size as 76mm x 25mm
    c = canvas.Canvas(buffer, pagesize=(76*mm, 25*mm))
    
    # Set up the document
    
    
    # Define positions for the two labels within the available width
    positions = [(2*mm, 10*mm), (38*mm, 10*mm)]  

    if barcodetype == "purchase":
        c.setTitle("Purchase Barcode")
        
        for pos_x, pos_y in positions:
            # company name
            c.setFont("Helvetica-Bold", 7)   
            c.drawString(pos_x + 9*mm, pos_y + 10.5*mm, company_name)
            
            # barcode image
            barcode_image = ImageReader(BytesIO(barcode_image_bytes))
            c.drawImage(barcode_image, pos_x+2*mm, pos_y + 0*mm, width=34*mm, height=10*mm, mask='auto')
            
            # product details
            c.setFontSize(6)  
            c.drawString(pos_x + 5*mm, pos_y + 0*mm, f"{product_name}")
            c.drawString(pos_x+ 5*mm, pos_y -2.5*mm, f"Selling Price: {round(sellingprice,2)}")
            c.drawString(pos_x+ 5*mm, pos_y - 5*mm, f"M.R.P: {mrp}")
            
            p_code = func_blackhource_encoder(purchaseprice)
            c.drawString(pos_x+ 5*mm, pos_y - 7.5*mm, f"Code: {p_code}")
        
        c.showPage()
        c.save()
        
        pdf = buffer.getvalue()
        buffer.close()
    else:
        c.setTitle("Service Barcode")
        
        for pos_x, pos_y in positions:
            # company name
            c.setFont("Helvetica-Bold", 7)   
            c.drawString(pos_x + 9*mm, pos_y + 10.5*mm, company_name)
            
            # barcode image
            barcode_image = ImageReader(BytesIO(barcode_image_bytes))
            c.drawImage(barcode_image, pos_x+2*mm, pos_y + 0*mm, width=34*mm, height=10*mm, mask='auto')
            
            # product details
            c.setFontSize(6)  
            c.drawString(pos_x + 5*mm, pos_y + 0*mm, f"{date} {sr_no}")
            c.drawString(pos_x+ 5*mm, pos_y -2.5*mm, f"{mobile} : {customer}")
            c.drawString(pos_x+ 5*mm, pos_y - 5*mm, f"{problem}")
            
            # p_code = func_blackhource_encoder(purchaseprice)
            # c.drawString(pos_x+ 5*mm, pos_y - 7.5*mm, f"Code: {p_code}")
        
        c.showPage()
        c.save()
        
        pdf = buffer.getvalue()
        buffer.close()
    
    return pdf

@login_required
def print_purchase_barcode_new(request, barcode_number, purchaseid):
    try:
        purchaseobj = Purchase.objects.filter(barcodenumber=barcode_number).first()
        if not purchaseobj:
            purchaseobj = BranchPurchase.objects.filter(barcodenumber=barcode_number).first()
        mrp = purchaseobj.name.mrp
        s_price = purchaseobj.name.sellingprice
        p_price = purchaseobj.name.price
        p_gst = purchaseobj.name.purchasegst.percentage
        s_gst = purchaseobj.name.salegst.percentage
        sellingprice = s_price + (s_price * (float(s_gst) / 100))
        purchaseprice = p_price + (p_price * (float(p_gst) / 100))
        product_name = purchaseobj.name.name
    except:
        sellingprice = ""
        mrp = ""
        purchaseprice = ""
        product_name = ""

    company_name = "MAGNUS CARE"
    barcode_format = barcode.get_barcode_class("code128")
    writer_options = {
        "module_width": 0.3,
        "module_height": 6.0,
        "font_size": 6,
        "text_distance": 2.5,
        "center_text": True,
    }

    barcode_bytes_io = BytesIO()
    my_barcode = barcode_format(barcode_number, writer=ImageWriter()).write(
        barcode_bytes_io, options=writer_options
    )
    barcode_bytes_io.seek(0)
    barcode_image_bytes = barcode_bytes_io.getvalue()

    # Create PDF using ReportLab
    pdf = create_barcode_pdf(
        barcodetype="purchase",
        barcode_number=barcode_number,
        company_name=company_name,
        product_name=product_name,
        sellingprice=sellingprice,
        mrp=mrp,
        purchaseprice=purchaseprice,
        barcode_image_bytes=barcode_image_bytes  # Passing the barcode image bytes
    )

    response = HttpResponse(content_type="application/pdf")
    response["Content-Disposition"] = (
        f'inline; filename="Purchase_barcode_{date.today()}.pdf"'
    )
    response.write(pdf)
    return response






#This is an old function not using now
@login_required
def print_purchase_barcode(request, id):

    if request.user.is_superuser:
        purchase_obj = Purchase.objects.filter(purchaseid=id)
    else:
        purchase_obj = BranchPurchase.objects.filter(purchaseid=id)
    company_name = "MAGNUS CARE"
    barcode_base64_list = []
    template = get_template("purchasebarcode.html")
    barcode_format = barcode.get_barcode_class("code128")
    writer_options = {
        "module_width": 0.3,
        "module_height": 10.0,
        "font_size": 12,
        "text_distance": 5.0,
        "center_text": True,
    }
    for item in purchase_obj:
        barcode_number = item.barcodenumber
        quantity = item.totalquantity
        for num in range(quantity):
            barcode_bytes_io = BytesIO()
            my_barcode = barcode_format(barcode_number, writer=ImageWriter()).write(
                barcode_bytes_io, options=writer_options
            )
            barcode_bytes_io.seek(0)
            barcode_image_bytes = barcode_bytes_io.getvalue()
            ##################################################
            composite_image_bytes = create_composite_image_purchase(
                barcode_image_bytes,
                company_name=company_name,
                date=datetime.now().strftime("%d/%m/%Y %I:%M %p"),
            )

            rotated_image_bytes = rotate_image(
                composite_image_bytes, -90
            )  # Rotate by -90 degrees
            barcode_base64 = base64.b64encode(rotated_image_bytes).decode()
            barcode_base64_list.append(barcode_base64)
            ###############################################
    context = {
        "barcode_base64": barcode_base64_list,
        "bc_type": "Purchase",
        "company_name": "MAGNUS CARE",
        "date": datetime.now().strftime("%d/%m/%Y %I:%M %p"),
    }
    # return render(request,'purchasebarcode.html',context)
    html = template.render(context)
    options = {
        "quiet": "",
        "encoding": "UTF-8",
    }

    pdf = pdfkit.from_string(html, False, options=options)
    response = HttpResponse(content_type="application/pdf")
    response["Content-Disposition"] = (
        f'inline; filename="Purchase_barcode_{date.today()}.pdf"'
    )
    response.write(pdf)
    return response


# Purchase return list function
@user_passes_test(
    partial(check_permission, page="Purchasereturnform"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def purchaseReturn(request):
    user = request.user
    if user.is_superuser:
        data = Purchase.objects.all()
        invoice_data = Purchase.objects.filter(
            ~Q(purchase_type="stockadd") & ~Q(purchase_type="transfer")
        )
    else:
        invoice_data = BranchPurchase.objects.filter(
            ~Q(purchase_type="stockadd") & ~Q(purchase_type="transfer")
        )
        data = BranchPurchase.objects.filter(branch=user.userprofile.branch)
    # invoicenumber_list = [i.invoicenumber for i in invoice_data]
    invoicenumber_list = [{"invoicenumber":i.invoicenumber,"purchaseid":i.purchaseid} for i in invoice_data]
    paymentmode = PaymentMode.objects.all()
    context = {
        "selected_invoiceno": "",
        "selected_purchaseid":"",
        "invoicenumbers": invoicenumber_list,
        "data": data,
        "paymentmode": paymentmode,
        'discount':0,
    }
    return render(request, "purchasereturnnew.html", context)


# This function take Purchase invoice number and returns the purchase details
def purchaseReturnSearch(request):
    user = request.user
    # inv_no = request.POST["invoiceno"]
    purchaseid = request.POST["purid"]

    already_returned = False
    invoice_number = None

    if user.is_superuser:
        data = Purchase.objects.all()
        # purchasedata = Purchase.objects.filter(invoicenumber=inv_no)
        purchasedata = Purchase.objects.filter(purchaseid=purchaseid)
        invoice_data = Purchase.objects.filter(
            ~Q(purchase_type="stockadd") & ~Q(purchase_type="transfer")
        )
        invoicenumber = Purchase.objects.filter(purchaseid=purchaseid).first().invoicenumber
        pur_ret_obj = PurchaseReturn.objects.filter(invoicenumber=invoicenumber)
        if pur_ret_obj:
            already_returned = True
    else:
        data = BranchPurchase.objects.filter(branch=user.userprofile.branch)
        # purchasedata = BranchPurchase.objects.filter(invoicenumber=inv_no)
        purchasedata = BranchPurchase.objects.filter(purchaseid=purchaseid)
        invoice_data = BranchPurchase.objects.filter(
            ~Q(purchase_type="stockadd") & ~Q(purchase_type="transfer")
        )
        invoicenumber = BranchPurchase.objects.filter(purchaseid=purchaseid).first().invoicenumber
        pur_ret_obj = PurchaseReturn.objects.filter(invoicenumber=invoicenumber)
        if pur_ret_obj:
            already_returned = True

    # invoicenumber_list = [i.invoicenumber for i in invoice_data]
    invoicenumber_list = [{"invoicenumber":i.invoicenumber,"purchaseid":i.purchaseid} for i in invoice_data]
    tax = Tax.objects.filter(branch=user.userprofile.branch)

    for item in purchasedata:
        invoicenumber = item.invoicenumber
        invoicedate = item.invoicedate
        if item.supplier == None:
            supplier = item.externalsupplier
        else:
            supplier = item.supplier
        totalamount = item.totalamount
        purchaseid = item.purchaseid
        branch = item.branch
        totalbillingamount = item.totalbillingamount
        amountrecieved = item.amountrecieved
        duebalance = item.duebalance
        discount = item.discount
        discountmethod = item.discountmethod
        paymentmode = item.paymentmode
        totaltax = item.totaltax
        if user.is_superuser:
            pass
        else:
            saleid = item.saleid

        break

    purchase_data_new = []
    for i in purchasedata:
        product = i.name
        purchaseid = i.purchaseid
        dic = {}
        dic["name"] = i.name
        ########################################
        if request.user.is_superuser:
            available_qty = Stock.objects.filter(Q(branch=branch)&Q(name=i.name)).first().quantity
        else:
            available_qty = BranchStock.objects.filter(Q(branch=branch)&Q(name=i.name)).first().quantity
        dic['availableqty'] = available_qty
        ########################################
        

        ##############################################################
        
        product_exist = PurchaseReturn.objects.filter(Q(product=product)&Q(invoicenumber=invoicenumber)&Q(purchaseid=purchaseid)).exists()
        if product_exist:
            purchasereturnobj = PurchaseReturn.objects.filter(Q(product=product)&Q(invoicenumber=invoicenumber)&Q(purchaseid=purchaseid))
            returned_qty = 0
            for j in purchasereturnobj:
                returned_qty = returned_qty + j.returnquantity
            balance_qty = i.totalquantity - returned_qty
            dic['balance_qty'] = balance_qty
        else:
            dic['balance_qty'] = i.totalquantity

        #############################################################

        dic["totalquantity"] = i.totalquantity
        if available_qty < i.totalquantity:
            dic['diffqty'] = ''
        else:
            dic['diffqty'] = ''
        
        dic["price"] = i.price
        dic["purchasegstname"] = i.purchasegst
        dic["tax"] = (
            Tax.objects.filter(
                Q(name=i.purchasegst) & Q(branch=request.user.userprofile.branch)
            )
            .first()
            .percentage
        )
        purchase_data_new.append(dic)


    paymentmode = PaymentMode.objects.all()
    context = {
        "tax": tax,
        # "selected_invoiceno": inv_no,
        "selected_invoiceno": invoicenumber ,
        "selected_purchaseid": purchaseid,
        "invoicenumber": invoicenumber,
        "invoicedate": invoicedate,
        "supplier": supplier,
        "totalamount": totalamount,
        "purchaseid": purchaseid,
        "branch": branch,
        "purchasedata": purchase_data_new,
        "invoicenumbers": invoicenumber_list,
        "tatalbillingamount": totalbillingamount,
        "amountrecieved": amountrecieved,
        "duebalance": duebalance,
        "discount": discount,
        "discountmethod": discountmethod,
        "paymentmode": paymentmode,
        "user": user,
        "already_returned":already_returned
    }

    return render(request, "purchasereturnnew.html", context)


# saving purchase return
def addPurchaseReturn(request):


    check_status_with_constant = partial(check_status_common, attribute="price")
    length_count = list(filter(check_status_with_constant, request.POST.keys()))


    already_pending_returned = PurchaseReturn.objects.filter(Q(purchaseid=request.POST["purchaseid"])&Q(status="Pending")).exists()
    if already_pending_returned:
        messages.error(request, "Pending return already exists of this purchase")
        return redirect("purchasereturn")
    purchasereturnid = generate_unique_id("PurchaseReturn", "PRT")
    for i in range(1, ((len(length_count)+1))):
        data = PurchaseReturn()
        i = str(i)

        try:
            productcheck = request.POST["productcheck" + i]
        except:
            continue

        if productcheck != "on":
            continue

        data.invoicenumber = request.POST["invno"]
        try:
            data.supplier = Branch.objects.get(name=request.POST["sup"])
        except:
            data.externalsupplier = Suppliers.objects.filter(
                Q(name=request.POST["sup"]) & Q(branch=request.user.userprofile.branch)
            ).first()

        data.purchasereturnid = purchasereturnid
        data.purchaseid =  request.POST["purchaseid"]
        data.product = Products.objects.filter(
            Q(name=request.POST["product" + i])
            & Q(branch=request.user.userprofile.branch)
        ).first()
        data.returnquantity = request.POST["returnqty" + i]
        data.rate = request.POST["rate" + i]
        data.paymentmode = request.POST["paymentmode"]
        data.tax = Tax.objects.get(
            Q(name=request.POST["tax" + i]) & Q(branch=request.user.userprofile.branch)
        )
        data.refundamount = request.POST["refundamount" + i]
        data.reason = request.POST["reason" + i]
        data.totalamount = request.POST["totalamount"]
        if request.POST["adjustment"] == "":
            data.adjustment = 0
        else:
            data.adjustment = request.POST["adjustment"]
        data.nettotal = request.POST["nettotal"]
        data.totaltax = request.POST["totaltax"]
        data.totalquantity = request.POST["totalqty"]
        data.status = "Pending"
        data.branch = Branch.objects.get(id=int(request.POST["branch"]))
        data.save()

    return redirect("purchasereturn")


# Purchase return list
@user_passes_test(
    partial(check_permission, page="Purchasereturnlist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
def purchaseReturnList(request):
    currentuser = request.user
    if currentuser.is_superuser:
        data = PurchaseReturn.objects.all().order_by("-pk")
    else:
        data = PurchaseReturn.objects.filter(
            branch=currentuser.userprofile.branch
        ).order_by("-pk")
    purchasereturnid_set = set()
    datafinal = [
        purchase
        for purchase in data
        if (
            purchase.purchasereturnid not in purchasereturnid_set
            and not purchasereturnid_set.add(purchase.purchasereturnid)
        )
    ]
    context = {
        "data": datafinal,
    }
    return render(request, "purchasereturnlist.html", context)



@login_required
def DeletePurchaseReturn(request,returnid):
 
    return_obj = PurchaseReturn.objects.filter(purchasereturnid=returnid)
   
    return_obj.delete()
  
    return redirect("purchasereturnlist")




# This function takes purchase return id and return purchase return details
@user_passes_test(
    partial(check_permission, page="Purchasereturdetails"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
def purchaseReturnDetails(request, returnid):
    currentuser = request.user
    data = PurchaseReturn.objects.filter(purchasereturnid=returnid)
    # Fetch the common fields from the DB
    for item in data:
        invoicenumber = item.invoicenumber
        entrydate = item.createddate
        if item.supplier == None:
            supplier = item.externalsupplier
        else:
            supplier = item.supplier
        totalamount = item.totalamount
        returnid = item.purchasereturnid
        branch = item.branch
        netamount = item.nettotal
        adjustment = item.adjustment
        status = item.status
        paymentmode = item.paymentmode
        totaltax = item.totaltax
        totalqty = item.totalquantity
        break

    if totaltax == None or totaltax == "":
        totaltax = 0

    context = {
        "totaltax": totaltax,
        "invoicenumber": invoicenumber,
        "entrydate": entrydate,
        "supplier": supplier,
        "status": status,
        "totalamount": totalamount,
        "returnid": returnid,
        "netamount": netamount,
        "branch": branch,
        "data": data,
        "totalqty": totalqty,
        "adjustment": adjustment,
        "paymentmode": paymentmode,
        "user": currentuser,
    }

    return render(request, "purchasereturndetails.html", context)


# This function change the status of purchase return already entered also remove the returned product from stock
def changePurchaseReturnStatus(request):
    status = request.POST["status"]
    returnid = request.POST["purchasereturnid"]
    if status:
        return_obj = PurchaseReturn.objects.filter(purchasereturnid=returnid)
        branch = None
        nettotal = None
        paymentmode = None
        invoicenumber = None
        supplier = None

        ##### checking available qty before returning ####
        is_less_than_return_quantity = False
        for ret in return_obj:
            productid = ret.product.id
            ret_qty = ret.returnquantity
            branch = ret.branch
            qty = 0
            if branch.name == "WAREHOUSE":
                if Stock.objects.filter(name_id=productid):
                    stock = Stock.objects.filter(name_id=productid).first()
                    qty = stock.quantity
                    if qty < ret_qty:
                        is_less_than_return_quantity = True
            else:
                if BranchStock.objects.filter(Q(name_id=productid) & Q(branch=branch)):
                    stock = BranchStock.objects.filter(
                        Q(name_id=productid) & Q(branch=branch)
                    ).first()
                qty = stock.quantity
                if qty < ret_qty:
                    is_less_than_return_quantity = True

        if is_less_than_return_quantity:
            messages.error(request, f"Only quantity {qty} left. Product id {productid}")
            return redirect("purchasereturn")
        ##### checking available qty before returning ######


        for ret in return_obj:
            ret.status = status
            ret.save()

            branch = ret.branch
            nettotal = ret.nettotal
            paymentmode = ret.paymentmode
            invoicenumber = ret.invoicenumber
            if ret.supplier == None:
                supplier = ret.externalsupplier.name
            else:
                supplier = ret.supplier.name

            productid = ret.product.id

            if branch.name == "WAREHOUSE":
                if Stock.objects.filter(name_id=productid):
                    stock = Stock.objects.filter(name_id=productid).first()
                    qty = stock.quantity
                    stock.quantity = int(qty) - int(ret.returnquantity)
                    stock.save()

            else:
                if BranchStock.objects.filter(Q(name_id=productid) & Q(branch=branch)):
                    stock = BranchStock.objects.filter(
                        Q(name_id=productid) & Q(branch=branch)
                    ).first()
                    qty = stock.quantity
                    stock.quantity = int(qty) - int(ret.returnquantity)
                    stock.save()
            


            strans_obj = StockTransaction.objects.filter(
                Q(
                    product_id=int(productid)
                )
                & Q(branch=request.user.userprofile.branch)
            ).first()


            if strans_obj:
                stocktr = StockTransaction()
                stocktr.product = Products.objects.filter(
                    Q(id=int(productid)) & Q(branch=request.user.userprofile.branch)
                ).first()
                stocktr.initial_quantity = strans_obj.initial_quantity
                stocktr.quantity = int(ret.returnquantity)
                stocktr.transactiontype = "Sub"
                stocktr.branch = request.user.userprofile.branch
                try:
                    stocktr.reference_number  = invoicenumber
                    stocktr.transaction_category  = 'Purchase Return Entry'
                except:
                    stocktr.reference_number  = 'NA'
                    stocktr.transaction_category  = 'Purchase Return Entry'
                stocktr.save()
 
            else:
                stocktr = StockTransaction()
                stocktr.product = Products.objects.filter(
                    Q(id=int(productid)) & Q(branch=request.user.userprofile.branch)
                ).first()
                stocktr.initial_quantity = 0
                stocktr.quantity = int(ret.returnquantity)
                stocktr.transactiontype = "Sub"
                stocktr.branch = request.user.userprofile.branch
                try:
                    stocktr.reference_number  = invoicenumber
                    stocktr.transaction_category  = 'Purchase Return Entry'
                except:
                    stocktr.reference_number  = 'NA'
                    stocktr.transaction_category  = 'Purchase Return Entry'
                stocktr.save()
                

        transaction = Transaction()
        transaction.transactionid = returnid
        transaction.amount = nettotal
        transaction.transactiontype = "purchasereturn"
        transaction.paymentmode = paymentmode
        transaction.branch = branch
        transaction.invoice_number = invoicenumber
        transaction.accounts = supplier
        transaction.remarks = ""
        transaction.transactiondate = datetime.now()
        transaction.subledger = func_get_sub_ledgers(request,'Purchase Return')
        transaction.save()

    financial_statement = addaccounts.AccountStatement()

    ledger_params = {
        "returnid": returnid,
        "nettotal": nettotal,
        "customer_or_vendor": supplier,
        "userbranch": branch,
        "paymentmode": paymentmode,
    }

    financial_statement.add_ledger("PurchaseReturn", ledger_params)

    cashbook_params = {
        "userbranch": branch,
        "nettotal": nettotal,
        "paymentmode": paymentmode,
        "branch_wid":request.user.userprofile.branch,
         'subledger' : func_get_sub_ledgers(request,'Purchase Return')
    }

    financial_statement.add_cashbook("PurchaseReturn", cashbook_params)


    general_ledger_params = {
        "returnid": returnid,
        "voucherid": returnid,
        "nettotal": nettotal,
        "description": f"Purchase Return to {supplier}",
        "userbranch": branch,
        "paymentmode": paymentmode,
    }

    financial_statement.add_generalledger("PurchaseReturn", general_ledger_params)


    # purchase_return_ledger = ledgercli.LedgerBook(branch)
    # params = {
    #     "billdate": date.today(),
    #     "billno": invoicenumber,
    #     "totalamount": nettotal,
    #     "mode": paymentmode,
    # }
    # purchase_return_ledger.post_purchase_return(**params)


    return redirect(reverse("purchasereturndetails", kwargs={"returnid": returnid}))





# Purchase functions ends here


# User functions


@user_passes_test(
    partial(check_permission, page="Userlist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def Users(request):
    if request.user.is_superuser:
        data = User.objects.all().order_by("-pk")
    else:
        user_ids = UserProfile.objects.filter(
            branch=request.user.userprofile.branch
        ).values_list("user", flat=True)
        data = User.objects.filter(id__in=user_ids)
    currentuser = request.user
    if currentuser.is_superuser:
        branch = "WAREHOUSE"
    else:
        branch = UserProfile.objects.get(user=currentuser).branch
    context = {
        "data": data,
    }
    return render(request, "users.html", context)


# user details function to see the selected user's details and permissions
@login_required
def myprofile(request):
    user = request.user
    context = {
        "user": user,
    }
    return render(request, "myprofile.html", context)


# user entry form
@user_passes_test(
    partial(check_permission, page="Userform"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
@never_cache
def addUserPage(request):
    branches = Branch.objects.filter(Q(branchtype="Own") | Q(branchtype="Franchise"))
    context = {
        "branches": branches,
    }
    return render(request, "adduserpage.html", context)


# function to save user
@login_required
def addUser(request):
    if request.method == "POST":
        username = request.POST.get("username")
        email = request.POST.get("email")
        password = request.POST.get("password")
        branch = request.POST.get("branch")
        mobile = request.POST.get("mobile")
        role = request.POST.get("role")
        firstname = request.POST.get("firstname")
        lastname = request.POST.get("lastname")
        try:
            user = User.objects.create_user(
                username=username,
                email=email,
                password=password,
                first_name=firstname,
                last_name=lastname,
            )
            branch = Branch.objects.get(id=branch)
            userprofile = UserProfile.objects.create(
                user=user,
                branch=branch,
                mobile=mobile,
                role=role,
                company=request.user.userprofile.company,
            )

            if role == "Branch Admin" or role == "Franchise Admin":
                userprofile.set_permissions(BRANCH_ADMIN)
            elif role == "Super Admin":
                userprofile.set_permissions(ADMIN)
            elif role == "Field Engineer":
                userprofile.set_permissions(FIELD_ENGINEER)
            elif role == "Technician":
                userprofile.set_permissions(TECHNICIAN)
            elif role == "TRC Front Desk":
                userprofile.set_permissions(TRC_FRONT_DESK)
            elif role == "TRC QC":
                userprofile.set_permissions(TRC_QC)
            elif role == "TRC Cleaning and Packing":
                userprofile.set_permissions(TRC_CLEANING_AND_PACKING)
            else:
                userprofile.set_permissions([])
            userprofile.save()

            # userprofile social
            userprofilesocial = UserProfileSocial()
            userprofilesocial.user = user
            userprofilesocial.cover_picture = (
                "https://media.publit.io/file/echocp/coverecho.jpg"
            )
            userprofilesocial.profile_picture = (
                "https://media.publit.io/file/echoicons/user-3237472.png"
            )
            userprofilesocial.phone = mobile
            userprofilesocial.save()

            return redirect("users")
        except IntegrityError as e:
            if "UNIQUE constraint failed: auth_user.username" in str(e):
                messages.error(request, "Username already exists.")
            else:
                messages.error(request, "An error occured.")
            return redirect("adduserpage")
    return redirect("users")


# user details function to see the selected user's details and permissions
@user_passes_test(
    partial(check_permission, page="Userdetails"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def userdetails(request, id):
    user = User.objects.get(id=id)
    permissions = user.userprofile.get_permissions()
    context = {"user": user, "permissions": permissions}
    return render(request, "myprofile.html", context)


# this function updates the users permissions
@login_required
def updateUserPermissions(request):
    id = request.POST["user_id"]
    permissions_list = list(request.POST.keys())

    if "csrfmiddlewaretoken" in request.POST.keys():
        permissions_list.remove("csrfmiddlewaretoken")
    if "user_id" in request.POST.keys():
        permissions_list.remove("user_id")

    new_permissions_list = list(map(lambda x: x.capitalize(), permissions_list))
    user_profile_obj = User.objects.get(id=int(id)).userprofile
    user_profile_obj.set_permissions(new_permissions_list)
    user_profile_obj.save()
    return redirect(reverse("userdetails", kwargs={"id": id}))


# form for updating user
@user_passes_test(
    partial(check_permission, page="Userupdate"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def userupdateform(request, id):
    user = User.objects.get(id=id)
    branches = Branch.objects.all()
    context = {
        "user": user,
        "branches": branches,
    }
    return render(request, "userupdateform.html", context)


# saving the user update
@login_required
def userupdate(request):
    if request.method == "POST":
        id = request.POST.get("user_id")
        user = User.objects.get(id=id)
        userprofile = UserProfile.objects.get(user=user)
        user.username = request.POST.get("username")
        user.email = request.POST.get("email")
        userprofile.branch = Branch.objects.get(id=request.POST.get("branch"))
        userprofile.mobile = request.POST.get("mobile")
        role = request.POST.get("role")
        userprofile.role = role
        if role == "Branch Admin" or role == "Franchise Admin":
            userprofile.set_permissions(BRANCH_ADMIN)
        elif role == "Super Admin":
            userprofile.set_permissions(ADMIN)
        elif role == "Field Engineer":
            userprofile.set_permissions(FIELD_ENGINEER)
        elif role == "Technician":
            userprofile.set_permissions(TECHNICIAN)
        elif role == "TRC Front Desk":
            userprofile.set_permissions(TRC_FRONT_DESK)
        elif role == "TRC QC":
            userprofile.set_permissions(TRC_QC)
        elif role == "TRC Cleaning and Packing":
            userprofile.set_permissions(TRC_CLEANING_AND_PACKING)
        else:
            userprofile.set_permissions([])
        if request.POST.get("password") != "":
            user.set_password(request.POST.get("password"))
        try:
            user.save()
            userprofile.save()
            return redirect(reverse("userdetails", kwargs={"id": id}))
        except IntegrityError as e:
            if "UNIQUE constraint failed: auth_user.username" in str(e):
                messages.error(request, "Username already exists.")
            else:
                messages.error(request, "An error occured.")
            return redirect(reverse("userupdateform", kwargs={"id": id}))
    return redirect(reverse("userdetails", kwargs={"id": id}))


# this is an ajax function for activating and deactivating user
@login_required
def update_user_status(request):
    if request.method == "POST":
        received_data = QueryDict(request.body)
        user_status = received_data.get("status")
        id = received_data.get("id")
        status = True
        if user_status == "true":
            status = True
        elif user_status == "false":
            status = False
        user = User.objects.get(id=id)
        user.is_active = status
        try:
            user.save()
            response_data = {
                "message": "User status updated successfully.",
            }
        except:
            response_data = {"error": "Error in updating user status."}
        return JsonResponse(response_data)
    response_data = {"error": "Invalid request."}
    return JsonResponse(response_data, status=400)


# End user function


# Stock function

# @user_passes_test(partial(check_permission, page="Stocklist"),login_url='/accessdenied/',redirect_field_name=None)
# @login_required
# def stock(request):
#     data = Stock.objects.all().order_by('-pk')
#     total_value = Stock.objects.all().aggregate(Sum('stockvalue'))['stockvalue__sum']
#     total_quantity = Stock.objects.all().aggregate(Sum('quantity'))['quantity__sum']
#     context = {'data': data,"total_value":total_value,"total_quantity":total_quantity}
#     return render (request, 'stock.html', context)


def func_get_stock_branchstock_items(obj, purchasemodal, stocktype):

    branch_stock_obj_filtered = []
    for item in obj:
        dic = {}
        dic["name"] = item.name
        dic["quantity"] = item.quantity
        dic["purchaserate"] = item.purchaserate
        dic["salerate"] = item.salerate
        dic["stockvalue"] = item.stockvalue
        filters = Q()
        if stocktype == "stock":
            dic["branch"] = Branch.objects.filter(id=1).first()
            filters &= Q(name=item.name)
        else:
            dic["branch"] = item.branch
            filters &= Q(branch=item.branch)
            filters &= Q(name=item.name)
        try:
            dic["barcode"] = purchasemodal.objects.filter(filters).first().barcodenumber
            dic["purchaseid"] = purchasemodal.objects.filter(filters).first().purchaseid
        except:
            dic["barcode"] = ""
            dic["purchaseid"] = ""
        branch_stock_obj_filtered.append(dic)
    return branch_stock_obj_filtered


# SG-23
@user_passes_test(
    partial(check_permission, page="Stocklist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def stock(request):
    search = ""
    search_filters = {
        "search_brand": "",
        "search_catagory": "",
        "search_subcatagory": "",
        "search_product_type": "",
    }

    data = Stock.objects.filter(quantity__gt=0).order_by("-pk")
    stock_obj_filtered = func_get_stock_branchstock_items(data, Purchase, "stock")
    total_value = Stock.objects.filter(quantity__gt=0).aggregate(Sum("stockvalue"))["stockvalue__sum"]
    total_quantity = Stock.objects.filter(quantity__gt=0).aggregate(Sum("quantity"))["quantity__sum"]
    all_category = Catagories.objects.filter(branch__name="WAREHOUSE")
    all_type = Type.objects.filter(branch__name="WAREHOUSE")
    all_subcat = SubCatagories.objects.filter(branch__name="WAREHOUSE")
    all_brands = Brand.objects.filter(branch__name="WAREHOUSE")
    if request.method == "POST":
        brand = request.POST.get("brand", None)
        catagory = request.POST.get("category", None)
        subcategory = request.POST.get("subcategory", None)
        product_type = request.POST.get("type", None)
        filters = Q()

        if brand:
            filters &= Q(name__brand=brand)
            search_filters["search_brand"] = Brand.objects.filter(id=int(brand)).first()
        if catagory:
            filters &= Q(name__catagory=catagory)
            search_filters["search_catagory"] = Catagories.objects.filter(
                id=int(catagory)
            ).first()
        if subcategory:
            filters &= Q(name__subcatagory=subcategory)
            search_filters["search_subcatagory"] = SubCatagories.objects.filter(
                id=int(subcategory)
            ).first()
        if product_type:
            filters &= Q(name__type=product_type)
            search_filters["search_product_type"] = Type.objects.filter(
                id=int(product_type)
            ).first()

        filters &= Q(quantity__gt=0)

        data = Stock.objects.filter(filters)
        stock_obj_filtered = func_get_stock_branchstock_items(data, Purchase, "stock")
        total_value = Stock.objects.filter(filters).aggregate(Sum("stockvalue"))[
            "stockvalue__sum"
        ]
        total_quantity = Stock.objects.filter(filters).aggregate(Sum("quantity"))[
            "quantity__sum"
        ]
        search = True

 

    context = {
        "data": data,
        "data_new": stock_obj_filtered,
        "total_value": total_value,
        "total_quantity": total_quantity,
        "issearch": search,
        "issearch": search,
        "all_category": all_category,
        "all_type": all_type,
        "all_subcat": all_subcat,
        "all_brands": all_brands,
    }
    context.update(search_filters)
    return render(request, "stock.html", context)


# Ajax function
# this function takes product id and return the available quantity
def get_product_details_stocktransfer(request):
    user = request.user
    if request.method == "POST":
        received_data = QueryDict(request.body)
        productid = received_data.get("productid")
        product_obj = Products.objects.filter(id=int(productid)).first()
        resp = {}
        if product_obj:
            resp = {
                "unitprice": product_obj.price,
                "salegst": product_obj.salegst.name,
                "purchasegst": product_obj.purchasegst.name,
                "mop": product_obj.mop,
                "mrp": product_obj.mrp,
            }
            if user.is_superuser:
                product_stock = Stock.objects.filter(name__id=product_obj.id).first()
                available_qty = product_stock.quantity
                resp["available_qty"] = available_qty
            else:
                product_stock = BranchStock.objects.filter(
                    Q(name__id=product_obj.id) & Q(branch=user.userprofile.branch)
                ).first()
                available_qty = product_stock.quantity
                resp["available_qty"] = available_qty

    return JsonResponse(resp)


@user_passes_test(
    partial(check_permission, page="Branchstocklist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def branchStock(request):
    currentuser = request.user
    homebranch = currentuser.userprofile.branch
    search = ""
    search_filters = {
        "search_branch": "",
        "search_brand": "",
        "search_catagory": "",
        "search_subcatagory": "",
        "search_product_type": "",
    }
    if currentuser.is_superuser:

        branch_stock_obj = BranchStock.objects.filter(
            ~Q(branch__branchtype="External")&Q(quantity__gt=0)
        ).order_by("branch")
        branch_stock_obj_filtered = func_get_stock_branchstock_items(
            branch_stock_obj, BranchPurchase, "branchstock"
        )

        total_value = BranchStock.objects.filter(
            ~Q(branch__branchtype="External")&Q(quantity__gt=0)
        ).aggregate(Sum("stockvalue"))["stockvalue__sum"]
        total_quantity = BranchStock.objects.filter(
            ~Q(branch__branchtype="External")&Q(quantity__gt=0)
        ).aggregate(Sum("quantity"))["quantity__sum"]
        all_branches = Branch.objects.filter(
            Q(branchtype="Own") | Q(branchtype="Franchise") | Q(name="WAREHOUSE")
        )
        all_category = Catagories.objects.all()
        all_type = Type.objects.all()
        all_subcat = SubCatagories.objects.all()
        all_brands = Brand.objects.all()
        if request.method == "POST":
            branch = request.POST.get("branch", None)
            brand = request.POST.get("brand", None)
            catagory = request.POST.get("category", None)
            subcategory = request.POST.get("subcategory", None)
            product_type = request.POST.get("type", None)
            filters = Q()
            if branch:
                filters &= Q(branch=branch)
                search_filters["search_branch"] = Branch.objects.filter(
                    id=int(branch)
                ).first()
            if brand:
                filters &= Q(name__brand=brand)
                search_filters["search_brand"] = Brand.objects.filter(
                    id=int(brand)
                ).first()
            if catagory:
                filters &= Q(name__catagory=catagory)
                search_filters["search_catagory"] = Catagories.objects.filter(
                    id=int(catagory)
                ).first()
            if subcategory:
                filters &= Q(name__subcatagory=subcategory)
                search_filters["search_subcatagory"] = SubCatagories.objects.filter(
                    id=int(subcategory)
                ).first()
            if product_type:
                filters &= Q(name__type=product_type)
                search_filters["search_product_type"] = Type.objects.filter(
                    id=int(product_type)
                ).first()

            filters &= Q(quantity__gt=0)

            branch_stock_obj = BranchStock.objects.filter(filters).order_by("branch")
            branch_stock_obj_filtered = func_get_stock_branchstock_items(
                branch_stock_obj, BranchPurchase, "branchstock"
            )
            total_value = BranchStock.objects.filter(filters).aggregate(
                Sum("stockvalue")
            )["stockvalue__sum"]
            total_quantity = BranchStock.objects.filter(filters).aggregate(
                Sum("quantity")
            )["quantity__sum"]
            search = True
    else:

        branch_stock_obj = BranchStock.objects.filter(
            Q(branch=currentuser.userprofile.branch)&Q(quantity__gt=0)
        ).order_by("-pk")
        branch_stock_obj_filtered = func_get_stock_branchstock_items(
            branch_stock_obj, BranchPurchase, "branchstock"
        )

        total_value = BranchStock.objects.filter(
            Q(branch=currentuser.userprofile.branch)&Q(quantity__gt=0)
        ).aggregate(Sum("stockvalue"))["stockvalue__sum"]
        total_quantity = BranchStock.objects.filter(
            Q(branch=currentuser.userprofile.branch)&Q(quantity__gt=0)
        ).aggregate(Sum("quantity"))["quantity__sum"]
        all_branches = [request.user.userprofile.branch]
        all_category = Catagories.objects.filter(branch=currentuser.userprofile.branch)
        all_type = Type.objects.filter(branch=currentuser.userprofile.branch)
        all_subcat = SubCatagories.objects.filter(branch=currentuser.userprofile.branch)
        all_brands = Brand.objects.filter(branch=currentuser.userprofile.branch)
        if request.method == "POST":
            branch = request.POST.get("branch", None)
            brand = request.POST.get("brand", None)
            catagory = request.POST.get("category", None)
            subcategory = request.POST.get("subcategory", None)
            product_type = request.POST.get("type", None)
            filters = Q()
            if branch:
                filters &= Q(branch=branch)
                search_filters["search_branch"] = Branch.objects.filter(
                    id=int(branch)
                ).first()
            if brand:
                filters &= Q(name__brand=brand)
                search_filters["search_brand"] = Brand.objects.filter(
                    id=int(brand)
                ).first()
            if catagory:
                filters &= Q(name__catagory=catagory)
                search_filters["search_catagory"] = Catagories.objects.filter(
                    id=int(catagory)
                ).first()
            if subcategory:
                filters &= Q(name__subcatagory=subcategory)
                search_filters["search_subcatagory"] = SubCatagories.objects.filter(
                    id=int(subcategory)
                ).first()
            if product_type:
                filters &= Q(name__type=product_type)
                search_filters["search_product_type"] = Type.objects.filter(
                    id=int(product_type)
                ).first()

            filters &= Q(quantity__gt=0)

            branch_stock_obj = BranchStock.objects.filter(filters).order_by("branch")
            branch_stock_obj_filtered = func_get_stock_branchstock_items(
                branch_stock_obj, BranchPurchase, "branchstock"
            )
            total_value = BranchStock.objects.filter(filters).aggregate(
                Sum("stockvalue")
            )["stockvalue__sum"]
            total_quantity = BranchStock.objects.filter(filters).aggregate(
                Sum("quantity")
            )["quantity__sum"]
            search = True

    context = {
        "data_new": branch_stock_obj_filtered,
        "data": branch_stock_obj,
        "branch": homebranch,
        "total_value": total_value,
        "total_quantity": total_quantity,
        "branch_list": all_branches,
        "issearch": search,
        "all_category": all_category,
        "all_type": all_type,
        "all_subcat": all_subcat,
        "all_brands": all_brands,
    }
    context.update(search_filters)

    return render(request, "branchstock.html", context)





@user_passes_test(
    partial(check_permission, page="Branchstocklist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def branchOutOfStock(request):
    currentuser = request.user
    homebranch = currentuser.userprofile.branch
    search = ""
    search_filters = {
        "search_branch": "",
        "search_brand": "",
        "search_catagory": "",
        "search_subcatagory": "",
        "search_product_type": "",
    }
    if currentuser.is_superuser:

        branch_stock_obj = BranchStock.objects.filter(
            ~Q(branch__branchtype="External")&Q(quantity=0)
        ).order_by("branch")
        branch_stock_obj_filtered = func_get_stock_branchstock_items(
            branch_stock_obj, BranchPurchase, "branchstock"
        )

        total_value = BranchStock.objects.filter(
            ~Q(branch__branchtype="External")&Q(quantity=0)
        ).aggregate(Sum("stockvalue"))["stockvalue__sum"]
        total_quantity = BranchStock.objects.filter(
            ~Q(branch__branchtype="External")&Q(quantity=0)
        ).aggregate(Sum("quantity"))["quantity__sum"]
        all_branches = Branch.objects.filter(
            Q(branchtype="Own") | Q(branchtype="Franchise") | Q(name="WAREHOUSE")
        )
        all_category = Catagories.objects.all()
        all_type = Type.objects.all()
        all_subcat = SubCatagories.objects.all()
        all_brands = Brand.objects.all()
        if request.method == "POST":
            branch = request.POST.get("branch", None)
            brand = request.POST.get("brand", None)
            catagory = request.POST.get("category", None)
            subcategory = request.POST.get("subcategory", None)
            product_type = request.POST.get("type", None)
            filters = Q()
            if branch:
                filters &= Q(branch=branch)
                search_filters["search_branch"] = Branch.objects.filter(
                    id=int(branch)
                ).first()
            if brand:
                filters &= Q(name__brand=brand)
                search_filters["search_brand"] = Brand.objects.filter(
                    id=int(brand)
                ).first()
            if catagory:
                filters &= Q(name__catagory=catagory)
                search_filters["search_catagory"] = Catagories.objects.filter(
                    id=int(catagory)
                ).first()
            if subcategory:
                filters &= Q(name__subcatagory=subcategory)
                search_filters["search_subcatagory"] = SubCatagories.objects.filter(
                    id=int(subcategory)
                ).first()
            if product_type:
                filters &= Q(name__type=product_type)
                search_filters["search_product_type"] = Type.objects.filter(
                    id=int(product_type)
                ).first()

            filters &= Q(quantity=0)

            branch_stock_obj = BranchStock.objects.filter(filters).order_by("branch")
            branch_stock_obj_filtered = func_get_stock_branchstock_items(
                branch_stock_obj, BranchPurchase, "branchstock"
            )
            total_value = BranchStock.objects.filter(filters).aggregate(
                Sum("stockvalue")
            )["stockvalue__sum"]
            total_quantity = BranchStock.objects.filter(filters).aggregate(
                Sum("quantity")
            )["quantity__sum"]
            search = True
    else:

        branch_stock_obj = BranchStock.objects.filter(
            Q(branch=currentuser.userprofile.branch)&Q(quantity=0)
        ).order_by("-pk")
        branch_stock_obj_filtered = func_get_stock_branchstock_items(
            branch_stock_obj, BranchPurchase, "branchstock"
        )

        total_value = BranchStock.objects.filter(
            Q(branch=currentuser.userprofile.branch)&Q(quantity=0)
        ).aggregate(Sum("stockvalue"))["stockvalue__sum"]
        total_quantity = BranchStock.objects.filter(
            Q(branch=currentuser.userprofile.branch)&Q(quantity=0)
        ).aggregate(Sum("quantity"))["quantity__sum"]
        all_branches = [request.user.userprofile.branch]
        all_category = Catagories.objects.filter(branch=currentuser.userprofile.branch)
        all_type = Type.objects.filter(branch=currentuser.userprofile.branch)
        all_subcat = SubCatagories.objects.filter(branch=currentuser.userprofile.branch)
        all_brands = Brand.objects.filter(branch=currentuser.userprofile.branch)
        if request.method == "POST":
            branch = request.POST.get("branch", None)
            brand = request.POST.get("brand", None)
            catagory = request.POST.get("category", None)
            subcategory = request.POST.get("subcategory", None)
            product_type = request.POST.get("type", None)
            filters = Q()
            if branch:
                filters &= Q(branch=branch)
                search_filters["search_branch"] = Branch.objects.filter(
                    id=int(branch)
                ).first()
            if brand:
                filters &= Q(name__brand=brand)
                search_filters["search_brand"] = Brand.objects.filter(
                    id=int(brand)
                ).first()
            if catagory:
                filters &= Q(name__catagory=catagory)
                search_filters["search_catagory"] = Catagories.objects.filter(
                    id=int(catagory)
                ).first()
            if subcategory:
                filters &= Q(name__subcatagory=subcategory)
                search_filters["search_subcatagory"] = SubCatagories.objects.filter(
                    id=int(subcategory)
                ).first()
            if product_type:
                filters &= Q(name__type=product_type)
                search_filters["search_product_type"] = Type.objects.filter(
                    id=int(product_type)
                ).first()

            filters &= Q(quantity=0)

            branch_stock_obj = BranchStock.objects.filter(filters).order_by("branch")
            branch_stock_obj_filtered = func_get_stock_branchstock_items(
                branch_stock_obj, BranchPurchase, "branchstock"
            )
            total_value = BranchStock.objects.filter(filters).aggregate(
                Sum("stockvalue")
            )["stockvalue__sum"]
            total_quantity = BranchStock.objects.filter(filters).aggregate(
                Sum("quantity")
            )["quantity__sum"]
            search = True

    context = {
        "data_new": branch_stock_obj_filtered,
        "data": branch_stock_obj,
        "branch": homebranch,
        "total_value": total_value,
        "total_quantity": total_quantity,
        "branch_list": all_branches,
        "issearch": search,
        "all_category": all_category,
        "all_type": all_type,
        "all_subcat": all_subcat,
        "all_brands": all_brands,
    }
    context.update(search_filters)

    return render(request, "branchoutofstock.html", context)


@user_passes_test(
    partial(check_permission, page="Stocktransfer"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def stock_transfer(request):
    branches = Branch.objects.filter(branchtype="Own")
    stocks = Stock.objects.filter(quantity__gt=0)
    user = request.user
    if user.is_superuser:
        stocks = Stock.objects.filter(quantity__gt=0)
    else:
        stocks = BranchStock.objects.filter(
            Q(quantity__gt=0) & Q(branch=user.userprofile.branch)
        )
    stock_dict = {}
    for i in stocks:
        stock_dict[i.name] = i.quantity
    context = {
        "stocks": stocks,
        "branches": branches,
        "stock_list": stock_dict,
    }
    return render(request, "stocktransfer.html", context)


@user_passes_test(
    partial(check_permission, page="Stocktransferlist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def stock_transfer_list(request):
    user = request.user
    if user.is_superuser:
        transfer_list = StockTransferList.objects.all().order_by("-pk")
    else:
        transfer_list = StockTransferList.objects.filter(
            Q(tobranch=user.userprofile.branch) | Q(frombranch=user.userprofile.branch)
        ).order_by("-pk")

    stocks = BranchStock.objects.filter(branch=request.user.userprofile.branch)
    taxes = Tax.objects.filter(branch=request.user.userprofile.branch)
    catagory = Catagories.objects.filter(branch=request.user.userprofile.branch)
    type = Type.objects.filter(branch=request.user.userprofile.branch)
    brand = Brand.objects.filter(branch=request.user.userprofile.branch)
    packing = Packing.objects.filter(branch=request.user.userprofile.branch)
    subcatagory = SubCatagories.objects.filter(branch=request.user.userprofile.branch)
    tax = Tax.objects.filter(branch=request.user.userprofile.branch)

    context = {
        "transfer_list": transfer_list,
        "user": user,
        "stocks": stocks,
        "taxes": taxes,
        "catagory": catagory,
        "type": type,
        "brand": brand,
        "packing": packing,
        "subcatagory": subcatagory,
    }

    return render(request, "stocktransferlist.html", context)


@login_required
def save_stock_transfer(request):
    user = request.user
    branch_id = request.POST["branch"]
    product_id = request.POST["product"]
    quantity = int(request.POST["quantity"])
    if user.is_superuser:
        stock = Stock.objects.filter(name__id=product_id).first()
    else:
        stock = BranchStock.objects.filter(name__id=product_id).first()

    if stock.quantity < quantity:
        messages.error(request, f"Only quantity {stock.quantity} left.")
        return redirect("stocktransfer")
    else:
        stock.quantity = stock.quantity - quantity
        stock.save()

        strans_obj = StockTransaction.objects.filter(
            Q(
                product=Products.objects.filter(
                    Q(id=product_id) & Q(branch=request.user.userprofile.branch)
                ).first()
            )
            & Q(branch=request.user.userprofile.branch)
        ).first()
        if strans_obj:
            stocktr = StockTransaction()
            stocktr.product = Products.objects.filter(
                Q(id=product_id) & Q(branch=request.user.userprofile.branch)
            ).first()
            stocktr.initial_quantity = strans_obj.initial_quantity
            stocktr.quantity = quantity
            stocktr.transactiontype = "Sub"
            stocktr.branch = request.user.userprofile.branch
            try:
                stocktr.reference_number  = product_id
                stocktr.transaction_category  = 'Stock Transfer'
            except:
                stocktr.reference_number  = 'NA'
                stocktr.transaction_category  = 'Stock Transfer'
            stocktr.save()
        else:
            stocktr = StockTransaction()
            stocktr.product = Products.objects.filter(
                Q(id=product_id) & Q(branch=request.user.userprofile.branch)
            ).first()
            stocktr.initial_quantity = 0
            stocktr.quantity = quantity
            stocktr.transactiontype = "Sub"
            stocktr.branch = request.user.userprofile.branch
            try:
                stocktr.reference_number  = product_id
                stocktr.transaction_category  = 'Stock Transfer'
            except:
                stocktr.reference_number  = 'NA'
                stocktr.transaction_category  = 'Stock Transfer'
            stocktr.save()

        stocktransfer = StockTransferList()
        stocktransfer.frombranch = user.userprofile.branch
        stocktransfer.tobranch = Branch.objects.filter(id=branch_id).first()
        stocktransfer.product = Products.objects.filter(id=product_id).first()
        stocktransfer.quantity = quantity
        stocktransfer.status = "Pending"
        stocktransfer.save()

    context = {}

    return redirect("stocktransferlist")


def stock_recieved(request, id):
    stocktransfer = StockTransferList.objects.filter(id=id).first()

    frombranch = stocktransfer.frombranch
    tobranch = stocktransfer.tobranch
    product = stocktransfer.product
    quantity = stocktransfer.quantity
    status = stocktransfer.status

    branchstock = BranchStock.objects.filter(
        Q(branch=tobranch) & Q(name__name=product.name)
    ).first()

    if branchstock:

        branchstock.quantity = branchstock.quantity + quantity
        branchstock.save()
        stocktransfer.status = "Recieved"
        stocktransfer.save()

        strans_obj = StockTransaction.objects.filter(
            Q(
                product=Products.objects.filter(
                    Q(name=product.name) & Q(branch=request.user.userprofile.branch)
                ).first()
            )
            & Q(branch=request.user.userprofile.branch)
        ).first()
        if strans_obj:
            stocktr = StockTransaction()
            stocktr.product = Products.objects.filter(
                Q(name=product.name) & Q(branch=request.user.userprofile.branch)
            ).first()
            stocktr.initial_quantity = strans_obj.initial_quantity
            stocktr.quantity = quantity
            stocktr.transactiontype = "Add"
            stocktr.branch = request.user.userprofile.branch
            try:
                stocktr.reference_number  = branchstock.name.id
                stocktr.transaction_category  = 'Receive Stock Transfer'
            except:
                stocktr.reference_number  = 'NA'
                stocktr.transaction_category  = 'Receive Stock Transfer'
            stocktr.save()
        else:
            stocktr = StockTransaction()
            stocktr.product = Products.objects.filter(
                Q(name=product.name) & Q(branch=request.user.userprofile.branch)
            ).first()
            stocktr.initial_quantity = 0
            stocktr.quantity = quantity
            stocktr.transactiontype = "Add"
            stocktr.branch = request.user.userprofile.branch
            try:
                stocktr.reference_number  = branchstock.name.id
                stocktr.transaction_category  = 'Receive Stock Transfer'
            except:
                stocktr.reference_number  = 'NA'
                stocktr.transaction_category  = 'Receive Stock Transfer'
            stocktr.save()

        ##### adding transfered stock in purchase #######
        bp = BranchPurchase()
        bp.name = branchstock.name
        bp.supplier = stocktransfer.frombranch
        bp.invoicenumber = f"ST{id}"
        bp.invoicedate = datetime.now()
        bp.barcodenumber = generate_unique_id("PurchaseBarcode", "PBC")[3::]
        bp.totalquantity = stocktransfer.quantity
        bp.price = branchstock.name.price
        bp.sellingprice = branchstock.name.sellingprice
        bp.purchasegst = branchstock.name.purchasegst
        bp.salegst = branchstock.name.salegst
        bp.purchaseid = generate_unique_id("Purchase", "PR")
        bp.branch = request.user.userprofile.branch
        bp.totalamount = 0
        bp.totalbillingamount = 0
        bp.amountrecieved = 0
        bp.duebalance = 0
        bp.discount = 0
        bp.mrp = branchstock.name.mrp
        bp.mop = branchstock.name.mop
        bp.purchase_type = "transfer"
        bp.save()
        ##### adding transfered stock in purchase #######

    else:

        branch_product = Products.objects.filter(
            Q(branch=tobranch) & Q(name=product.name)
        ).first()
        if branch_product:

            branchstock_obj = BranchStock()
            branchstock_obj.name = branch_product
            branchstock_obj.branch = tobranch
            branchstock_obj.quantity = quantity
            branchstock_obj.purchaserate = branch_product.price
            branchstock_obj.salerate = branch_product.sellingprice
            branchstock_obj.save()
            stocktransfer.status = "Recieved"
            stocktransfer.save()

            ##### adding transfered stock in purchase #######
            bp = BranchPurchase()
            bp.name = branch_product
            bp.supplier = stocktransfer.frombranch
            bp.invoicenumber = f"ST{id}"
            bp.invoicedate = datetime.now()
            bp.barcodenumber = generate_unique_id("PurchaseBarcode", "PBC")[3::]
            bp.totalquantity = quantity
            bp.price = branch_product.price
            bp.sellingprice = branch_product.sellingprice
            bp.purchasegst = branch_product.purchasegst
            bp.salegst = branch_product.salegst
            bp.purchaseid = generate_unique_id("Purchase", "PR")
            bp.branch = request.user.userprofile.branch
            bp.totalamount = 0
            bp.totalbillingamount = 0
            bp.amountrecieved = 0
            bp.duebalance = 0
            bp.discount = 0
            bp.mrp = branch_product.mrp
            bp.mop = branch_product.mop
            bp.purchase_type = "transfer"
            bp.save()
            ##### adding transfered stock in purchase #######

        else:

            messages.error(
                request,
                f"Please register the product first, register the product with same product name",
            )
            return redirect("stocktransferlist")

    return redirect("stocktransferlist")


def stock_not_recieved(request, id):
    stocktransfer = StockTransferList.objects.filter(id=id).first()
    stocktransfer.status = "Not Recieved"
    stocktransfer.save()
    return redirect("stocktransferlist")


@login_required
def addProductStockTransfer(request):
    data = Products()
    data.name = request.POST["name"]

    catagoryname = request.POST["catagory"]

    data.catagory = Catagories.objects.filter(
        Q(name=catagoryname) & Q(branch=request.user.userprofile.branch)
    ).first()
    subcatagoryname = request.POST["subcatagory"]

    data.subcatagory = SubCatagories.objects.filter(
        Q(name=subcatagoryname) & Q(branch=request.user.userprofile.branch)
    ).first()
    brandname = request.POST["brand"]

    data.brand = Brand.objects.filter(
        Q(branch=request.user.userprofile.branch) & Q(name=brandname)
    ).first()
    type = request.POST["type"]

    data.type = Type.objects.filter(
        Q(name=type) & Q(branch=request.user.userprofile.branch)
    ).first()
    packingname = request.POST["packing"]

    data.packing = Packing.objects.filter(
        Q(name=packingname) & Q(branch=request.user.userprofile.branch)
    ).first()
    data.HSN = request.POST["hsn"]

    data.price = float(request.POST["price"])

    data.sellingprice = float(request.POST["sellingprice"])

    purchasegst = Tax.objects.filter(id=int(request.POST["purchasegst"])).first()
    data.purchasegst = purchasegst
    salegst = Tax.objects.filter(id=int(request.POST["salegst"])).first()
    data.salegst = salegst
    try:
        data.mrp = float(request.POST["mrp"])
    except:
        pass
    try:
        data.mop = float(request.POST["mop"])
    except:
        pass
    data.branch = request.user.userprofile.branch

    transferid = request.POST["transferid"]

    stocktransfer = StockTransferList.objects.filter(id=int(transferid)).first()

    quantity = stocktransfer.quantity

    try:
        data.save()
        stocktransfer.status = "Recieved"
        stocktransfer.save()
    except IntegrityError as e:
        messages.error(request, "Product already exists.")
        return redirect("stocktransferlist")
    except:
        messages.error(request, "An error occured.")
        return redirect("stocktransferlist")

    ##### adding transfered stock in purchase #######
    bp = BranchPurchase()
    bp.name = Products.objects.filter(
        Q(name=request.POST["name"]) & Q(branch=request.user.userprofile.branch)
    ).first()
    bp.supplier = (
        StockTransferList.objects.filter(id=int(transferid)).first().frombranch
    )
    bp.invoicenumber = f"ST{transferid}"
    bp.invoicedate = datetime.now()
    bp.barcodenumber = generate_unique_id("PurchaseBarcode", "PBC")[3::]
    bp.totalquantity = quantity
    bp.price = float(request.POST["price"])
    bp.sellingprice = float(request.POST["sellingprice"])
    bp.purchasegst = purchasegst.name
    bp.salegst = salegst.name
    bp.purchaseid = generate_unique_id("Purchase", "PR")
    bp.branch = request.user.userprofile.branch
    bp.totalamount = 0
    bp.totalbillingamount = 0
    bp.amountrecieved = 0
    bp.duebalance = 0
    bp.discount = 0
    try:
        bp.mrp = float(request.POST["mrp"])
    except:
        pass
    try:
        bp.mop = float(request.POST["mop"])
    except:
        pass
    bp.purchase_type = "transfer"
    bp.save()
    ##### adding transfered stock in purchase #######

    if request.user.is_superuser:
        stock = Stock()
        productname = request.POST["name"]
        stock.name = Products.objects.filter(
            Q(name=productname) & Q(branch=request.user.userprofile.branch)
        ).first()

        stock.quantity = int(quantity)
        stock.purchaserate = float(request.POST["price"])
        stock.salerate = float(request.POST["sellingprice"])
        stock.save()

    else:
        stock = BranchStock()
        productname = request.POST["name"]
        stock.name = Products.objects.filter(
            Q(name=productname) & Q(branch=request.user.userprofile.branch)
        ).first()
        stock.branch = request.user.userprofile.branch
        stock.purchaserate = float(request.POST["price"])
        stock.salerate = float(request.POST["sellingprice"])
        stock.quantity = int(quantity)
        stock.save()

    stocktr = StockTransaction()
    prod  =Products.objects.filter(
        Q(name=productname) & Q(branch=request.user.userprofile.branch)
    ).first()
    stocktr.product = prod
    stocktr.initial_quantity = 0
    stocktr.quantity = int(quantity)
    stocktr.transactiontype = "Add"
    stocktr.branch = request.user.userprofile.branch
    try:
        stocktr.reference_number  = prod.id
        stocktr.transaction_category  = 'Product Entry From Stock Transfer'
    except:
        stocktr.reference_number  = 'NA'
        stocktr.transaction_category  = 'Product Entry From Stock Transfer'
    stocktr.save()

    return redirect("stocktransferlist")


@login_required
def addStockStockTransfer(request):

    branchstockid = request.POST["stock"]
    stock = BranchStock.objects.filter(id=int(branchstockid)).first()
    product = stock.name
    stock_quantity = stock.quantity

    transferid = request.POST["transferid"]
    stocktransfer = StockTransferList.objects.filter(id=int(transferid)).first()
    quantity = stocktransfer.quantity
    stock.quantity = stock_quantity + quantity

    stocktr = StockTransaction()
    stocktr.product = stock.name
    stocktr.initial_quantity = 0
    stocktr.quantity = int(quantity)
    stocktr.transactiontype = "Add"
    stocktr.branch = request.user.userprofile.branch
    try:
        stocktr.reference_number  = product.id
        stocktr.transaction_category  = 'Stock Entry From Stock Transfer'
    except:
        stocktr.reference_number  = 'NA'
        stocktr.transaction_category  = 'Stock Entry From Stock Transfer'

    try:
        stock.save()
        stocktr.save()
        stocktransfer.status = "Recieved"
        stocktransfer.save()
    except:
        messages.error(request, "An error occured.")
        return redirect("stocktransferlist")

    ##### adding transfered stock in purchase #######
    bp = BranchPurchase()
    bp.name = product
    bp.supplier = (
        StockTransferList.objects.filter(id=int(transferid)).first().frombranch
    )
    bp.invoicenumber = f"ST{transferid}"
    bp.invoicedate = datetime.now()
    bp.barcodenumber = generate_unique_id("PurchaseBarcode", "PBC")[3::]
    bp.totalquantity = quantity
    bp.price = product.price
    bp.sellingprice = product.sellingprice
    bp.purchasegst = product.purchasegst.name
    bp.salegst = product.salegst.name
    bp.purchaseid = generate_unique_id("Purchase", "PR")
    bp.branch = request.user.userprofile.branch
    bp.totalamount = 0
    bp.totalbillingamount = 0
    bp.amountrecieved = 0
    bp.duebalance = 0
    bp.discount = 0
    try:
        bp.mrp = product.mrp
    except:
        pass
    try:
        bp.mop = product.mop
    except:
        pass
    bp.purchase_type = "transfer"
    bp.save()
    ##### adding transfered stock in purchase #######

    return redirect("stocktransferlist")


@login_required
def stockadjustment(request):

    if request.user.is_superuser:
        branches = Branch.objects.filter(Q(branchtype="Own") | Q(name="WAREHOUSE"))
    else:
        branches = [request.user.userprofile.branch]

    context = {
        "branches": branches,
    }
    return render(request, "stockadjustment.html", context)



@login_required
def openingstock(request):

    if request.user.is_superuser:
        branches = Branch.objects.filter(Q(branchtype="Own") | Q(name="WAREHOUSE"))
    else:
        branches = [request.user.userprofile.branch]

    context = {
        "branches": branches,
    }
    return render(request, "openingstock.html", context)


def get_product_list_by_branchid(request):
    received_data = QueryDict(request.body)
    branchid = received_data.get("branchid")

    if int(branchid) == 1:
        products = Stock.objects.filter().values("name")
    else:
        products = BranchStock.objects.filter(branch=int(branchid)).values("name")

    products_list = []

    for item in products:
        dic = {}
        dic["product"] = Products.objects.filter(id=int(item["name"])).first().name
        dic["id"] = item["name"]
        products_list.append(dic)

    resp = {"Response": products_list}

    return JsonResponse(resp)


def get_product_stock_details(request):
    received_data = QueryDict(request.body)
    branchid = received_data.get("branchid")
    productid = received_data.get("productid")

    resp = {}

    if int(branchid) == 1:
        stock = Stock.objects.filter(name=int(productid)).first()
    else:
        stock = BranchStock.objects.filter(
            Q(name=int(productid)) & Q(branch=int(branchid))
        ).first()

    resp["product"] = stock.name.name
    resp["available_qty"] = stock.quantity
    resp["branchid"] = branchid

    return JsonResponse(resp)


def savestockadjustment(request):

    productid = request.POST.get("product")
    availableqty = request.POST.get("availableqty")
    adjustment = request.POST.get("adjustment")
    quantity = request.POST.get("quantity")
    reason = request.POST.get("reason")
    branch = request.POST.get("branch")

    stockadj = StockAdjustment()
    stockadj.sa_number = generate_unique_id("StockAdjustment", "SA")
    stockadj.product = Products.objects.filter(id=int(productid)).first()
    stockadj.adjustment = adjustment
    stockadj.quantity = int(quantity)
    stockadj.reason = reason
    stockadj.status = "Pending"
    stockadj.branch = Branch.objects.filter(id=int(branch)).first()
    try:
        stockadj.purchase_rate = (
            Products.objects.filter(id=int(productid)).first().price
        )
        stockadj.sale_rate = (
            Products.objects.filter(id=int(productid)).first().sellingprice
        )
        stockadj.purchase_tax = float(
            Products.objects.filter(id=int(productid)).first().purchasegst.percentage
        )
        stockadj.sale_tax = float(
            Products.objects.filter(id=int(productid)).first().salegst.percentage
        )
    except:
        pass
    stockadj.save()

    return redirect("stockadjustmentlist")


def stockadjustmentlist(request):

    current_user = request.user

    if current_user.is_superuser:
        data = StockAdjustment.objects.all().order_by("-pk")
    else:
        data = StockAdjustment.objects.filter(
            branch=current_user.userprofile.branch
        ).order_by("-pk")

    context = {"data": data}

    return render(request, "stockadjustmentlist.html", context)


def stockadjustmentview(request, sa_number):

    item = StockAdjustment.objects.filter(sa_number=sa_number).first()

    content = {"item": item}

    return render(request, "stockadjustmentview.html", content)


def confirmstockadjustment(request):

    current_user = request.user

    sa_number = request.POST.get("sa_number")

    item = StockAdjustment.objects.filter(sa_number=sa_number).first()
    item.status = "Confirmed"
    product = item.product
    quantity = item.quantity
    adjustment = item.adjustment
    branch = item.branch
    item.save()

    if branch.name == "WAREHOUSE":
        stock = Stock.objects.filter(name=product).first()
        current_quantity = stock.quantity
    else:
        stock = BranchStock.objects.filter(Q(branch=branch) & Q(name=product)).first()
        current_quantity = stock.quantity

 

    if adjustment == "Decrease":

  

        stock.quantity = current_quantity - quantity

        stocktr = StockTransaction()
        stocktr.product = product
        stocktr.initial_quantity = 0
        stocktr.quantity = quantity
        stocktr.transactiontype = "Sub"
        stocktr.branch = branch
        try:
            stocktr.reference_number  = product.id
            stocktr.transaction_category  = 'Stock Adjustment'
        except:
            stocktr.reference_number  = 'NA'
            stocktr.transaction_category  = 'Stock Adjustment'

        stocktr.save()
        stock.save()

    elif adjustment == "Increase":

    

        stock.quantity = current_quantity + quantity

        stocktr = StockTransaction()
        stocktr.product = product
        stocktr.initial_quantity = 0
        stocktr.quantity = quantity
        stocktr.transactiontype = "Add"
        stocktr.branch = branch
        try:
            stocktr.reference_number  = product.id
            stocktr.transaction_category  = 'Stock Adjustment'
        except:
            stocktr.reference_number  = 'NA'
            stocktr.transaction_category  = 'Stock Adjustment'
        stocktr.save()
        stock.save()

    return redirect(reverse("stockadjustmentview", kwargs={"sa_number": sa_number}))


# end stock function


# Sale function start


@user_passes_test(
    partial(check_permission, page="Salelist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def sale(request):
    currentuser = request.user
    if currentuser.is_superuser:
        homebranch = Branch.objects.get(
            name="WAREHOUSE"
        )  # warehouse branch is the branch of super user
        data = Sale.objects.all().order_by("-pk")
    else:
        homebranch = UserProfile.objects.get(user=currentuser).branch
        data = Sale.objects.filter(branch=homebranch).order_by("-pk")

    saleid_set = set()
    datafinal = [
        sale
        for sale in data
        if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
    ]

    if request.user.is_superuser:
        categories = Catagories.objects.all()
        brands = Brand.objects.all()
    else:
        brands = Brand.objects.filter(branch=request.user.userprofile.branch)
        categories = Catagories.objects.filter(branch=request.user.userprofile.branch)

    context = {
        "data": datafinal,
        "categories": categories,
        "brands": brands,
        "user": currentuser,
    }
    return render(request, "sale.html", context)




@user_passes_test(
    partial(check_permission, page="Salelist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def sale_receivable(request):
    currentuser = request.user
    if currentuser.is_superuser:
        homebranch = Branch.objects.get(
            name="WAREHOUSE"
        )  # warehouse branch is the branch of super user
        data = Sale.objects.filter(Q(amountrecieved__lt=F("totalbillingamount"))).order_by("-pk")
    else:
        homebranch = UserProfile.objects.get(user=currentuser).branch
        data = Sale.objects.filter(Q(branch=homebranch) & Q(amountrecieved__lt=F("totalbillingamount"))).order_by("-pk")

    saleid_set = set()
    datafinal = [
        sale
        for sale in data
        if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
    ]

    if request.user.is_superuser:
        categories = Catagories.objects.all()
        brands = Brand.objects.all()
    else:
        brands = Brand.objects.filter(branch=request.user.userprofile.branch)
        categories = Catagories.objects.filter(branch=request.user.userprofile.branch)

    context = {
        "data": datafinal,
        "categories": categories,
        "brands": brands,
        "user": currentuser,
    }
    return render(request, "salereceivable.html", context)

@login_required
def search_sale(request):
    currentuser = request.user
    request_data = request.POST
    category = request_data.get("sale_category")
    subcategory = request_data.get("sale_subcategory")
    brand = request_data.get("sale_brand")

    if category == "" and subcategory == "" and brand == "":
        return redirect(reverse("sale"))

    category = Catagories.objects.filter(name=category).first()
    subcategory = SubCatagories.objects.filter(name=subcategory).first()
    brand = Brand.objects.filter(name=brand).first()
    data = []

    if category and subcategory and brand:
        if currentuser.is_superuser:
            homebranch = Branch.objects.get(
                name="WAREHOUSE"
            )  # warehouse branch is the branch of uper user
            data = Sale.objects.filter(
                Q(name__catagory=category)
                & Q(name__subcatagory=subcategory)
                & Q(name__brand=brand)
            ).order_by("-pk")
        else:
            homebranch = currentuser.userprofile.branch
            data = Sale.objects.filter(
                Q(branch=homebranch)
                & Q(name__catagory=category)
                & Q(name__subcatagory=subcategory)
                & Q(name__brand=brand)
            ).order_by("-pk")
    elif category and subcategory:
        if currentuser.is_superuser:
            homebranch = Branch.objects.get(
                name="WAREHOUSE"
            )  # warehouse branch is the branch of uper user
            data = Sale.objects.filter(
                Q(name__catagory=category) & Q(name__subcatagory=subcategory)
            ).order_by("-pk")
        else:
            homebranch = currentuser.userprofile.branch
            data = Sale.objects.filter(
                Q(branch=homebranch)
                & Q(name__catagory=category)
                & Q(name__subcatagory=subcategory)
            ).order_by("-pk")
    elif category and brand:
        if currentuser.is_superuser:
            homebranch = Branch.objects.get(
                name="WAREHOUSE"
            )  # warehouse branch is the branch of uper user
            data = Sale.objects.filter(
                Q(name__catagory=category) & Q(name__brand=brand)
            ).order_by("-pk")
        else:
            homebranch = currentuser.userprofile.branch
            data = Sale.objects.filter(
                Q(branch=homebranch) & Q(name__catagory=category) & Q(name__brand=brand)
            ).order_by("-pk")
    elif category:
        if currentuser.is_superuser:
            homebranch = Branch.objects.get(
                name="WAREHOUSE"
            )  # warehouse branch is the branch of uper user
            data = Sale.objects.filter(name__catagory=category).order_by("-pk")
        else:
            homebranch = currentuser.userprofile.branch
            data = Sale.objects.filter(
                Q(branch=homebranch) & Q(name__catagory=category)
            ).order_by("-pk")
    elif brand:
        if currentuser.is_superuser:
            homebranch = Branch.objects.get(
                name="WAREHOUSE"
            )  # warehouse branch is the branch of uper user
            data = Sale.objects.filter(name__brand=brand).order_by("-pk")
        else:
            homebranch = currentuser.userprofile.branch
            data = Sale.objects.filter(
                Q(branch=homebranch) & Q(name__brand=brand)
            ).order_by("-pk")

    saleid_set = set()
    datafinal = [
        sale
        for sale in data
        if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
    ]

    if request.user.is_superuser:
        categories = Catagories.objects.all()
        brands = Brand.objects.all()
    else:
        brands = Brand.objects.filter(branch=request.user.userprofile.branch)
        categories = Catagories.objects.filter(branch=request.user.userprofile.branch)

    context = {
        "data": datafinal,
        "categories": categories,
        "brands": brands,
    }

    return render(request, "sale.html", context)


@user_passes_test(
    partial(check_permission, page="Saleview"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def saleview(request, pid):
    data = Sale.objects.filter(saleid=pid)
    # Fetch the common fields from the DB
    
    for item in data:
        invoicenumber = item.invoicenumber
        invoicedate = item.invoicedate
        customer = item.customer
        totalamount = item.totalamount
        totaltax = item.totaltax
        saleid = item.saleid
        branch = item.branch
        totalbillingamount = item.totalbillingamount
        amountrecieved = item.amountrecieved
        duebalance = item.duebalance
        discount = item.discount
        discountmethod = item.discountmethod
        paymentmode = item.paymentmode
        salesperson = item.added_by
        # SG-28
        customer_gst = item.customer_gst_number

        break

    if totaltax == None:
        totaltax = 0

    ## 24/10/2024 ###
    product_total = 0
    for item in data:
        salegst_ = Tax.objects.filter(Q(name=item.salegst)&Q(branch=item.branch)).first().percentage
        price = item.price
        quantity = item.totalquantity
        total = (float(price) + (float(price) * float(salegst_) / 100)) * float(quantity)
        product_total += total


    context = {
        "total_excluding_tax_after_discount":round(totalamount,2),
        "total_incl_tax" : product_total,
        "totaltax": totaltax,
        "invoicenumber": invoicenumber,
        "invoicedate": invoicedate,
        "customer": customer,
        "totalamount": totalamount,
        "saleid": saleid,
        "branch": branch,
        "data": data,
        "totalbillingamount": totalbillingamount,
        "amountrecieved": amountrecieved,
        "duebalance": duebalance,
        "discount": discount,
        "discountmethod": discountmethod,
        "paymentmode": paymentmode,
        "salesperson": salesperson,
        "customer_gst": customer_gst,
    }
    return render(request, "saleview.html", context)


@user_passes_test(
    partial(check_permission, page="Saledueform"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def saleDueForm(request, saleid):
    sale = Sale.objects.filter(saleid=saleid).first()
    today = date.today()
    paymentmode = PaymentMode.objects.all()
    context = {"saledata": sale, "datetoday": today, "paymentmodes": paymentmode}
    return render(request, "saledueform.html", context)


@user_passes_test(
    partial(check_permission, page="Saleform"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def saleForm(request):

    currentuser = request.user
    current_branch = request.user.userprofile.branch
    if currentuser.is_superuser:
        products = (
            Stock.objects.filter(quantity__gt=0).values_list("id", flat=True).distinct()
        )
        products = [Stock.objects.filter(id=pr).first().name for pr in products]
        salespersons = [
            prof.user for prof in UserProfile.objects.filter(branch=current_branch)
        ]

    else:
        products = (
            BranchStock.objects.filter(
                Q(quantity__gt=0) & Q(branch=currentuser.userprofile.branch)
            )
            .values_list("id", flat=True)
            .distinct()
        )
        products = [BranchStock.objects.filter(id=pr).first().name for pr in products]
        salespersons = [
            prof.user for prof in UserProfile.objects.filter(branch=current_branch)
        ]

    # tax = Tax.objects.all()
    tax = Tax.objects.filter(branch=request.user.userprofile.branch)

    invoicenumber = UniqueIdGenerator.objects.filter(model="Invoice").last()
    invoicenumber = (
        str(invoicenumber.prefix)
        + f'-{str(date.today().year)[2:]}{datetime.now().strftime("%m")}'
        + str(invoicenumber.uniqueid)
    )

    regular_customer_list = []
    if (
        currentuser.userprofile.role == "Branch Admin"
        or currentuser.userprofile.role == "Franchise Admin"
    ):
        regular_customer_list = Customers.objects.filter(
            branch=currentuser.userprofile.branch
        )

    if currentuser.is_superuser:
        stocks = Stock.objects.filter(quantity__gt=0)
    else:
        stocks = BranchStock.objects.filter(
            Q(quantity__gt=0) & Q(branch=currentuser.userprofile.branch)
        )
    stock_dict = []
    for i in stocks:
        dict = {}
        dict["product"] = i.name
        dict["quantity"] = i.quantity
        dict["purchase_rate"] = i.name.price
        dict["purchase_tax"] = i.name.purchasegst
        dict["purchase_total"] = (i.name.price) + (
            i.name.price * (float(i.name.purchasegst.percentage) / 100)
        )
        stock_dict.append(dict)

    # print(stock_dict)
    paymentmode = PaymentMode.objects.all()

    context = {
        "products": products,
        "customers": Branch.objects.filter(
            Q(branchtype="Franchise") | Q(branchtype="External")
        ),
        "tax": tax,
        "added_customer": "",
        "invoice_number": invoicenumber,
        "salespersons": salespersons,
        "user": currentuser,
        "regular_customers": regular_customer_list,
        "stock_list": stock_dict,
        "paymentmode": paymentmode,
    }

    return render(request, "addsale.html", context)


#### sales return


@user_passes_test(
    partial(check_permission, page="Salereturnform"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def salesReturn(request):

    user = request.user
    # if user.is_superuser:
    #     data = Sale.objects.all()
    # else:
    data = Sale.objects.filter(branch=user.userprofile.branch)
    # invoicenumber_list = [i.invoicenumber for i in data]
    invoicenumber_list = [{"invoicenumber":i.invoicenumber,"saleid":i.saleid} for i in data]
    paymentmode = PaymentMode.objects.all()
    context = {
        "selected_invoiceno": "",
        "invoicenumbers": invoicenumber_list,
        "data": data,
        "paymentmode": paymentmode,
        'discount':0,
    }
    return render(request, "salesreturnnew.html", context)


@user_passes_test(
    partial(check_permission, page="Salereturnlist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def salesReturnList(request):

    currentuser = request.user
    if currentuser.is_superuser:
        data = SaleReturn.objects.all().order_by("-pk")
    else:
        data = SaleReturn.objects.filter(
            branch=currentuser.userprofile.branch
        ).order_by("-pk")

    salereturnid_set = set()
    datafinal = [
        sale
        for sale in data
        if (
            sale.salereturnid not in salereturnid_set
            and not salereturnid_set.add(sale.salereturnid)
        )
    ]

    context = {
        "data": datafinal,
    }
    return render(request, "salesreturnlist.html", context)


@user_passes_test(
    partial(check_permission, page="Salereturndetails"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def salesReturnDetails(request, returnid):

    currentuser = request.user

    data = SaleReturn.objects.filter(salereturnid=returnid)

    # Fetch the common fields from the DB
    for item in data:
        invoicenumber = item.invoicenumber
        entrydate = item.createddate
        customer = item.customer
        totalamount = item.totalamount
        returnid = item.salereturnid
        branch = item.branch
        netamount = item.nettotal
        discount = item.discount
        paymentmode = item.paymentmode
        totaltax = item.totaltax
        totalqty = item.totalquantity

        break
    if totaltax == None or totaltax == "":
        totaltax = 0

    context = {
        "totaltax": totaltax,
        "invoicenumber": invoicenumber,
        "entrydate": entrydate,
        "customer": customer,
        "totalamount": totalamount,
        "returnid": returnid,
        "netamount": netamount,
        "branch": branch,
        "data": data,
        "totalqty": totalqty,
        "discount": discount,
        "paymentmode": paymentmode,
        "user": currentuser,
    }

    return render(request, "salesreturndetails.html", context)


@login_required
def salesReturnSearch(request):
    user = request.user

    saleid = request.POST["invoiceno"]
    if user.is_superuser:
        data = Sale.objects.all()
        salesdata = Sale.objects.filter(saleid=saleid)

    else:
        data = Sale.objects.filter(branch=user.userprofile.branch)
        salesdata = Sale.objects.filter(saleid=saleid)

    invoicenumber_list = [{"invoicenumber":i.invoicenumber,"saleid":i.saleid} for i in data]
    tax = Tax.objects.filter(branch=request.user.userprofile.branch)

    

    for item in salesdata:
        invoicenumber = item.invoicenumber
        invoicedate = item.invoicedate
        customer = item.customer
        customerid = item.customerid
        customertype = item.customertype
        totalamount = item.totalamount
        salesid = item.saleid
        branch = item.branch
        discountmethod = item.discountmethod
        discount = item.discount

        break
  
    salereturn_exist = SaleReturn.objects.filter(invoicenumber=invoicenumber).first()
    if salereturn_exist:
        already_returned = True
    else:
        already_returned = False

    sales_data_new = []
    branch = request.user.userprofile.branch
    for i in salesdata:
        dic = {}
        ############### checking balance qty ##################
        if already_returned:
            product = i.name
            saleid = i.saleid
            product_exist = SaleReturn.objects.filter(Q(product=product)&Q(invoicenumber=invoicenumber)&Q(saleid=saleid)).exists()
            if product_exist:
                salereturnobj = SaleReturn.objects.filter(Q(product=product)&Q(invoicenumber=invoicenumber)&Q(saleid=saleid))
                returned_qty = 0
                for j in salereturnobj:
                    returned_qty = returned_qty + j.returnquantity
                balance_qty = i.totalquantity - returned_qty
                dic['balance_qty'] = balance_qty
            else:
                dic['balance_qty'] = i.totalquantity
        else:
            dic['balance_qty'] = i.totalquantity
        ############### checking balance qty ##################

        dic["barcodenumber"] = i.barcodenumber
        dic["name"] = i.name
        dic["totalquantity"] = i.totalquantity
        dic["price"] = i.price
        dic["salegstname"] = i.salegst
        dic["tax"] = (
            Tax.objects.filter(
                Q(name=i.salegst) & Q(branch=branch )
            )
            .first()
            .percentage
        )
        
        sales_data_new.append(dic)
    paymentmode = PaymentMode.objects.all()
    context = {
        "customerid": customerid,
        "customertype": customertype,
        "tax": tax,
        "selected_invoiceno": invoicenumber,
        "selected_saleid": saleid,
        "invoicenumber": invoicenumber,
        "invoicedate": invoicedate,
        "customer": customer,
        "branch": branch,
        "salesid": salesid,
        "salesdata": sales_data_new,
        "invoicenumbers": invoicenumber_list,
        "paymentmode": paymentmode,
        "user": user,
        "already_returned":already_returned,
        'discount':discount,
        'discountmethod':discountmethod
    }

    return render(request, "salesreturnnew.html", context)


@login_required
def addSalesReturn(request):

    

    check_status_with_constant = partial(check_status_common, attribute="price-sale")
    length_count = list(filter(check_status_with_constant, request.POST.keys()))

    # return redirect("purchase")
    salereturnid = generate_unique_id("SalesReturn", "SRT")
    return_customer = request.POST["cust"]
    for i in range(1, ((len(length_count)+2))):
        data = SaleReturn()
        i = str(i)
        try:
            productcheck = request.POST["productcheck" + i]
        except:
            continue
        if productcheck != "on":
            continue
        data.invoicenumber = request.POST["invno-sale"]
        data.saleid = request.POST['saleid']
        data.customer = return_customer
        data.customertype = request.POST["custtype"]
        data.customerid = request.POST["custid"]
        data.barcode = request.POST["barcode-sale" + i]
        data.salereturnid = salereturnid
        data.paymentmode = request.POST["paymentmode"]

        # data.product = Products.objects.get(name=request.POST['product-sale' + i])
        data.product = Products.objects.filter(
            Q(name=request.POST["product-sale" + i])
            & Q(branch=request.user.userprofile.branch)
        ).first()

        data.returnquantity = request.POST["returnqty-sale" + i]
        data.rate = request.POST["rate-sale" + i]
        data.tax = Tax.objects.get(
            Q(name=request.POST["tax-sale" + i])
            & Q(branch=request.user.userprofile.branch)
        )
        data.refundamount = request.POST["refundamount-sale" + i]
        data.reason = request.POST["reason-sale" + i]
        data.totalamount = request.POST["totalamount-sale"]
        if request.POST["discount-sale"] == "":
            data.discount = 0
        else:
            data.discount = request.POST["discount-sale"]
        data.nettotal = request.POST["nettotal-sale"]
        data.totaltax = request.POST["totaltax-sale"]
        data.totalquantity = request.POST["totalqty-sale"]
        data.branch = Branch.objects.get(id=int(request.POST["branch-sale"]))
       
        data.save()

        # productid = Products.objects.get(name=request.POST['product-sale' + i]).id
        productid = (
            Products.objects.filter(
                Q(name=request.POST["product-sale" + i])
                & Q(branch=request.user.userprofile.branch)
            )
            .first()
            .id
        )
        currentuserbranch = request.user.userprofile.branch
        salebranch = Branch.objects.get(id=int(request.POST["branch-sale"]))

        if salebranch.name == "WAREHOUSE":

            if Stock.objects.filter(name_id=productid):

                stock = Stock.objects.filter(name_id=productid).first()
                qty = stock.quantity
                stock.quantity = int(qty) + int(request.POST["returnqty-sale" + i])
                stock.save()
        else:

            if BranchStock.objects.filter(Q(name_id=productid) & Q(branch=salebranch)):

                stock = BranchStock.objects.filter(
                    Q(name_id=productid) & Q(branch=salebranch)
                ).first()
                qty = stock.quantity
                stock.quantity = int(qty) + int(request.POST["returnqty-sale" + i])
                stock.save()

        strans_obj = StockTransaction.objects.filter(
            Q(
                product=Products.objects.filter(
                    Q(id=productid) & Q(branch=request.user.userprofile.branch)
                ).first()
            )
            & Q(branch=request.user.userprofile.branch)
        ).first()
        if strans_obj:
            stocktr = StockTransaction()
            stocktr.product = Products.objects.filter(
                Q(id=productid) & Q(branch=request.user.userprofile.branch)
            ).first()
            stocktr.initial_quantity = strans_obj.initial_quantity
            stocktr.quantity = int(request.POST["returnqty-sale" + i])
            stocktr.transactiontype = "Add"
            stocktr.branch = request.user.userprofile.branch
            try:
                stocktr.reference_number  = request.POST["invno-sale"]
                stocktr.transaction_category  = 'Sales Return'
            except:
                stocktr.reference_number  = 'NA'
                stocktr.transaction_category  = 'Sales Return'
            stocktr.save()
        else:
            stocktr = StockTransaction()
            stocktr.product = Products.objects.filter(
                Q(id=productid) & Q(branch=request.user.userprofile.branch)
            ).first()
            stocktr.initial_quantity = 0
            stocktr.quantity = int(request.POST["returnqty-sale" + i])
            stocktr.transactiontype = "Add"
            stocktr.branch = request.user.userprofile.branch
            try:
                stocktr.reference_number  = request.POST["invno-sale"]
                stocktr.transaction_category  = 'Sales Return'
            except:
                stocktr.reference_number  = 'NA'
                stocktr.transaction_category  = 'Sales Return'
            stocktr.save()

    transaction = Transaction()
    transaction.transactionid = salereturnid
    transaction.amount = float(request.POST["nettotal-sale"])
    transaction.transactiontype = "salereturn"
    transaction.paymentmode = request.POST["paymentmode"]
    transaction.branch = Branch.objects.get(id=int(request.POST["branch-sale"]))
    transaction.invoice_number = request.POST["invno-sale"]
    transaction.accounts = request.POST["cust"]
    transaction.remarks = ""
    transaction.transactiondate = datetime.now()
    transaction.subledger = func_get_sub_ledgers(request,'Sales Return')
    transaction.save()

    financial_statement = addaccounts.AccountStatement()



    ledger_params = {
        "salereturnid": salereturnid,
        "amount": float(request.POST["nettotal-sale"]),
        "customer_or_vendor": return_customer,
        "userbranch": request.user.userprofile.branch,
         "paymentmode": request.POST["paymentmode"],
    }

    financial_statement.add_ledger("SaleReturn", ledger_params)

    

    cashbook_params = {
        "userbranch": request.user.userprofile.branch,
        "amount": float(request.POST["nettotal-sale"]),
        "paymentmode": request.POST["paymentmode"],
        "branch_wid":request.user.userprofile.branch,
         'subledger' : func_get_sub_ledgers(request,'Sales Return')
    }

    financial_statement.add_cashbook("SaleReturn", cashbook_params)

    # sale_return_ledger = ledgercli.LedgerBook(transaction.branch)
  

    # ledger_paymentmode = request.POST["paymentmode"]
    # ledger_totaltax = float(request.POST["totaltax-sale"])
    # ledger_invoiceno = request.POST["invno-sale"]
 
    # params = {
    #     "invoicedate": date.today(),
    #     "mode": ledger_paymentmode,
    #     "taxamount": ledger_totaltax,
    #     "invoiceno": ledger_invoiceno,
    #     "amountpaid": float(request.POST["nettotal-sale"]),
    # }

    # sale_return_ledger.post_sale_return(**params)
    general_ledger_params = {
        "salereturnid": salereturnid,
        "voucherid": salereturnid,
        "amount": float(request.POST["nettotal-sale"]),
        "description": f"Sale Return from {return_customer}",
        "userbranch": request.user.userprofile.branch,
         "paymentmode": request.POST["paymentmode"],
    }

    financial_statement.add_generalledger("SaleReturn", general_ledger_params)

    return redirect("salesreturn")


def func_generate_sale_pdf(request, id, action):

    user = request.user
    # get a list of dictionaries of given values
    data = Sale.objects.filter(saleid=id).values(
    "name", "barcodenumber", "price", "salegst", "totalquantity"
        )
    # Fetch the common fields from the DB
    sale = Sale.objects.filter(saleid=id).first()
    invoicenumber = sale.invoicenumber
    invoicedate = sale.invoicedate
    customer = sale.customer
    sale_type = sale.paymentmode
    totalamount = sale.totalamount
    totalbillingamount = sale.totalbillingamount
    saleid = sale.saleid
    branch = sale.branch
    amountrecieved = sale.amountrecieved
    duebalance = sale.duebalance
    discount = sale.discount
    discountmethod = sale.discountmethod
    if sale.totaltax == None or sale.totaltax == "":
        totaltax = 0
    else:
        totaltax = sale.totaltax

    data_list = []
    for item in data:

        price_ = item['price']
        salegst_ = Tax.objects.filter(Q(name=item['salegst'])&Q(branch=branch)).first().percentage
        total = (float(price_) + (float(price_) * float(salegst_) / 100)) * float(item["totalquantity"])
        prod_tax = (float(price_) * float(salegst_) / 100)
        data_dict = {
            "name": Products.objects.get(id=item["name"]).name,
            "barcodenumber": item["barcodenumber"],
            "price": item["price"],
            "salegst": item["salegst"],
            "salegst_percentage": salegst_,
            "totalquantity": item["totalquantity"],
            "total": total,
            "prod_tax":prod_tax
        }
        data_list.append(data_dict)

    company = request.user.userprofile.company
    company_name = company.company_name
    if branch.name == "WAREHOUSE":
        address_line1 = company.address_line1
        address_line2 = company.address_line2
        address_line3 = company.address_line3
        phone = ""
    else:
        address_line1 = branch.address
        phone = branch.phone
        address_line2 = ""
        address_line3 = ""

    logo = company.logo_url
    currentuser = request.user

    current_date = date.today()

    sale_obj = Sale.objects.filter(saleid=id).first()

    if sale_obj.branch.name == "WAREHOUSE":
        customerid = sale_obj.customerid
        customertype = "B2B"
        vatnumber = Branch.objects.filter(id=customerid).first().gstin
        phonenumber = Branch.objects.filter(id=customerid).first().phone
    else:
        customerid = sale_obj.customerid
        vatnumber = Customers.objects.filter(id=customerid).first().vatnumber
        customertype = Customers.objects.filter(id=customerid).first().customertype
        phonenumber = Customers.objects.filter(id=customerid).first().phone
        if customertype == "nan" or customertype == None or customertype == "":
            customertype == "B2C"

    totalworden = func_price_in_words(totalbillingamount, "en")
    totalwordar = func_price_in_words(totalbillingamount, "ar")

    total_excld_tax = totalamount - totaltax

    qrcode_base64 = func_generate_invoice_qrcode(totalbillingamount,totaltax,invoicedate)

    context = {
        'qrcode_base64':qrcode_base64,
        "total_excld_tax": total_excld_tax,
        "phonenumber": phonenumber,
        "vatnumber": vatnumber,
        "customertype": customertype,
        "currentdate": current_date,
        "invoicenumber": invoicenumber,
        "invoicedate": invoicedate,
        "customer": customer,
        "type": sale_type,
        "totalamount": totalamount,
        "totalbillingamount": totalbillingamount,
        "saleid": saleid,
        "branch": branch,
        "data": data_list,
        "amountrecieved": amountrecieved,
        "duebalance": duebalance,
        "discount": discount,
        "discountmethod": discountmethod,
        "id": id,
        "company_name": company_name,
        "address_line1": address_line1,
        "address_line2": address_line2,
        "address_line3": address_line3,
        "logo": GLOBAL_VARIABLES["current_host"] + logo.url,
        "phone": phone,
        "totaltax": totaltax,
        "current_user": currentuser,
        "current_host": str(request.get_host()),
        "totalworden": totalworden,
        "totalwordar": totalwordar,
    }
    try:
        PAGESIZE = PageSize.objects.filter(active=True).first().size
    except:
        PAGESIZE = "A4"

    language = Language.objects.first()
    if language:
        language = language.language
    else:
        language = None

    # create a template object
    if language == "ar":
        template = get_template("salespdfarabic.html")
    else:
        template = get_template("salespdf.html")

    # render the context dictionary values
    html = template.render(context)
    options = {"quiet": "", "encoding": "UTF-8", "page-size": PAGESIZE}
    css = os.path.join(BASE_DIR, "core", "static", "css", "salespdf.css")
    # generate the pdf from html
    pdf = pdfkit.from_string(html, False, options=options, css=css)
    response = HttpResponse(content_type="application/pdf")
    if action == "download":
        response["Content-Disposition"] = (
            f'attachment; filename="Sales_Invoice_{date.today()}.pdf"'
        )
    else:
        response["Content-Disposition"] = (
            f'inline; filename="Sales_Invoice_{date.today()}.pdf"'
        )
    response.write(pdf)
    return response


# def get_sale_pdf_bytes(request, id):

#     user = request.user
#     # get a list of dictionaries of given values
#     data = Sale.objects.filter(saleid=id).values(
#     "name", "barcodenumber", "price", "salegst", "totalquantity"
#         )
#     # Fetch the common fields from the DB
#     sale = Sale.objects.filter(saleid=id).first()
#     invoicenumber = sale.invoicenumber
#     invoicedate = sale.invoicedate
#     customer = sale.customer
#     sale_type = sale.paymentmode
#     totalamount = sale.totalamount
#     totalbillingamount = sale.totalbillingamount
#     saleid = sale.saleid
#     branch = sale.branch
#     amountrecieved = sale.amountrecieved
#     duebalance = sale.duebalance
#     discount = sale.discount
#     discountmethod = sale.discountmethod
#     if sale.totaltax == None or sale.totaltax == "":
#         totaltax = 0
#     else:
#         totaltax = sale.totaltax

#     data_list = []
#     for item in data:
#         price_ = item['price']
#         salegst_ = Tax.objects.filter(Q(name=item['salegst'])&Q(branch=branch)).first().percentage
#         total = (float(price_) + (float(price_) * float(salegst_) / 100)) * float(item["totalquantity"])
#         prod_tax = (float(price_) * float(salegst_) / 100)
#         data_dict = {
#             "name": Products.objects.get(id=item["name"]).name,
#             "barcodenumber": item["barcodenumber"],
#             "price": item["price"],
#             "salegst": item["salegst"],
#             "salegst_percentage": salegst_ ,
#             "totalquantity": item["totalquantity"],
#             "total": total,
#             "prod_tax":prod_tax
#         }
#         data_list.append(data_dict)

#     company = request.user.userprofile.company
#     company_name = company.company_name
#     if branch.name == "WAREHOUSE":
#         address_line1 = company.address_line1
#         address_line2 = company.address_line2
#         address_line3 = company.address_line3
#         phone = ""
#     else:
#         address_line1 = branch.address
#         phone = branch.phone
#         address_line2 = ""
#         address_line3 = ""

#     logo = company.logo_url
#     currentuser = request.user
#     current_date = date.today()

#     sale_obj = Sale.objects.filter(saleid=id).first()

#     if sale_obj.branch.name == "WAREHOUSE":
#         customerid = sale_obj.customerid
#         customertype = "B2B"
#         vatnumber = Branch.objects.filter(id=customerid).first().gstin
#         phonenumber = Branch.objects.filter(id=customerid).first().phone
#     else:
#         customerid = sale_obj.customerid
#         vatnumber = Customers.objects.filter(id=customerid).first().vatnumber
#         customertype = Customers.objects.filter(id=customerid).first().customertype
#         phonenumber = Customers.objects.filter(id=customerid).first().phone
#         if customertype == "nan" or customertype == None or customertype == "":
#             customertype == "B2C"

#     totalworden = func_price_in_words(totalbillingamount, "en")
#     totalwordar = func_price_in_words(totalbillingamount, "ar")

#     total_excld_tax = totalamount - totaltax

#     qrcode_base64 = func_generate_invoice_qrcode(totalbillingamount,totaltax,invoicedate)

#     context = {
#         'qrcode_base64':qrcode_base64,
#         "total_excld_tax": total_excld_tax,
#         "phonenumber": phonenumber,
#         "vatnumber": vatnumber,
#         "customertype": customertype,
#         "currentdate": current_date,
#         "invoicenumber": invoicenumber,
#         "invoicedate": invoicedate,
#         "customer": customer,
#         "type": sale_type,
#         "totalamount": totalamount,
#         "totalbillingamount": totalbillingamount,
#         "saleid": saleid,
#         "branch": branch,
#         "data": data_list,
#         "amountrecieved": amountrecieved,
#         "duebalance": duebalance,
#         "discount": discount,
#         "discountmethod": discountmethod,
#         "id": id,
#         "company_name": company_name,
#         "address_line1": address_line1,
#         "address_line2": address_line2,
#         "address_line3": address_line3,
#         "logo": GLOBAL_VARIABLES["current_host"] + logo.url,
#         "phone": phone,
#         "totaltax": totaltax,
#         "current_user": currentuser,
#         "current_host": str(request.get_host()),
#         "totalworden": totalworden,
#         "totalwordar": totalwordar,
#     }
#     try:
#         PAGESIZE = PageSize.objects.filter(active=True).first().size
#     except:
#         PAGESIZE = "A4"

#     language = Language.objects.first()
#     if language:
#         language = language.language
#     else:
#         language = None

#     # create a template object
#     if language == "ar":
#         template = get_template("salespdfarabic.html")
#     else:
#         template = get_template("salespdf.html")
#     # render the context dictionary values
#     html = template.render(context)
#     options = {"quiet": "", "encoding": "UTF-8", "page-size": PAGESIZE}
#     css = os.path.join(BASE_DIR, "core", "static", "css", "salespdf.css")
#     # generate the pdf from html
#     pdf = pdfkit.from_string(html, False, options=options, css=css)
#     return pdf



def get_sale_pdf_bytes(request, id):

    user = request.user
    # get a list of dictionaries of given values
    data = Sale.objects.filter(saleid=id).values("name", "barcodenumber", "price", "salegst", "totalquantity")

    # Fetch the common fields from the DB
    sale = Sale.objects.filter(saleid=id).first()
    invoicenumber = sale.invoicenumber
    invoicedate = sale.invoicedate
    customer = sale.customer
    sale_type = sale.paymentmode
    totalamount = sale.totalamount
    totalbillingamount = sale.totalbillingamount
    saleid = sale.saleid
    branch = sale.branch
    amountrecieved = sale.amountrecieved
    duebalance = sale.duebalance
    discount = sale.discount
    discountmethod = sale.discountmethod
    if sale.totaltax == None or sale.totaltax == "":
        totaltax = 0
    else:
        totaltax = sale.totaltax

    product_total = 0
    data_list = []
    for item in data:
        price_ = item['price']
        salegst_ = Tax.objects.filter(Q(name=item['salegst'])&Q(branch=branch)).first().percentage
        total = (float(price_) + (float(price_) * float(salegst_) / 100)) * float(item["totalquantity"])
        prod_tax = (float(price_) * float(salegst_) / 100)
        data_dict = {
            "name": Products.objects.get(id=item["name"]).name,
            "barcodenumber": item["barcodenumber"],
            "price": item["price"],
            "salegst": item["salegst"],
            "salegst_percentage": salegst_,
            "totalquantity": item["totalquantity"],
            "total": total,
            "prod_tax":prod_tax,

        }
        product_total += total
        data_list.append(data_dict)

    company = request.user.userprofile.company
    company_name = company.company_name
    if branch.name == "WAREHOUSE":
        address_line1 = company.address_line1
        address_line2 = company.address_line2
        address_line3 = company.address_line3
        phone = ""
    else:
        address_line1 = branch.address
        phone = branch.phone
        address_line2 = ""
        address_line3 = ""

    logo = company.logo_url
    currentuser = request.user
    current_date = date.today()

    sale_obj = Sale.objects.filter(saleid=id).first()

    if sale_obj.branch.name == "WAREHOUSE":
        customerid = sale_obj.customerid
        customertype = "B2B"
        vatnumber = Branch.objects.filter(id=customerid).first().gstin
        phonenumber = Branch.objects.filter(id=customerid).first().phone
    else:
        customerid = sale_obj.customerid
        vatnumber = Customers.objects.filter(id=customerid).first().vatnumber
        customertype = Customers.objects.filter(id=customerid).first().customertype
        phonenumber = Customers.objects.filter(id=customerid).first().phone
        if customertype == "nan" or customertype == None or customertype == "":
            customertype == "B2C"

    totalworden = func_price_in_words(totalbillingamount, "en")
    totalwordar = func_price_in_words(totalbillingamount, "ar")

    total_excld_tax = totalamount - totaltax
    total_excluding_tax_new = product_total - totaltax


    qrcode_base64 = func_generate_invoice_qrcode(totalbillingamount,totaltax,invoicedate)

    context = {
        "total_excluding_tax_new":total_excluding_tax_new,
        "product_total":product_total,
        'qrcode_base64':qrcode_base64,
        "total_excld_tax": total_excld_tax,
        "phonenumber": phonenumber,
        "vatnumber": vatnumber,
        "customertype": customertype,
        "currentdate": current_date,
        "invoicenumber": invoicenumber,
        "invoicedate": invoicedate,
        "customer": customer,
        "type": sale_type,
        "totalamount": totalamount,
        "totalbillingamount": totalbillingamount,
        "saleid": saleid,
        "branch": branch,
        "data": data_list,
        "amountrecieved": amountrecieved,
        "duebalance": duebalance,
        "discount": discount,
        "discountmethod": discountmethod,
        "id": id,
        "company_name": company_name,
        "address_line1": address_line1,
        "address_line2": address_line2,
        "address_line3": address_line3,
        "logo": GLOBAL_VARIABLES["current_host"] + logo.url,
        "phone": phone,
        "totaltax": totaltax,
        "current_user": currentuser,
        "current_host": str(request.get_host()),
        "totalworden": totalworden,
        "totalwordar": totalwordar,
    }
    try:
        PAGESIZE = PageSize.objects.filter(active=True).first().size
    except:
        PAGESIZE = "A4"

    language = Language.objects.first()

    if language:
        language = language.language
    else:
        language = None

    # create a template object
    if language == "ar":
        template = get_template("salespdfarabic.html")
    else:
        template = get_template("salespdf.html")

    # render the context dictionary values
    html = template.render(context)
    options = {"quiet": "", "encoding": "UTF-8", "page-size": PAGESIZE}
    css = os.path.join(BASE_DIR, "core", "static", "css", "salespdf.css")
    # generate the pdf from html
    pdf = pdfkit.from_string(html, False, options=options, css=css)
    return pdf


@login_required
def addSale(request):

    start_time = time.time()

    check_status_with_constant = partial(check_status_common, attribute="saleprice")
    length_count = list(filter(check_status_with_constant, request.POST.keys()))

    data = Sale()
    currentuser = request.user
    role = currentuser.userprofile.role
    branch = currentuser.userprofile.branch

    lastSaleId = data.unique_id = generate_unique_id("Sale", "SL")
    # purchase_id_branch = generate_unique_id("Purchase", "PR")
    wp_fullname = ""
    wp_phone = ""
    
    ###################################
    invoicenumber = request.POST["saleinvoicenumber"]
    sale_paymentmode = request.POST.get("salepaymentmode")
    customer_gst_number = request.POST.get("customergst", None)
    invoicedate = request.POST.get("saleinvoicedate")
    if invoicedate != None and invoicedate != "":
        invoicedate = datetime.strptime(invoicedate, "%d-%m-%Y").strftime(
            "%Y-%m-%d"
        )
    sale_person = User.objects.filter(
            id=int(request.POST.get("salesperson"))
        ).first()
    customer = request.POST.get("customer")
    if role == "Branch Admin" or role == "Franchise Admin":
        firstname = Customers.objects.filter(id=customer).first().firstname
        lastname = Customers.objects.filter(id=customer).first().lastname
        data.customer = f"{firstname} {lastname}"
        wp_fullname = f"{firstname} {lastname}"
        wp_phone = Customers.objects.filter(id=customer).first().phone
    elif currentuser.is_superuser:
        name = Branch.objects.get(id=customer).name
        data.customer = name
        wp_fullname = name
        wp_phone = Branch.objects.get(id=customer).phone
    ####################################

    customer_ledger = None
    for i in range(1, ((len(length_count)+1))):
      
        i = str(i)
        productname = request.POST.get("salename" + i)
        if not productname:
            continue  # Assuming no product supplied in the html form.
        
        data.invoicenumber = invoicenumber
        data.paymentmode = sale_paymentmode
        # SG-28
        data.customer_gst_number = customer_gst_number
        
        
        data.invoicedate = invoicedate

        data.branch = currentuser.userprofile.branch
        data.added_by = sale_person

        
        
        data.customerid = int(customer)

        try:
            cust_obj = Customers.objects.filter(id=int(customer)).first()
            if cust_obj:
                ledger_title = f"{cust_obj.firstname} {cust_obj.lastname} {cust_obj.unique_id}"
                cust_ledger = CoASubAccounts.objects.filter(Q(title=ledger_title)&Q(is_adminonly=True)).first()
                data.customer_ledger = cust_ledger
                customer_ledger = cust_ledger
        except:
            pass


        data.saleid = (
            lastSaleId  # Purchase ID will get incremented by 1 for each purchase
        )
        data.name = Products.objects.filter(
            Q(name=productname) & Q(branch=request.user.userprofile.branch)
        ).first()
        if request.POST["salebarcode" + i]:
            data.barcodenumber = request.POST["salebarcode" + i]
        data.price = request.POST["saleprice" + i]
        # data.purchasegst =  request.POST['purchasegst' + i ]
        data.salegst = request.POST["salegstsale" + i]
        productquantity = request.POST["salequantity" + i]
        data.totalquantity = productquantity

        data.totalamount = float(
            request.POST["saletotalamount"]
        )  # changed request.POST['netamount'] to request.POST['totalamount'] to total amount 11-07-2023
        data.totalbillingamount = float(request.POST["saletotalbillingamount"])
        data.totaltax = float(request.POST["saletotaltax"])
        data.amountrecieved = float(request.POST["salerecieved"])
        data.duebalance = float(request.POST["saleduebalance"])
        if request.POST["salemrp" + i]:
            data.mrp = float(request.POST["salemrp" + i])
        if request.POST["salemop" + i]:
            data.mop = float(request.POST["salemop" + i])
        if request.POST["salediscount"]:
            data.discount = float(request.POST["salediscount"])
        else:
            data.discount = 0
        data.discountmethod = request.POST["salediscountmethod"]
        data.status = "Pending"
        data.purchase_price = Products.objects.filter(
            Q(name=productname) & Q(branch=request.user.userprofile.branch)
        ).first().price
        data.purchase_tax = Products.objects.filter(
            Q(name=productname) & Q(branch=request.user.userprofile.branch)
        ).first().purchasegst.percentage
        data.pk = None  # if the primary key is not marked None, only the last row will be saved

        data.save()

        productid = (
            Products.objects.filter(
                Q(name=productname) & Q(branch=request.user.userprofile.branch)
            )
            .first()
            .id
        )
        # stock table has to be updated with the product count
        # if the product is not there in the stock, create the entry else update the stock quantity.
        stock = Stock()
        if currentuser.is_superuser:
            if Stock.objects.filter(name_id=productid):
                # Stock.objects.filter(name_id=productid).update(quantity=F('quantity')- productquantity )

                stock = Stock.objects.filter(name_id=productid).first()
                qty = stock.quantity
                stock.quantity = int(qty) - int(productquantity)
                stock.save()

        else:
            product = Products.objects.filter(
                Q(name=productname) & Q(branch=request.user.userprofile.branch)
            ).first()
            branchstock_obj = BranchStock.objects.filter(
                Q(branch=currentuser.userprofile.branch) & Q(name=product)
            ).first()
            if branchstock_obj:

                qty = branchstock_obj.quantity
                branchstock_obj.quantity = int(qty) - int(productquantity)
                branchstock_obj.save()

        strans_obj = StockTransaction.objects.filter(
            Q(
                product=Products.objects.filter(
                    Q(name=productname) & Q(branch=request.user.userprofile.branch)
                ).first()
            )
            & Q(branch=request.user.userprofile.branch)
        ).first()
        if strans_obj:
            stocktr = StockTransaction()
            stocktr.product = Products.objects.filter(
                Q(id=productid) & Q(branch=request.user.userprofile.branch)
            ).first()
            stocktr.initial_quantity = strans_obj.initial_quantity
            stocktr.quantity = int(productquantity)
            stocktr.transactiontype = "Sub"
            stocktr.branch = request.user.userprofile.branch
            stocktr.created_date =  invoicedate
            try:
                stocktr.reference_number  = request.POST["saleinvoicenumber"]
                stocktr.transaction_category  = 'Sales Entry'
            except:
                stocktr.reference_number  = 'NA'
                stocktr.transaction_category  = 'Sales Entry'
            stocktr.save()
        else:
            stocktr = StockTransaction()
            stocktr.product = Products.objects.filter(
                Q(id=productid) & Q(branch=request.user.userprofile.branch)
            ).first()
            stocktr.initial_quantity = 0
            stocktr.quantity = int(productquantity)
            stocktr.transactiontype = "Sub"
            stocktr.branch = request.user.userprofile.branch
            stocktr.created_date =  invoicedate
            try:
                stocktr.reference_number  = request.POST["saleinvoicenumber"]
                stocktr.transaction_category  = 'Sales Entry'
            except:
                stocktr.reference_number  = 'NA'
                stocktr.transaction_category  = 'Sales Entry'
            stocktr.save()

    # add entry in the transaction for money reciept
    if float(request.POST["salerecieved"]) != 0:
        transaction = Transaction()
        transaction.transactionid = lastSaleId
        transaction.amount = float(request.POST["salerecieved"])
        transaction.transactiontype = "sale"
        transaction.paymentmode = request.POST["salepaymentmode"]
        transaction.branch = request.user.userprofile.branch
        transaction.invoice_number = request.POST["saleinvoicenumber"]
        if currentuser.is_superuser:
            transaction.accounts = Branch.objects.get(
                id=request.POST.get("customer")
            ).name
        else:
            cust_obj = Customers.objects.filter(id=request.POST.get("customer")).first()
            transaction.accounts = f"{cust_obj.firstname} {cust_obj.lastname}"
        transaction.remarks = ""
        transaction.transactiondate = invoicedate
        transaction.subledger = func_get_sub_ledgers(request,'Sales')
        transaction.save()

    ####################### send whatsapp message #########
    try:
        fullname = wp_fullname
        phone = wp_phone
        saleid = lastSaleId
        pdf_byte = get_sale_pdf_bytes(request, saleid)
        whatsapp(phone, pdf_byte, "sale_invoice", fullname)
    except:
        pass
    #######################################################

    financial_statement = addaccounts.AccountStatement()

    ledger_params = {
        "invoicenumber": data.invoicenumber,
        "invoicedate": invoicedate,
        "totalamount": float(request.POST["saletotalbillingamount"]),
        "customer_or_vendor": data.customer,
        "userbranch": data.branch,
        "amountrecieved": data.amountrecieved,
        "duebalance": data.duebalance,
        "paymentmode": sale_paymentmode,
       
    }

    financial_statement.add_ledger("Sale", ledger_params)

    cashbook_params = {
        "userbranch": request.user.userprofile.branch,
        "amountrecieved": data.amountrecieved,
        "paymentmode": data.paymentmode,
        "invoicedate": invoicedate,
        "branch_wid":request.user.userprofile.branch,
         'subledger' : func_get_sub_ledgers(request,'Sales')
    }

    financial_statement.add_cashbook("Sale", cashbook_params)


    general_ledger_params = {
        "invoicenumber": data.invoicenumber,
        "invoicedate": invoicedate,
        "totalamount": float(request.POST["saletotalbillingamount"]),
        "voucherid": lastSaleId,
        "description": f"Sale to {data.customer}",
        "userbranch": data.branch,
        "amountrecieved": data.amountrecieved,
        "duebalance": data.duebalance,
        "paymentmode": sale_paymentmode,
        "customer": customer_ledger,
    }

    financial_statement.add_generalledger("Sale", general_ledger_params)

    # sale_ledger = ledgercli.LedgerBook(data.branch)

    # params = {
    #     "invoicedate": invoicedate,
    #     "mode": data.paymentmode,
    #     "taxamount": data.totaltax,
    #     "invoiceno": data.invoicenumber,
    #     "amountreceived": data.amountrecieved,
    #     "customer": data.customer,
    #     "duebalance": data.duebalance,
    # }

    # sale_ledger.post_sale(**params)

    generate_unique_id("Invoice", "INV")

    end_time = time.time()
    time_diffeence = end_time-start_time

    return redirect(reverse("saleview", kwargs={"pid": lastSaleId}))
   




# @login_required
# def addSale(request):
#     start_time = time.time()
    
#     # Helper function to safely convert to float
#     def safe_float(value, default=0.0):
#         try:
#             if value is None or value == '':
#                 return default
#             return float(value)
#         except (ValueError, TypeError):
#             return default
    
#     current_user = request.user
#     user_profile = getattr(current_user, 'userprofile', None)
#     if not user_profile:
#         return HttpResponseBadRequest("User profile not found")
        
#     role = user_profile.role
#     branch = user_profile.branch
    
#     # Get POST data once
#     post_data = request.POST
    
#     # Generate IDs once
#     last_sale_id = generate_unique_id("Sale", "SL")
    
#     # Prepare common data
#     invoice_number = post_data.get("saleinvoicenumber")
#     payment_mode = post_data.get("salepaymentmode")
#     customer_id = post_data.get("customer")
#     invoice_date = post_data.get("saleinvoicedate")
    
#     if invoice_date:
#         invoice_date = datetime.strptime(invoice_date, "%d-%m-%Y").strftime("%Y-%m-%d")
    
#     # Prepare customer data once
#     wp_fullname = ""
#     wp_phone = ""
#     customer_name = ""
    
#     # Optimize customer query
#     if role in ("Branch Admin", "Franchise Admin"):
#         customer_obj = Customers.objects.filter(id=customer_id).select_related().first()
#         if customer_obj:
#             customer_name = f"{customer_obj.firstname} {customer_obj.lastname}"
#             wp_fullname = customer_name
#             wp_phone = customer_obj.phone
#     elif current_user.is_superuser:
#         branch_obj = Branch.objects.filter(id=customer_id).first()
#         if branch_obj:
#             customer_name = branch_obj.name
#             wp_fullname = customer_name
#             wp_phone = branch_obj.phone
    
#     # Prepare bulk creates
#     sales_to_create = []
#     stock_transactions = []
    
#     # Get all products for this branch once
#     branch_products = {
#         p.name: p for p in Products.objects.filter(branch=branch).select_related()
#     }
    
#     # Process items in bulk
#     length_count = [k for k in post_data.keys() if k.startswith('saleprice')]
#     for i in range(1, len(length_count) + 10):
#         i_str = str(i)
#         product_name = post_data.get(f"salename{i_str}")
        
#         if not product_name:
#             continue
            
#         product = branch_products.get(product_name)
#         if not product:
#             continue
            
#         # Create Sale object with safe float conversions
#         sale = Sale(
#             invoicenumber=invoice_number,
#             paymentmode=payment_mode,
#             customer_gst_number=post_data.get("customergst"),
#             invoicedate=invoice_date,
#             branch=branch,
#             added_by_id=post_data.get("salesperson"),
#             customer=customer_name,
#             customerid=int(customer_id),
#             saleid=last_sale_id,
#             name=product,
#             barcodenumber=post_data.get(f"salebarcode{i_str}"),
#             price=safe_float(post_data.get(f"saleprice{i_str}")),
#             salegst=post_data.get(f"salegstsale{i_str}"),
#             totalquantity=post_data.get(f"salequantity{i_str}"),
#             totalamount=safe_float(post_data.get("saletotalamount")),
#             totalbillingamount=safe_float(post_data.get("saletotalbillingamount")),
#             totaltax=safe_float(post_data.get("saletotaltax")),
#             amountrecieved=safe_float(post_data.get("salerecieved")),
#             duebalance=safe_float(post_data.get("saleduebalance")),
#             mrp=safe_float(post_data.get(f"salemrp{i_str}")),
#             mop=safe_float(post_data.get(f"salemop{i_str}")),
#             discount=safe_float(post_data.get("salediscount")),
#             discountmethod=post_data.get("salediscountmethod", ""),
#             status="Pending",
#             purchase_price=product.price,
#             purchase_tax=product.purchasegst.percentage
#         )
#         sales_to_create.append(sale)
        
#         # Prepare stock transaction
#         stock_tr = StockTransaction(
#             product=product,
#             initial_quantity=0,
#             quantity=int(post_data[f"salequantity{i_str}"]),
#             transactiontype="Sub",
#             branch=branch,
#             reference_number=invoice_number,
#             transaction_category='Sales Entry'
#         )
#         stock_transactions.append(stock_tr)
    
#     # Bulk create sales
#     Sale.objects.bulk_create(sales_to_create)
    
#     # Update stocks in bulk
#     if current_user.is_superuser:
#         stock_updates = [
#             Stock.objects.filter(name_id=sale.name.id)
#             .update(quantity=F('quantity') - int(sale.totalquantity))
#             for sale in sales_to_create
#         ]
#     else:
#         stock_updates = [
#             BranchStock.objects.filter(branch=branch, name=sale.name)
#             .update(quantity=F('quantity') - int(sale.totalquantity))
#             for sale in sales_to_create
#         ]
    
#     # Bulk create stock transactions
#     StockTransaction.objects.bulk_create(stock_transactions)
    
#     # Create transaction if amount received
#     received_amount = safe_float(post_data.get("salerecieved"))
#     if received_amount != 0:
#         Transaction.objects.create(
#             transactionid=last_sale_id,
#             amount=received_amount,
#             transactiontype="sale",
#             paymentmode=payment_mode,
#             branch=branch,
#             invoice_number=invoice_number,
#             accounts=customer_name,
#             remarks="",
#             transactiondate=invoice_date
#         )
    
#     # Send WhatsApp message in background task
#     try:
#         if wp_phone and wp_fullname:
#             pdf_byte = get_sale_pdf_bytes(request, last_sale_id)
#             # Assuming you have a task queue system like Celery
#             send_whatsapp_message.delay(wp_phone, pdf_byte, "sale_invoice", wp_fullname)
#     except Exception as e:
#         logger.error(f"WhatsApp message failed: {str(e)}")
    
#     # Financial statements
#     financial_statement = addaccounts.AccountStatement()
    
#     ledger_params = {
#         "invoicenumber": invoice_number,
#         "invoicedate": invoice_date,
#         "totalamount": safe_float(post_data.get("saletotalbillingamount")),
#         "customer_or_vendor": customer_name,
#         "userbranch": branch,
#         "amountrecieved": received_amount,
#         "duebalance": safe_float(post_data.get("saleduebalance")),
#     }
    
#     financial_statement.add_ledger("Sale", ledger_params)
    
#     cashbook_params = {
#         "userbranch": branch,
#         "amountrecieved": received_amount,
#         "paymentmode": payment_mode,
#         "invoicedate": invoice_date,
#     }
    
#     financial_statement.add_cashbook("Sale", cashbook_params)
    
#     # Ledger updates
#     sale_ledger = ledgercli.LedgerBook(branch)
#     sale_ledger.post_sale(
#         invoicedate=invoice_date,
#         mode=payment_mode,
#         taxamount=safe_float(post_data.get("saletotaltax")),
#         invoiceno=invoice_number,
#         amountreceived=received_amount,
#         customer=customer_name,
#         duebalance=safe_float(post_data.get("saleduebalance"))
#     )
    
#     generate_unique_id("Invoice", "INV")
    
#     end_time = time.time()
#     time_difference = end_time - start_time
    
#     print("sale time optimized",time_difference)
    
#     return redirect(reverse("saleview", kwargs={"pid": last_sale_id}))
    
    
    
   





@login_required
def addSaleDue(request):

    if request.method == "POST":
        saleid = request.POST.get("saleid")
        totalbillingamount = request.POST.get("totalbillingamount")
        amountrecieved = request.POST.get("amountrecieved")
        duebalance = request.POST.get("duebalance")
        paymentmode = request.POST.get("paymentmode")

        sale_obj = Sale.objects.filter(saleid=saleid).first()
        transaction = Transaction()
        transaction.transactionid = saleid
        transaction.amount = float(amountrecieved)
        transaction.transactiontype = "sale"
        transaction.paymentmode = paymentmode
        transaction.branch = request.user.userprofile.branch
        transaction.invoice_number = sale_obj.invoicenumber
        transaction.accounts = sale_obj.customer
        transaction.remarks = ""
        transaction.transactiondate = datetime.now()
        transaction.subledger = func_get_sub_ledgers(request,'Sales')
        transaction.save()

        sales = Sale.objects.filter(saleid=saleid)
        for sale in sales:
            sale.amountrecieved = float(sale.amountrecieved) + float(amountrecieved)
            sale.duebalance = float(sale.duebalance) - float(amountrecieved)
            sale.save()

        customer_ledger = sale_obj.customer_ledger

    financial_statement = addaccounts.AccountStatement()

    ledger_params = {
        "invoicenumber": transaction.invoice_number,
        "amountrecieved": amountrecieved,
        "customer_or_vendor": transaction.accounts,
        "userbranch": request.user.userprofile.branch,
        "paymentmode": paymentmode,
    }

    financial_statement.add_ledger("SaleDue", ledger_params)

    
    cashbook_params = {
        "invoicedate": date.today(),
        "paymentmode": paymentmode,
        "amountrecieved": amountrecieved,
        "userbranch": request.user.userprofile.branch,
        "branch_wid":request.user.userprofile.branch,
         'subledger' : func_get_sub_ledgers(request,'Sales')
    }

    financial_statement.add_cashbook("SaleDue", cashbook_params)



    general_ledger_params = {
        "invoicenumber": transaction.invoice_number,
        "voucherid": saleid,
        "amountrecieved": amountrecieved,
        "description": f"Sale Due Payment from {transaction.accounts}",
        "userbranch": request.user.userprofile.branch,
        "paymentmode": paymentmode,
        "customer": customer_ledger,

    }

    financial_statement.add_generalledger("SaleDue", general_ledger_params)

    # sale_ledger = ledgercli.LedgerBook(request.user.userprofile.branch)

    # params = {
    #     "invoicedate": date.today(),
    #     "mode": paymentmode,
    #     "invoiceno": transaction.invoice_number,
    #     "amountreceived": amountrecieved,
    #     "customer": transaction.accounts,
    #     "duebalance": sale.duebalance,
    # }

    # sale_ledger.post_sale_due(**params)

    return redirect("sale")


@login_required
def StalesStatusUpdate(request):

    if request.method == "POST":
        salesid = request.POST["salesid"]
        status = request.POST["status"]

        sales = Sale.objects.filter(saleid=salesid)

        if sales:
            for sale in sales:
                sale.status = status
                sale.save()

    return redirect("sale")


# convert currency in words


def func_price_in_words(price, language):
    try:
        # Convert the numeric price to words
        words = num2words(price, lang=language, to="currency", currency="SAR")
        return words.capitalize()
    except:
        return ""


# # function which generates pdf of purchase details


@user_passes_test(
    partial(check_permission, page="Salepdf"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def generate_sale_pdf(request, id, action):

    user = request.user
    # get a list of dictionaries of given values
    data = Sale.objects.filter(saleid=id).values("name", "barcodenumber", "price", "salegst", "totalquantity")

    # Fetch the common fields from the DB
    sale = Sale.objects.filter(saleid=id).first()
    invoicenumber = sale.invoicenumber
    invoicedate = sale.invoicedate
    customer = sale.customer
    sale_type = sale.paymentmode
    totalamount = sale.totalamount
    totalbillingamount = sale.totalbillingamount
    saleid = sale.saleid
    branch = sale.branch
    amountrecieved = sale.amountrecieved
    duebalance = sale.duebalance
    discount = sale.discount
    discountmethod = sale.discountmethod
    if sale.totaltax == None or sale.totaltax == "":
        totaltax = 0
    else:
        totaltax = sale.totaltax

    product_total = 0
    data_list = []
    for item in data:
        price_ = item['price']
        salegst_ = Tax.objects.filter(Q(name=item['salegst'])&Q(branch=branch)).first().percentage
        total = (float(price_) + (float(price_) * float(salegst_) / 100)) * float(item["totalquantity"])
        prod_tax = (float(price_) * float(salegst_) / 100)
        data_dict = {
            "name": Products.objects.get(id=item["name"]).name,
            "barcodenumber": item["barcodenumber"],
            "price": item["price"],
            "salegst": item["salegst"],
            "salegst_percentage": salegst_,
            "totalquantity": item["totalquantity"],
            "total": total,
            "prod_tax":prod_tax,
        }
        product_total += total
        data_list.append(data_dict)

    company = request.user.userprofile.company
    company_name = company.company_name
    if branch.name == "WAREHOUSE":
        address_line1 = company.address_line1
        address_line2 = company.address_line2
        address_line3 = company.address_line3
        phone = ""
    else:
        address_line1 = branch.address
        phone = branch.phone
        address_line2 = ""
        address_line3 = ""

    logo = company.logo_url
    currentuser = request.user
    current_date = date.today()

    sale_obj = Sale.objects.filter(saleid=id).first()

    if sale_obj.branch.name == "WAREHOUSE":
        customerid = sale_obj.customerid
        customertype = "B2B"
        vatnumber = Branch.objects.filter(id=customerid).first().gstin
        phonenumber = Branch.objects.filter(id=customerid).first().phone
    else:
        customerid = sale_obj.customerid
        vatnumber = Customers.objects.filter(id=customerid).first().vatnumber
        customertype = Customers.objects.filter(id=customerid).first().customertype
        phonenumber = Customers.objects.filter(id=customerid).first().phone
        if customertype == "nan" or customertype == None or customertype == "":
            customertype == "B2C"

    totalworden = func_price_in_words(totalbillingamount, "en")
    totalwordar = func_price_in_words(totalbillingamount, "ar")

    total_excld_tax = totalamount - totaltax
    total_excluding_tax_new = product_total - totaltax

    qrcode_base64 = func_generate_invoice_qrcode(totalbillingamount,totaltax,invoicedate)

    context = {
        "total_excluding_tax_new":total_excluding_tax_new,
        "product_total":product_total,
        'qrcode_base64':qrcode_base64,
        "total_excld_tax": total_excld_tax,
        "phonenumber": phonenumber,
        "vatnumber": vatnumber,
        "customertype": customertype,
        "currentdate": current_date,
        "invoicenumber": invoicenumber,
        "invoicedate": invoicedate,
        "customer": customer,
        "type": sale_type,
        "totalamount": totalamount,
        "totalbillingamount": totalbillingamount,
        "saleid": saleid,
        "branch": branch,
        "data": data_list,
        "amountrecieved": amountrecieved,
        "duebalance": duebalance,
        "discount": discount,
        "discountmethod": discountmethod,
        "id": id,
        "company_name": company_name,
        "address_line1": address_line1,
        "address_line2": address_line2,
        "address_line3": address_line3,
        "logo": GLOBAL_VARIABLES["current_host"] + logo.url,
        "phone": phone,
        "totaltax": totaltax,
        "current_user": currentuser,
        "current_host": str(request.get_host()),
        "totalworden": totalworden,
        "totalwordar": totalwordar,
    }

    language = Language.objects.first()
    if language:
        language = language.language
    else:
        language = None

    # create a template object
    if language == "ar":
        template = get_template("salespdfarabic.html")
    else:
        template = get_template("salespdf.html")

    try:
        PAGESIZE = PageSize.objects.filter(active=True).first().size
    except:
        PAGESIZE = "A4"

    # render the context dictionary values
    html = template.render(context)
    options = {"quiet": "", "encoding": "UTF-8", "page-size": PAGESIZE}
    css = os.path.join(BASE_DIR, "core", "static", "css", "salespdf.css")
    # generate the pdf from html
    pdf = pdfkit.from_string(html, False, options=options, css=css)
    response = HttpResponse(content_type="application/pdf")
    if action == "download":
        response["Content-Disposition"] = (
            f'attachment; filename="Sales_Invoice_{date.today()}.pdf"'
        )
    else:
        response["Content-Disposition"] = (
            f'inline; filename="Sales_Invoice_{date.today()}.pdf"'
        )
    response.write(pdf)
    return response






@login_required
def sale_invoice_page(request, id):

    user = request.user
    # get a list of dictionaries of given values
    data = Sale.objects.filter(saleid=id).values(
    "name", "barcodenumber", "price", "salegst", "totalquantity"
        )

    # Fetch the common fields from the DB
    sale = Sale.objects.filter(saleid=id).first()
    invoicenumber = sale.invoicenumber
    invoicedate = sale.invoicedate
    customer = sale.customer
    sale_type = sale.paymentmode
    totalamount = sale.totalamount
    totalbillingamount = sale.totalbillingamount
    saleid = sale.saleid
    branch = sale.branch
    amountrecieved = sale.amountrecieved
    duebalance = sale.duebalance
    discount = sale.discount
    discountmethod = sale.discountmethod
    if sale.totaltax == None or sale.totaltax == "":
        totaltax = 0
    else:
        totaltax = sale.totaltax

    product_total = 0
    data_list = []
    for item in data:
        price_ = item['price']
        salegst_ = Tax.objects.filter(Q(name=item['salegst'])&Q(branch=branch)).first().percentage
        total = (float(price_) + (float(price_) * float(salegst_) / 100)) * float(item["totalquantity"])
        prod_tax = (float(price_) * float(salegst_) / 100)
        data_dict = {
            "name": Products.objects.get(id=item["name"]).name,
            "barcodenumber": item["barcodenumber"],
            "price": item["price"],
            "salegst": item["salegst"],
            "salegst_percentage": salegst_,
            "totalquantity": item["totalquantity"],
            "total": total,
            "prod_tax":prod_tax,
        }
        product_total += total
        data_list.append(data_dict)

    company = request.user.userprofile.company
    company_name = company.company_name
    if branch.name == "WAREHOUSE":
        address_line1 = company.address_line1
        address_line2 = company.address_line2
        address_line3 = company.address_line3
        phone = ""
    else:
        address_line1 = branch.address
        phone = branch.phone
        address_line2 = ""
        address_line3 = ""

    logo = company.logo_url
    currentuser = request.user
    current_date = date.today()

    sale_obj = Sale.objects.filter(saleid=id).first()

    if sale_obj.branch.name == "WAREHOUSE":
        customerid = sale_obj.customerid
        customertype = "B2B"
        vatnumber = Branch.objects.filter(id=customerid).first().gstin
        phonenumber = Branch.objects.filter(id=customerid).first().phone
    else:
        customerid = sale_obj.customerid
        vatnumber = Customers.objects.filter(id=customerid).first().vatnumber
        customertype = Customers.objects.filter(id=customerid).first().customertype
        phonenumber = Customers.objects.filter(id=customerid).first().phone
        if customertype == "nan" or customertype == None or customertype == "":
            customertype == "B2C"

    totalworden = func_price_in_words(totalbillingamount, "en")
    totalwordar = func_price_in_words(totalbillingamount, "ar")

    total_excld_tax = totalamount - totaltax
    total_excluding_tax_new = product_total - totaltax
 

    
    qrcode_base64 = func_generate_invoice_qrcode(totalbillingamount,totaltax,invoicedate)

    context = {
        "total_excluding_tax_new":total_excluding_tax_new,
        "product_total":product_total,
        'qrcode_base64':qrcode_base64,
        "total_excld_tax": total_excld_tax,
        "phonenumber": phonenumber,
        "vatnumber": vatnumber,
        "customertype": customertype,
        "currentdate": current_date,
        "invoicenumber": invoicenumber,
        "invoicedate": invoicedate,
        "customer": customer,
        "type": sale_type,
        "totalamount": totalamount,
        "totalbillingamount": totalbillingamount,
        "saleid": saleid,
        "branch": branch,
        "data": data_list,
        "amountrecieved": amountrecieved,
        "duebalance": duebalance,
        "discount": discount,
        "discountmethod": discountmethod,
        "id": id,
        "company_name": company_name,
        "address_line1": address_line1,
        "address_line2": address_line2,
        "address_line3": address_line3,
        "logo": GLOBAL_VARIABLES["current_host"] + logo.url,
        "phone": phone,
        "totaltax": totaltax,
        "current_user": currentuser,
        "current_host": str(request.get_host()),
        "totalworden": totalworden,
        "totalwordar": totalwordar,
    }

    language = Language.objects.first()
    if language:
        language = language.language
    else:
        language = None

    # create a template object
    if language == "ar":
        template = get_template("salespdfarabic.html")
    else:
        template = get_template("salespdf.html")

    try:
        PAGESIZE = PageSize.objects.filter(active=True).first().size
    except:
        PAGESIZE = "A4"

    # render the context dictionary values
    return render(request,"saleinvoice.html",context=context)


# end sale function

# Reports function


@login_required
def report(request):
    context = {}
    return render(request, "report.html", context)


def reports_monthly_sales(request):
    current_year = date.today().year
    current_month = date.today().month
    user = request.user

    if user.is_superuser:
        current_branch = user.userprofile.branch
        monthly_sales_obj = Sale.objects.filter(
            Q(invoicedate__year=current_year)
            & Q(invoicedate__month=current_month)
            & Q(branch=current_branch)
        ).order_by("-pk")

        saleid_set = set()
        monthly_sales_obj = [
            sale
            for sale in monthly_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        month_total_sales_amount = 0
        month_total_sales_amount_recieved = 0
        month_total_sales_amount_due = 0
        for i in monthly_sales_obj:
            month_total_sales_amount += i.totalbillingamount
            month_total_sales_amount_recieved += i.amountrecieved
            month_total_sales_amount_due += i.duebalance

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    else:
        branch = user.userprofile.branch
        monthly_sales_obj = Sale.objects.filter(
            Q(invoicedate__year=current_year)
            & Q(invoicedate__month=current_month)
            & Q(branch=branch)
        ).order_by("-pk")

        saleid_set = set()
        monthly_sales_obj = [
            sale
            for sale in monthly_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        month_total_sales_amount = 0
        month_total_sales_amount_recieved = 0
        month_total_sales_amount_due = 0
        for i in monthly_sales_obj:
            month_total_sales_amount += i.totalbillingamount
            month_total_sales_amount_recieved += i.amountrecieved
            month_total_sales_amount_due += i.duebalance
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    month_dict = {
        "1": "January",
        "2": "February",
        "3": "March",
        "4": "April",
        "5": "May",
        "6": "June",
        "7": "July",
        "8": "August",
        "9": "September",
        "10": "October",
        "11": "November",
        "12": "December",
    }

    context = {
        "monthly_sales": monthly_sales_obj,
        "month_sales_total": month_total_sales_amount,
        "month_sales_recieved": month_total_sales_amount_recieved,
        "month_sales_duebalance": month_total_sales_amount_due,
        "selected_month": {
            "month": date.today().month,
            "month_str": month_dict[str(date.today().month)],
        },
        "all_branches": all_branches,
        "selected_branch": user.userprofile.branch,
    }
    return render(request, "reportsmonthlysales.html", context)


def reports_individual_sales(request):

    current_user = request.user
    current_year = date.today().year
    current_month = date.today().month

    month_dict = {
        "1": "January",
        "2": "February",
        "3": "March",
        "4": "April",
        "5": "May",
        "6": "June",
        "7": "July",
        "8": "August",
        "9": "September",
        "10": "October",
        "11": "November",
        "12": "December",
    }

    date_range = month_dict[str(current_month)]
    if current_user.is_superuser:
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
        sales_persons_unique_list = []

        if request.method == "POST":
            user = User.objects.filter(id=int(request.POST["user"])).first()
            branch = Branch.objects.filter(id=int(request.POST["branch"])).first()
            start_date = datetime.strptime(
                request.POST["startdate"], "%d-%m-%Y"
            ).strftime("%Y-%m-%d")
            end_date = datetime.strptime(request.POST["enddate"], "%d-%m-%Y").strftime(
                "%Y-%m-%d"
            )
            startdate = datetime.strptime(start_date, "%Y-%m-%d").strftime("%B %d, %Y")
            enddate = datetime.strptime(end_date, "%Y-%m-%d").strftime("%B %d, %Y")
            if user and branch and startdate and enddate:
                date_range = f"{startdate} - {enddate}"
                sales_obj = Sale.objects.filter(
                    Q(branch=branch)
                    & Q(invoicedate__gte=start_date)
                    & Q(invoicedate__lte=end_date)
                    & Q(added_by=user)
                )
            else:
                sales_obj = Sale.objects.filter(
                    Q(invoicedate__year=current_year)
                    & Q(invoicedate__month=current_month)
                )
        else:
            sales_obj = Sale.objects.filter(
                Q(invoicedate__year=current_year) & Q(invoicedate__month=current_month)
            )

        saleid_set = set()
        sales_obj = [
            sale
            for sale in sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]
        sales_total_amount = 0
        sales_amount_recieved = 0
        sales_amount_due = 0
        for i in sales_obj:
            sales_total_amount += i.totalbillingamount
            sales_amount_recieved += i.amountrecieved
            sales_amount_due += i.duebalance
    else:
        all_branches = [current_user.userprofile.branch]
        sales_persons = Sale.objects.filter(
            branch=current_user.userprofile.branch
        ).values_list("added_by")
        sales_persons_list = [
            User.objects.filter(id=person[0]).first()
            for person in sales_persons
            if person[0] != None
        ]
        sales_persons_unique_list = list(set(sales_persons_list))

        if request.method == "POST":
            user = User.objects.filter(id=int(request.POST["user"])).first()
            start_date = datetime.strptime(
                request.POST["startdate"], "%d-%m-%Y"
            ).strftime("%Y-%m-%d")
            end_date = datetime.strptime(request.POST["enddate"], "%d-%m-%Y").strftime(
                "%Y-%m-%d"
            )
            startdate = datetime.strptime(start_date, "%Y-%m-%d").strftime("%B %d, %Y")
            enddate = datetime.strptime(end_date, "%Y-%m-%d").strftime("%B %d, %Y")
            if user and startdate and enddate:
                date_range = f"{startdate} - {enddate}"
                sales_obj = Sale.objects.filter(
                    Q(branch=current_user.userprofile.branch)
                    & Q(invoicedate__gte=start_date)
                    & Q(invoicedate__lte=end_date)
                    & Q(added_by=user)
                )
            else:
                sales_obj = Sale.objects.filter(
                    Q(branch=current_user.userprofile.branch)
                    & Q(invoicedate__year=current_year)
                    & Q(invoicedate__month=current_month)
                )

        else:
            sales_obj = Sale.objects.filter(
                Q(branch=current_user.userprofile.branch)
                & Q(invoicedate__year=current_year)
                & Q(invoicedate__month=current_month)
            )

        saleid_set = set()
        sales_obj = [
            sale
            for sale in sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        sales_total_amount = 0
        sales_amount_recieved = 0
        sales_amount_due = 0
        for i in sales_obj:
            sales_total_amount += i.totalbillingamount
            sales_amount_recieved += i.amountrecieved
            sales_amount_due += i.duebalance

    context = {
        "all_branches": all_branches,
        "sales_persons": sales_persons_unique_list,
        "sales_obj": sales_obj,
        "date_range_str": date_range,
        "sales_amount_due": sales_amount_due,
        "sales_amount_received": sales_amount_recieved,
        "sales_total_amount": sales_total_amount,
    }

    return render(request, "reportsindividualsales.html", context)


def get_salespersons_branch(request):

    received_data = QueryDict(request.body)
    branchid = received_data.get("branchid")

    salesobj = Sale.objects.filter(Q(branch=branchid))

    resp = []
    if salesobj:
        for item in salesobj:
            if item.added_by:
                dic = {}
                dic["id"] = item.added_by.id
                dic["name"] = (
                    User.objects.filter(id=int(item.added_by.id)).first().username
                )
                resp.append(dic)
    else:
        resp = "error"

    return JsonResponse({"Response": resp})


def reports_yearly_sales(request):
    current_year = date.today().year
    current_month = date.today().month
    user = request.user

    if user.is_superuser:
        current_branch = user.userprofile.branch
        yearly_sales_obj = Sale.objects.filter(
            Q(invoicedate__year=current_year) & Q(branch=current_branch)
        ).order_by("-pk")

        saleid_set = set()
        yearly_sales_obj = [
            sale
            for sale in yearly_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        year_total_sales_amount = 0
        year_total_sales_amount_recieved = 0
        year_total_sales_amount_due = 0
        for i in yearly_sales_obj:
            year_total_sales_amount += i.totalbillingamount
            year_total_sales_amount_recieved += i.amountrecieved
            year_total_sales_amount_due += i.duebalance

        all_years = list(Sale.objects.values("invoicedate__year").distinct())

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    else:
        branch = user.userprofile.branch
        yearly_sales_obj = Sale.objects.filter(
            Q(invoicedate__year=current_year) & Q(branch=branch)
        ).order_by("-pk")

        saleid_set = set()
        yearly_sales_obj = [
            sale
            for sale in yearly_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        year_total_sales_amount = 0
        year_total_sales_amount_recieved = 0
        year_total_sales_amount_due = 0
        for i in yearly_sales_obj:
            year_total_sales_amount += i.totalbillingamount
            year_total_sales_amount_recieved += i.amountrecieved
            year_total_sales_amount_due += i.duebalance

        all_years = list(
            Sale.objects.filter(branch=branch).values("invoicedate__year").distinct()
        )

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    context = {
        "year_sales": yearly_sales_obj,
        "year_sales_total": year_total_sales_amount,
        "year_sales_recieved": year_total_sales_amount_recieved,
        "year_sales_duebalance": year_total_sales_amount_due,
        "current_year": {"year": date.today().year},
        "all_years": all_years,
        "all_branches": all_branches,
        "selected_branch": user.userprofile.branch,
    }
    return render(request, "reportsyearlysales.html", context)


@user_passes_test(
    partial(check_permission, page="Purchasereport"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def reports_daily_purchase(request):
    current_year = date.today().year
    current_date = date.today()
    user = request.user

    if user.is_superuser:

        daily_purchase_obj = Purchase.objects.filter(invoicedate=current_date).order_by(
            "-pk"
        )

        purchaseid_set = set()
        daily_purchase_obj = [
            purchase
            for purchase in daily_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        day_total_purchase_amount = 0
        day_total_purchase_amount_paid = 0
        day_total_purchase_amount_due = 0
        for i in daily_purchase_obj:
            day_total_purchase_amount += i.totalbillingamount
            day_total_purchase_amount_paid += i.amountrecieved
            day_total_purchase_amount_due += i.duebalance

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    else:
        branch = user.userprofile.branch
        daily_purchase_obj = BranchPurchase.objects.filter(
            Q(invoicedate=current_date) & Q(branch=branch)
        ).order_by("-pk")

        purchaseid_set = set()
        daily_purchase_obj = [
            purchase
            for purchase in daily_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        day_total_purchase_amount = 0
        day_total_purchase_amount_paid = 0
        day_total_purchase_amount_due = 0
        for i in daily_purchase_obj:
            day_total_purchase_amount += i.totalbillingamount
            day_total_purchase_amount_paid += i.amountrecieved
            day_total_purchase_amount_due += i.duebalance

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    context = {
        "daily_purchase": daily_purchase_obj,
        "day_purchase_total": day_total_purchase_amount,
        "day_purchase_paid": day_total_purchase_amount_paid,
        "day_purchase_duebalance": day_total_purchase_amount_due,
        "selected_date": {"date": date.today()},
        "all_branches": all_branches,
        "selected_branch": user.userprofile.branch,
    }
    return render(request, "reportsdailypurchase.html", context)


@user_passes_test(
    partial(check_permission, page="Salesreport"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def reports_daily_sales(request):
    current_year = date.today().year
    current_date = date.today()
    user = request.user

    if user.is_superuser:

        daily_sales_obj = Sale.objects.filter(invoicedate=current_date).order_by("-pk")

        saleid_set = set()
        daily_sales_obj = [
            sale
            for sale in daily_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        day_total_sales_amount = 0
        day_total_sales_amount_recieved = 0
        day_total_sales_amount_due = 0
        for i in daily_sales_obj:
            day_total_sales_amount += i.totalbillingamount
            day_total_sales_amount_recieved += i.amountrecieved
            day_total_sales_amount_due += i.duebalance

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    else:
        branch = user.userprofile.branch
        daily_sales_obj = Sale.objects.filter(
            Q(invoicedate=current_date) & Q(branch=branch)
        ).order_by("-pk")

        saleid_set = set()
        daily_sales_obj = [
            sale
            for sale in daily_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        day_total_sales_amount = 0
        day_total_sales_amount_recieved = 0
        day_total_sales_amount_due = 0
        for i in daily_sales_obj:
            day_total_sales_amount += i.totalbillingamount
            day_total_sales_amount_recieved += i.amountrecieved
            day_total_sales_amount_due += i.duebalance

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    context = {
        "daily_sales": daily_sales_obj,
        "day_sales_total": day_total_sales_amount,
        "day_sales_recieved": day_total_sales_amount_recieved,
        "day_sales_duebalance": day_total_sales_amount_due,
        "selected_date": {"date": date.today()},
        "all_branches": all_branches,
        "selected_branch": user.userprofile.branch,
    }
    return render(request, "reportsdailysales.html", context)


@login_required
def reports_monthly_purchase(request):
    current_year = date.today().year
    current_month = date.today().month
    user = request.user

    if user.is_superuser:

        monthly_purchase_obj = Purchase.objects.filter(
            Q(invoicedate__year=current_year) & Q(invoicedate__month=current_month)
        ).order_by("-pk")

        purchaseid_set = set()
        monthly_purchase_obj = [
            purchase
            for purchase in monthly_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        month_total_purchase_amount = 0
        month_total_purchase_amount_paid = 0
        month_total_purchase_amount_due = 0
        for i in monthly_purchase_obj:
            month_total_purchase_amount += i.totalbillingamount
            month_total_purchase_amount_paid += i.amountrecieved
            month_total_purchase_amount_due += i.duebalance

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    else:
        branch = user.userprofile.branch
        monthly_purchase_obj = BranchPurchase.objects.filter(
            Q(invoicedate__year=current_year)
            & Q(invoicedate__month=current_month)
            & Q(branch=branch)
        ).order_by("-pk")

        purchaseid_set = set()
        monthly_purchase_obj = [
            purchase
            for purchase in monthly_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        month_total_purchase_amount = 0
        month_total_purchase_amount_paid = 0
        month_total_purchase_amount_due = 0
        for i in monthly_purchase_obj:
            month_total_purchase_amount += i.totalbillingamount
            month_total_purchase_amount_paid += i.amountrecieved
            month_total_purchase_amount_due += i.duebalance

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    month_dict = {
        "1": "January",
        "2": "February",
        "3": "March",
        "4": "April",
        "5": "May",
        "6": "June",
        "7": "July",
        "8": "August",
        "9": "September",
        "10": "October",
        "11": "November",
        "12": "December",
    }

    context = {
        "monthly_purchase": monthly_purchase_obj,
        "month_purchase_total": month_total_purchase_amount,
        "month_purchase_paid": month_total_purchase_amount_paid,
        "month_purchase_duebalance": month_total_purchase_amount_due,
        "selected_month": {
            "month": date.today().month,
            "month_str": month_dict[str(date.today().month)],
        },
        "all_branches": all_branches,
        "selected_branch": user.userprofile.branch,
    }
    return render(request, "reportsmonthlypurchase.html", context)


@login_required
def reports_yearly_purchase(request):
    current_year = date.today().year
    current_month = date.today().month
    user = request.user

    if user.is_superuser:

        yearly_purchase_obj = Purchase.objects.filter(
            invoicedate__year=current_year
        ).order_by("-pk")

        purchaseid_set = set()
        yearly_purchase_obj = [
            purchase
            for purchase in yearly_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        year_total_purchase_amount = 0
        year_total_purchase_amount_paid = 0
        year_total_purchase_amount_due = 0

        for i in yearly_purchase_obj:
            year_total_purchase_amount_paid += i.amountrecieved
            year_total_purchase_amount += i.totalbillingamount
            year_total_purchase_amount_due += i.duebalance

        all_years = list(Purchase.objects.values("invoicedate__year").distinct())

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    else:
        branch = user.userprofile.branch
        yearly_purchase_obj = BranchPurchase.objects.filter(
            Q(invoicedate__year=current_year) & Q(branch=branch)
        ).order_by("-pk")

        purchaseid_set = set()
        yearly_purchase_obj = [
            purchase
            for purchase in yearly_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        year_total_purchase_amount = 0
        year_total_purchase_amount_paid = 0
        year_total_purchase_amount_due = 0

        for i in yearly_purchase_obj:
            year_total_purchase_amount_paid += i.amountrecieved
            year_total_purchase_amount += i.totalbillingamount
            year_total_purchase_amount_due += i.duebalance

        all_years = list(
            BranchPurchase.objects.filter(
                Q(invoicedate__year=current_year) & Q(branch=branch)
            )
            .values("invoicedate__year")
            .distinct()
        )

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    context = {
        "year_purchase": yearly_purchase_obj,
        "year_purchase_total": year_total_purchase_amount,
        "year_purchase_paid": year_total_purchase_amount_paid,
        "year_purchase_duebalance": year_total_purchase_amount_due,
        "current_year": {"year": date.today().year},
        "all_years": all_years,
        "all_branches": all_branches,
        "selected_branch": user.userprofile.branch,
    }
    return render(request, "reportsyearlypurchase.html", context)


# end of reports function


# Accounts function start


@user_passes_test(
    partial(check_permission, page="Moneyreciept"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def accounts(request):
    currentuser = request.user
    if currentuser.is_superuser:
        transaction = Transaction.objects.all().order_by("-pk")
    else:
        transaction = Transaction.objects.filter(
            branch=currentuser.userprofile.branch
        ).order_by("-pk")
    invoicenumber_list = set()
    accounts_list = set()
    transaction_list = []
    purchase_due_balance = 0
    sale_due_balance = 0
    service_due_balance = 0
    for tr in transaction:
        if tr.transactiontype == "purchase":

            transactionid = tr.transactionid
            transaction_dict = {}
            if currentuser.is_superuser:

                purchase_p = Purchase.objects.filter(purchaseid=transactionid).first()
                if not purchase_p:
                    pass
                else:
                    ###########
                    if purchase_p.duebalance:
                        purchase_due_balance += purchase_p.duebalance
                    ###########

                    invoicenumber_list.add(purchase_p.invoicenumber)
                    accounts_list.add(purchase_p.supplier.name)
                    transaction_dict["invoicenumber"] = purchase_p.invoicenumber
                    transaction_dict["purchaseid"] = purchase_p.purchaseid

                    
                    transaction_dict["paymentmode"] = tr.paymentmode
                    transaction_dict["transaction"] = tr
                    transaction_dict["branch"] = tr.branch
                    transaction_dict['date'] = purchase_p.invoicedate

                   

                    ###############
                    # trans_obj =Transaction.objects.filter(transactionid=purchase_p.purchaseid)
                    # is_first = False
                    # if tr==trans_obj.first():
                    #     is_first=True
                    # else:
                    #     is_first = False

                    # if is_first:
                    #     transaction_dict['createddate'] = purchase_p.invoicedate
                    # else:
                    #     transaction_dict['createddate'] = tr.createddate

                    transaction_date = tr.transactiondate
                    if transaction_date:
                        transaction_dict['createddate'] = transaction_date
                    else:
                        transaction_dict['createddate'] = tr.createddate
                    ###############

                    transaction_list.append(transaction_dict)
                purchase_b = BranchPurchase.objects.filter(
                    purchaseid=transactionid
                ).first()
                if not purchase_b:
                    pass
                else:
                    ###########
                    if purchase_b.duebalance:
                        purchase_due_balance += purchase_b.duebalance
                    ###########
                    invoicenumber_list.add(purchase_b.invoicenumber)
                    if purchase_b.supplier == None:
                        accounts_list.add(purchase_b.externalsupplier.name)
                    else:
                        accounts_list.add(purchase_b.supplier.name)
                    transaction_dict["invoicenumber"] = purchase_b.invoicenumber
                    if purchase_b.supplier == None:
                        transaction_dict["accounts"] = purchase_b.externalsupplier.name
                    else:
                        transaction_dict["accounts"] = purchase_b.supplier.name
                    transaction_dict["paymentmode"] = tr.paymentmode
                    transaction_dict["transaction"] = tr
                    transaction_dict["branch"] = tr.branch
                    transaction_dict['date'] = purchase_b.invoicedate
               
                        
                    ###############
                    # trans_obj =Transaction.objects.filter(transactionid=purchase_b.purchaseid)
                    # is_first = False
                    # if tr==trans_obj.first():
                    #     is_first=True
                    # else:
                    #     is_first = False
                   
                    # if is_first:
                    #     transaction_dict['createddate'] = purchase_b.invoicedate
                    # else:
                    #     transaction_dict['createddate'] = tr.createddate
                    transaction_date = tr.transactiondate
                    if transaction_date:
                        transaction_dict['createddate'] = transaction_date
                    else:
                        transaction_dict['createddate'] = tr.createddate
                    ###############

                    transaction_list.append(transaction_dict)

            else:
                purchase = BranchPurchase.objects.filter(
                    purchaseid=transactionid
                ).first()
                if not purchase:
                    pass
                else:

                    ###########
                    if purchase.duebalance:
                        purchase_due_balance += purchase.duebalance
                    ###########

                    invoicenumber_list.add(purchase.invoicenumber)
                    if purchase.supplier == None:
                        accounts_list.add(purchase.externalsupplier.name)
                    else:
                        accounts_list.add(purchase.supplier.name)

                    transaction_dict["invoicenumber"] = purchase.invoicenumber
                    if purchase.supplier == None:
                        transaction_dict["accounts"] = purchase.externalsupplier.name
                    else:
                        transaction_dict["accounts"] = purchase.supplier.name

                    
                    transaction_dict["paymentmode"] = tr.paymentmode
                    transaction_dict["transaction"] = tr
                    transaction_dict["branch"] = tr.branch
                    transaction_dict['date'] = purchase.invoicedate
         

                    ###############
                    # trans_obj =Transaction.objects.filter(transactionid=purchase.purchaseid)
                    # is_first = False
                    # if tr==trans_obj.first():
                    #     is_first=True
                    # else:
                    #     is_first = False
                   
                    # if is_first:
                    #     transaction_dict['createddate'] = purchase.invoicedate
                    # else:
                    #     transaction_dict['createddate'] = tr.createddate
                    transaction_date = tr.transactiondate
                    if transaction_date:
                        transaction_dict['createddate'] = transaction_date
                    else:
                        transaction_dict['createddate'] = tr.createddate
                    ###############
                    

                    transaction_list.append(transaction_dict)

        if tr.transactiontype == "purchasereturn":

            transactionid = tr.transactionid
            transaction_dict = {}
            # if currentuser.is_superuser:

            purchase_p = PurchaseReturn.objects.filter(
                purchasereturnid=transactionid
            ).first()
            if not purchase_p:
                pass
            else:
                invoicenumber_list.add(purchase_p.invoicenumber)
                if purchase_p.supplier == None:
                    accounts_list.add(purchase_p.externalsupplier.name)
                else:
                    accounts_list.add(purchase_p.supplier.name)
                transaction_dict["invoicenumber"] = purchase_p.invoicenumber
                if purchase_p.supplier == None:
                    transaction_dict["accounts"] = purchase_p.externalsupplier.name
                else:
                    transaction_dict["accounts"] = purchase_p.supplier.name
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict['date'] = purchase_p.createddate
       


                ###############
                # trans_obj =Transaction.objects.filter(transactionid=purchase_p.purchasereturnid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = purchase_p.createddate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############


                transaction_list.append(transaction_dict)

        if tr.transactiontype == "sale":

            transactionid = tr.transactionid
            transaction_dict = {}
            sale = Sale.objects.filter(saleid=transactionid).first()
            if not sale:
                pass
            else:
                ###########
                if sale.duebalance:
                    sale_due_balance += sale.duebalance
                ###########
                invoicenumber_list.add(sale.invoicenumber)
                accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = sale.invoicenumber
                transaction_dict["accounts"] = sale.customer
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict['date'] = sale.invoicedate
          

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=sale.saleid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = sale.invoicedate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############
            

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "salereturn":
            transactionid = tr.transactionid
            transaction_dict = {}
            sale = SaleReturn.objects.filter(salereturnid=transactionid).first()
            if not sale:
                pass
            else:
                invoicenumber_list.add(sale.invoicenumber)
                accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = sale.invoicenumber
                transaction_dict["accounts"] = sale.customer
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict['date'] = sale.createddate
       


                ###############
                # trans_obj =Transaction.objects.filter(transactionid=sale.salereturnid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = sale.createddate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############


                transaction_list.append(transaction_dict)

        if tr.transactiontype == "expense":

            transactionid = tr.transactionid
            transaction_dict = {}
            expense = Expenses.objects.filter(expenseid=transactionid).first()
            if not expense:
                pass
            else:
                invoicenumber_list.add(expense.billnumber)
                # accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = expense.billnumber
                transaction_dict["accounts"] = ""
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = expense.remarks
                transaction_dict["branch"] = tr.branch
                transaction_dict['date'] = expense.expensedate
         

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=expense.expenseid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = expense.expensedate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "payment":

            transactionid = tr.transactionid
            transaction_dict = {}
            payment = Payments.objects.filter(paymentid=transactionid).first()
            if not payment:
                pass
            else:
                invoicenumber_list.add(payment.referenceno)
                # accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = payment.referenceno
                transaction_dict["accounts"] = ""
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = payment.description
                transaction_dict["branch"] = tr.branch
                transaction_dict['date'] = payment.paymentdate
              

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=payment.paymentid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = payment.paymentdate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############
             
                transaction_list.append(transaction_dict)

        if tr.transactiontype == "receipt":

            transactionid = tr.transactionid
            transaction_dict = {}
            receipt = Receipts.objects.filter(receiptid=transactionid).first()
            if not receipt:
                pass
            else:
                invoicenumber_list.add(receipt.referenceno)
                # accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = receipt.referenceno
                transaction_dict["accounts"] = ""
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = receipt.description
                transaction_dict["branch"] = tr.branch
                transaction_dict['date'] = receipt.receiptdate
        

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=receipt.receiptid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = receipt.receiptdate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        # if tr.transactiontype == "journal":

        #     transactionid = tr.transactionid
        #     transaction_dict = {}
        #     journal = Journals.objects.filter(journalid=transactionid).first()
        #     if not journal:
        #         pass
        #     else:
                
        #         invoicenumber_list.add(journal.referenceno)
        #         transaction_dict["invoicenumber"] = journal.referenceno
        #         transaction_dict["accounts"] = ""
        #         transaction_dict["paymentmode"] = tr.paymentmode
        #         transaction_dict["transaction"] = tr
        #         transaction_dict["remarks"] = journal.description
        #         transaction_dict["branch"] = tr.branch
        #         transaction_dict['date'] = journal.journaldate
            
        #         transaction_date = tr.transactiondate
        #         if transaction_date:
        #             transaction_dict['createddate'] = transaction_date
        #         else:
        #             transaction_dict['createddate'] = tr.createddate

        #         transaction_list.append(transaction_dict)

        if tr.transactiontype == "service":

            transactionid = tr.transactionid
            transaction_dict = {}
            # expense =Expenses.objects.filter(expenseid = transactionid).first()
            service = Service.objects.filter(servicerefnumber=transactionid).first()
            if not service:
                pass
            else:

                ###########
                if service.duebalance:
                    service_due_balance += service.duebalance
                ###########

                invoicenumber_list.add(service.servicerefnumber)
                accounts_list.add(f"{service.firstname} {service.lastname}")
                transaction_dict["invoicenumber"] = service.servicerefnumber
                transaction_dict["accounts"] = f"{service.firstname} {service.lastname}"
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict['date'] = service.memodate
               

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=service.servicerefnumber)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = service.memodate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

    paymentmodes = PaymentMode.objects.all()


    
    transaction_list = sorted(
        transaction_list,
        key=lambda x: x['createddate'],
        reverse=True
    )


    context = {
        "transaction": transaction_list,
        "invoicenumber_list": invoicenumber_list,
        "accounts_list": accounts_list,
        "paymentmodes": paymentmodes,
        "purchase_due_balance": purchase_due_balance,
        "sale_due_balance": sale_due_balance,
        "service_due_balance": service_due_balance,
    }

    return render(request, "moneyreciept.html", context)






@user_passes_test(
    partial(check_permission, page="Moneyreciept"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def daybook(request):
    currentuser = request.user
    if currentuser.is_superuser:
        transaction = Transaction.objects.all().order_by("-pk")
    else:
        transaction = Transaction.objects.filter(
            branch=currentuser.userprofile.branch
        ).order_by("-pk")
    invoicenumber_list = set()
    accounts_list = set()
    transaction_list = []
    purchase_due_balance = 0
    sale_due_balance = 0
    service_due_balance = 0

    search = 'No'
    total_debit = 0
    total_credit = 0
    


    for tr in transaction:
        if tr.transactiontype == "purchase":

            transactionid = tr.transactionid
            transaction_dict = {}
            if currentuser.is_superuser:

                purchase_p = Purchase.objects.filter(purchaseid=transactionid).first()
                if not purchase_p:
                    pass
                else:
                    ###########
                    if purchase_p.duebalance:
                        purchase_due_balance += purchase_p.duebalance
                    ###########

                    invoicenumber_list.add(purchase_p.invoicenumber)
                    accounts_list.add(purchase_p.supplier.name)
                    transaction_dict["invoicenumber"] = purchase_p.invoicenumber
                    transaction_dict["accounts"] = purchase_p.supplier.name
                    transaction_dict["paymentmode"] = tr.paymentmode
                    transaction_dict["transaction"] = tr
                    transaction_dict["branch"] = tr.branch
                    transaction_dict["title"] = "Purchase"
                    transaction_dict["amounttype"] = "Credit"
                    total_credit += tr.amount
                    transaction_dict['date'] = purchase_p.invoicedate
                  

                    ###############
                    # trans_obj =Transaction.objects.filter(transactionid=purchase_p.purchaseid)
                    # is_first = False
                    # if len(trans_obj) == 1:
                    #     is_first = False
                    # elif tr==trans_obj.first():
                    #     is_first=True
                    # else:
                    #     is_first = False

                    # if is_first:
                    #     transaction_dict['createddate'] = purchase_p.invoicedate
                    # else:
                    #     transaction_dict['createddate'] = tr.createddate
                    transaction_date = tr.transactiondate
                    if transaction_date:
                        transaction_dict['createddate'] = transaction_date
                    else:
                        transaction_dict['createddate'] = tr.createddate

                    
                    ###############

                    transaction_list.append(transaction_dict)
                purchase_b = BranchPurchase.objects.filter(
                    purchaseid=transactionid
                ).first()
                if not purchase_b:
                    pass
                else:
                    ###########
                    if purchase_b.duebalance:
                        purchase_due_balance += purchase_b.duebalance
                    ###########
                    invoicenumber_list.add(purchase_b.invoicenumber)
                    if purchase_b.supplier == None:
                        accounts_list.add(purchase_b.externalsupplier.name)
                    else:
                        accounts_list.add(purchase_b.supplier.name)
                    transaction_dict["invoicenumber"] = purchase_b.invoicenumber
                    if purchase_b.supplier == None:
                        transaction_dict["accounts"] = purchase_b.externalsupplier.name
                    else:
                        transaction_dict["accounts"] = purchase_b.supplier.name
                    transaction_dict["paymentmode"] = tr.paymentmode
                    transaction_dict["transaction"] = tr
                    transaction_dict["branch"] = tr.branch
                    transaction_dict["title"] = "Purchase"
                    transaction_dict["amounttype"] = "Credit"
                    total_credit += tr.amount
                    transaction_dict['date'] = purchase_b.invoicedate
                 

                    ###############
                    # trans_obj =Transaction.objects.filter(transactionid=purchase_b.purchaseid)
                    # is_first = False
                    # if len(trans_obj) == 1:
                    #     is_first = False
                    # elif tr==trans_obj.first():
                    #     is_first=True
                    # else:
                    #     is_first = False
                   
                    # if is_first:
                    #     transaction_dict['createddate'] = purchase_b.invoicedate
                    # else:
                    #     transaction_dict['createddate'] = tr.createddate

                    transaction_date = tr.transactiondate
                    if transaction_date:
                        transaction_dict['createddate'] = transaction_date
                    else:
                        transaction_dict['createddate'] = tr.createddate
                    ###############


                    transaction_list.append(transaction_dict)

            else:
                purchase = BranchPurchase.objects.filter(
                    purchaseid=transactionid
                ).first()
                if not purchase:
                    pass
                else:

                    ###########
                    if purchase.duebalance:
                        purchase_due_balance += purchase.duebalance
                    ###########

                    invoicenumber_list.add(purchase.invoicenumber)
                    if purchase.supplier == None:
                        accounts_list.add(purchase.externalsupplier.name)
                    else:
                        accounts_list.add(purchase.supplier.name)
                    transaction_dict["invoicenumber"] = purchase.invoicenumber
                    if purchase.supplier == None:
                        transaction_dict["accounts"] = purchase.externalsupplier.name
                    else:
                        transaction_dict["accounts"] = purchase.supplier.name
                    transaction_dict["paymentmode"] = tr.paymentmode
                    transaction_dict["transaction"] = tr
                    transaction_dict["branch"] = tr.branch
                    transaction_dict["title"] = "Purchase"
                    transaction_dict["amounttype"] = "Credit"
                    total_credit += tr.amount
                    transaction_dict['date'] = purchase.invoicedate
                  

                    ###############
                    # trans_obj =Transaction.objects.filter(transactionid=purchase.purchaseid)
                    # print("daybook",trans_obj)
                    # is_first = False
                    # if len(trans_obj) == 1:
                    #     is_first = False
                    # elif tr==trans_obj.first():
                    #     is_first=True
                    # else:
                    #     is_first = False
                   
                    # if is_first:
                    #     transaction_dict['createddate'] = purchase.invoicedate
                    # else:
                    #     transaction_dict['createddate'] = tr.createddate
                    transaction_date = tr.transactiondate
                    if transaction_date:
                        transaction_dict['createddate'] = transaction_date
                    else:
                        transaction_dict['createddate'] = tr.createddate
                    ###############

                    transaction_list.append(transaction_dict)

        if tr.transactiontype == "purchasereturn":

            transactionid = tr.transactionid
            transaction_dict = {}
            # if currentuser.is_superuser:

            purchase_p = PurchaseReturn.objects.filter(
                purchasereturnid=transactionid
            ).first()
            if not purchase_p:
                pass
            else:
                invoicenumber_list.add(purchase_p.invoicenumber)
                if purchase_p.supplier == None:
                    accounts_list.add(purchase_p.externalsupplier.name)
                else:
                    accounts_list.add(purchase_p.supplier.name)
                transaction_dict["invoicenumber"] = purchase_p.invoicenumber
                if purchase_p.supplier == None:
                    transaction_dict["accounts"] = purchase_p.externalsupplier.name
                else:
                    transaction_dict["accounts"] = purchase_p.supplier.name
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Purchase Return"
                transaction_dict["amounttype"] = "Debit"
                total_debit += tr.amount
                transaction_dict['date'] = purchase_p.createddate
               

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=purchase_p.purchasereturnid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = purchase_p.createddate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "sale":

            transactionid = tr.transactionid
            transaction_dict = {}
            sale = Sale.objects.filter(saleid=transactionid).first()
            if not sale:
                pass
            else:
                ###########
                if sale.duebalance:
                    sale_due_balance += sale.duebalance
                ###########
                invoicenumber_list.add(sale.invoicenumber)
                accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = sale.invoicenumber
                transaction_dict["accounts"] = sale.customer
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Sale"
                transaction_dict["amounttype"] = "Debit"
                total_debit += tr.amount
                transaction_dict['date'] = sale.invoicedate

       

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=sale.saleid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = sale.invoicedate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############


                transaction_list.append(transaction_dict)

        if tr.transactiontype == "salereturn":
            transactionid = tr.transactionid
            transaction_dict = {}
            sale = SaleReturn.objects.filter(salereturnid=transactionid).first()
            if not sale:
                pass
            else:
                invoicenumber_list.add(sale.invoicenumber)
                accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = sale.invoicenumber
                transaction_dict["accounts"] = sale.customer
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Sale Return"
                transaction_dict["amounttype"] = "Credit"
                total_credit += tr.amount
                transaction_dict['date'] = sale.createddate

             

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=sale.salereturnid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = sale.createddate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "expense":

            transactionid = tr.transactionid
            transaction_dict = {}
            expense = Expenses.objects.filter(expenseid=transactionid).first()
            if not expense:
                pass
            else:
                invoicenumber_list.add(expense.billnumber)
                # accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = expense.billnumber
                transaction_dict["accounts"] = ""
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = expense.remarks
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Expense"
                transaction_dict["amounttype"] = "Credit"
                total_credit += tr.amount
                transaction_dict['date'] = expense.expensedate

          

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=expense.expenseid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = expense.expensedate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "payment":

            transactionid = tr.transactionid
            transaction_dict = {}
            payment = Payments.objects.filter(paymentid=transactionid).first()
            if not payment:
                pass
            else:
                invoicenumber_list.add(payment.referenceno)
                # accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = payment.referenceno
                transaction_dict["accounts"] = payment.debitaccount
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = payment.description
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Payment"
                transaction_dict["amounttype"] = "Credit"
                total_credit += tr.amount
                transaction_dict['date'] = payment.paymentdate


                ###############
                # trans_obj =Transaction.objects.filter(transactionid=payment.paymentid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = payment.paymentdate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "receipt":

            transactionid = tr.transactionid
            transaction_dict = {}
            receipt = Receipts.objects.filter(receiptid=transactionid).first()
            if not receipt:
                pass
            else:
                invoicenumber_list.add(receipt.referenceno)
                # accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = receipt.referenceno
                transaction_dict["accounts"] =receipt.creditaccount
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = receipt.description
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Receipt"
                transaction_dict["amounttype"] = "Debit"
                total_debit += tr.amount
                transaction_dict['date'] = receipt.receiptdate

             

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=receipt.receiptid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = receipt.receiptdate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "journal":

            transactionid = tr.transactionid
            transaction_dict = {}
            journal = Journals.objects.filter(journalid=transactionid).first()

            if not journal:
                pass
            else:
                amount_type = ''
                accounts = ''
                # cash_list = ['CASH ACCOUNT']

                if journal.creditaccount == tr.accounts:
                    amount_type = 'Credit'
                elif journal.debitaccount == tr.accounts:
                    amount_type = 'Debit'

                invoicenumber_list.add(journal.referenceno)
                transaction_dict["invoicenumber"] = journal.referenceno
                transaction_dict["accounts"] = tr.accounts
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = journal.description
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Journal"
                transaction_dict["amounttype"] = amount_type
                transaction_dict['date'] = journal.journaldate

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=journal.journalid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = journal.journaldate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "service":

            transactionid = tr.transactionid
            transaction_dict = {}
            # expense =Expenses.objects.filter(expenseid = transactionid).first()
            service = Service.objects.filter(servicerefnumber=transactionid).first()
            if not service:
                pass
            else:

                ###########
                if service.duebalance:
                    service_due_balance += service.duebalance
                ###########

                invoicenumber_list.add(service.servicerefnumber)
                accounts_list.add(f"{service.firstname} {service.lastname}")
                transaction_dict["invoicenumber"] = service.servicerefnumber
                transaction_dict["accounts"] = f"{service.firstname} {service.lastname}"
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Service"
                transaction_dict["amounttype"] = "Debit"
                total_debit += tr.amount
                transaction_dict['date'] = service.memodate

           

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=service.servicerefnumber)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = service.memodate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)


    startdate = date.today()
    enddate = date.today()


    if startdate and enddate:
        transaction_list  = sorted(
        [
            transaction for transaction in transaction_list 
            if startdate <= transaction['createddate'] <= enddate
        ],
        key=lambda x: x['createddate'],
        reverse=False
        )
    else:
        transaction_list = sorted(
        transaction_list,
        key=lambda x: x['createddate'],
        reverse=False
    )

    # transaction_list = sorted(
    #     transaction_list,
    #     key=lambda x: x['createddate'],
    #     reverse=True
    # )
    
    total_debit = 0
    total_credit = 0

    for item in transaction_list:
        if item["amounttype"] == "Debit":
            total_debit += item["transaction"].amount
        elif item["amounttype"] == "Credit":
            total_credit += item["transaction"].amount

    total_balance = total_debit - total_credit

    paymentmodes = PaymentMode.objects.all()

    context = {
        'search':search,
        'totaldebit':total_debit,
        'totalcredit':total_credit,
        'balance':total_balance,
        "transaction": transaction_list,
        "invoicenumber_list": invoicenumber_list,
        "accounts_list": accounts_list,
        "paymentmodes": paymentmodes,
        "purchase_due_balance": purchase_due_balance,
        "sale_due_balance": sale_due_balance,
        "service_due_balance": service_due_balance,
    }

    return render(request, "daybook.html", context)








@login_required
def search_daybook(request):

    customer_supplier_selected = request.POST.get("supplier_customer_money")
    invoice_number_selected = request.POST.get("invoice_number_money")
    payment_mode = request.POST.get("payment_mode")
    startdate = request.POST.get("startdate", None)
    enddate = request.POST.get("enddate", None)

    currentuser = request.user
    transaction = []

    filters = Q()

    if customer_supplier_selected:
        filters &= Q(accounts=customer_supplier_selected)

    if payment_mode:
        filters &= Q(paymentmode=payment_mode)

    if invoice_number_selected:
        filters &= Q(invoice_number=invoice_number_selected)

    # if startdate:
    #     start_date = datetime.strptime(startdate, "%d-%m-%Y").date()
    #     filters &= Q(createddate__gte=start_date)

    # if enddate:
    #     end_date = datetime.strptime(enddate, "%d-%m-%Y").date()
    #     filters &= Q(createddate__lte=end_date)

    if not currentuser.is_superuser:
        filters &= Q(branch=currentuser.userprofile.branch)

    if filters:
        transaction = Transaction.objects.filter(filters).order_by("-pk")

    invoicenumber_list = set()
    accounts_list = set()

    if currentuser.is_superuser:
        transactions_all = Transaction.objects.all().order_by("-pk")
    else:
        transactions_all = Transaction.objects.filter(
            branch=currentuser.userprofile.branch
        ).order_by("-pk")
    for trans in transactions_all:
        accounts_list.add(trans.accounts)
        invoicenumber_list.add(trans.invoice_number)

    transaction_list = []
    purchase_due_balance = 0
    sale_due_balance = 0
    service_due_balance = 0

    search='Yes'
    total_debit = 0
    total_credit = 0
    
    for tr in transaction:
        if tr.transactiontype == "purchase":

            transactionid = tr.transactionid
            transaction_dict = {}
            if currentuser.is_superuser:

                purchase_p = Purchase.objects.filter(purchaseid=transactionid).first()
                if not purchase_p:
                    pass
                else:
                    ###########
                    if purchase_p.duebalance:
                        purchase_due_balance += purchase_p.duebalance
                    ###########

                    invoicenumber_list.add(purchase_p.invoicenumber)
                    accounts_list.add(purchase_p.supplier.name)
                    transaction_dict["invoicenumber"] = purchase_p.invoicenumber
                    transaction_dict["accounts"] = purchase_p.supplier.name
                    transaction_dict["paymentmode"] = tr.paymentmode
                    transaction_dict["transaction"] = tr
                    transaction_dict["branch"] = tr.branch
                    transaction_dict["title"] = "Purchase"
                    transaction_dict["amounttype"] = "Credit"
                  
                    transaction_dict['date'] = purchase_p.invoicedate
               

                    ###############
                    # trans_obj =Transaction.objects.filter(transactionid=purchase_p.purchaseid)
                    # is_first = False
                    # if tr==trans_obj.first():
                    #     is_first=True
                    # else:
                    #     is_first = False

                    # if is_first:
                    #     transaction_dict['createddate'] = purchase_p.invoicedate
                    # else:
                    #     transaction_dict['createddate'] = tr.createddate
                    transaction_date = tr.transactiondate
                    if transaction_date:
                        transaction_dict['createddate'] = transaction_date
                    else:
                        transaction_dict['createddate'] = tr.createddate
                    ###############

                    transaction_list.append(transaction_dict)
                purchase_b = BranchPurchase.objects.filter(
                    purchaseid=transactionid
                ).first()
                if not purchase_b:
                    pass
                else:
                    ###########
                    if purchase_b.duebalance:
                        purchase_due_balance += purchase_b.duebalance
                    ###########
                    invoicenumber_list.add(purchase_b.invoicenumber)
                    if purchase_b.supplier == None:
                        accounts_list.add(purchase_b.externalsupplier.name)
                    else:
                        accounts_list.add(purchase_b.supplier.name)
                    transaction_dict["invoicenumber"] = purchase_b.invoicenumber
                    if purchase_b.supplier == None:
                        transaction_dict["accounts"] = purchase_b.externalsupplier.name
                    else:
                        transaction_dict["accounts"] = purchase_b.supplier.name
                    transaction_dict["paymentmode"] = tr.paymentmode
                    transaction_dict["transaction"] = tr
                    transaction_dict["branch"] = tr.branch
                    transaction_dict["title"] = "Purchase"
                    transaction_dict["amounttype"] = "Credit"
                  
                    transaction_dict['date'] = purchase_b.invoicedate

                   

                    ###############
                    # trans_obj =Transaction.objects.filter(transactionid=purchase_b.purchaseid)
                    # is_first = False
                    # if tr==trans_obj.first():
                    #     is_first=True
                    # else:
                    #     is_first = False
                   
                    # if is_first:
                    #     transaction_dict['createddate'] = purchase_b.invoicedate
                    # else:
                    #     transaction_dict['createddate'] = tr.createddate
                    transaction_date = tr.transactiondate
                    if transaction_date:
                        transaction_dict['createddate'] = transaction_date
                    else:
                        transaction_dict['createddate'] = tr.createddate
                    ###############

                    transaction_list.append(transaction_dict)

            else:
                purchase = BranchPurchase.objects.filter(
                    purchaseid=transactionid
                ).first()
                if not purchase:
                    pass
                else:

                    ###########
                    if purchase.duebalance:
                        purchase_due_balance += purchase.duebalance
                    ###########

                    invoicenumber_list.add(purchase.invoicenumber)
                    if purchase.supplier == None:
                        accounts_list.add(purchase.externalsupplier.name)
                    else:
                        accounts_list.add(purchase.supplier.name)
                    transaction_dict["invoicenumber"] = purchase.invoicenumber
                    if purchase.supplier == None:
                        transaction_dict["accounts"] = purchase.externalsupplier.name
                    else:
                        transaction_dict["accounts"] = purchase.supplier.name
                    transaction_dict["paymentmode"] = tr.paymentmode
                    transaction_dict["transaction"] = tr
                    transaction_dict["branch"] = tr.branch
                    transaction_dict["title"] = "Purchase"
                    transaction_dict["amounttype"] = "Credit"
               
                    transaction_dict['date'] = purchase.invoicedate

                 

                    ###############
                    # trans_obj =Transaction.objects.filter(transactionid=purchase.purchaseid)
                    # is_first = False
                    # if tr==trans_obj.first():
                    #     is_first=True
                    # else:
                    #     is_first = False
                   
                    # if is_first:
                    #     transaction_dict['createddate'] = purchase.invoicedate
                    # else:
                    #     transaction_dict['createddate'] = tr.createddate
                    transaction_date = tr.transactiondate
                    if transaction_date:
                        transaction_dict['createddate'] = transaction_date
                    else:
                        transaction_dict['createddate'] = tr.createddate
                    ###############

                    transaction_list.append(transaction_dict)

        if tr.transactiontype == "purchasereturn":

            transactionid = tr.transactionid
            transaction_dict = {}
            # if currentuser.is_superuser:

            purchase_p = PurchaseReturn.objects.filter(
                purchasereturnid=transactionid
            ).first()
            if not purchase_p:
                pass
            else:
                invoicenumber_list.add(purchase_p.invoicenumber)
                if purchase_p.supplier == None:
                    accounts_list.add(purchase_p.externalsupplier.name)
                else:
                    accounts_list.add(purchase_p.supplier.name)
                transaction_dict["invoicenumber"] = purchase_p.invoicenumber
                if purchase_p.supplier == None:
                    transaction_dict["accounts"] = purchase_p.externalsupplier.name
                else:
                    transaction_dict["accounts"] = purchase_p.supplier.name
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Purchase Return"
                transaction_dict["amounttype"] = "Debit"
              
                transaction_dict['date'] = purchase_p.createddate

       

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=purchase_p.purchasereturnid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = purchase_p.createddate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "sale":

            transactionid = tr.transactionid
            transaction_dict = {}
            sale = Sale.objects.filter(saleid=transactionid).first()
            if not sale:
                pass
            else:
                ###########
                if sale.duebalance:
                    sale_due_balance += sale.duebalance
                ###########
                invoicenumber_list.add(sale.invoicenumber)
                accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = sale.invoicenumber
                transaction_dict["accounts"] = sale.customer
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Sale"
                transaction_dict["amounttype"] = "Debit"
              
                transaction_dict['date'] = sale.invoicedate


                ###############
                # trans_obj =Transaction.objects.filter(transactionid=sale.saleid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = sale.invoicedate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "salereturn":
            transactionid = tr.transactionid
            transaction_dict = {}
            sale = SaleReturn.objects.filter(salereturnid=transactionid).first()
            if not sale:
                pass
            else:
                invoicenumber_list.add(sale.invoicenumber)
                accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = sale.invoicenumber
                transaction_dict["accounts"] = sale.customer
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Sale Return"
                transaction_dict["amounttype"] = "Credit"
               
                transaction_dict['date'] = sale.createddate

              

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=sale.salereturnid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = sale.createddate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "expense":

            transactionid = tr.transactionid
            transaction_dict = {}
            expense = Expenses.objects.filter(expenseid=transactionid).first()
            if not expense:
                pass
            else:
                invoicenumber_list.add(expense.billnumber)
                # accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = expense.billnumber
                transaction_dict["accounts"] = ""
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = expense.remarks
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Expense"
                transaction_dict["amounttype"] = "Credit"
             
                transaction_dict['date'] = expense.expensedate

           

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=expense.expenseid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = expense.expensedate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "payment":

            transactionid = tr.transactionid
            transaction_dict = {}
            payment = Payments.objects.filter(paymentid=transactionid).first()
            if not payment:
                pass
            else:
                invoicenumber_list.add(payment.referenceno)
                # accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = payment.referenceno
                transaction_dict["accounts"] = payment.debitaccount
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = payment.description
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Payment"
                transaction_dict["amounttype"] = "Credit"
              
                transaction_dict['date'] = payment.paymentdate

             

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=payment.paymentid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = payment.paymentdate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "receipt":

            transactionid = tr.transactionid
            transaction_dict = {}
            receipt = Receipts.objects.filter(receiptid=transactionid).first()
            if not receipt:
                pass
            else:
                invoicenumber_list.add(receipt.referenceno)
                # accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = receipt.referenceno
                transaction_dict["accounts"] =receipt.creditaccount
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = receipt.description
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Receipt"
                transaction_dict["amounttype"] = "Debit"
             
                transaction_dict['date'] = receipt.receiptdate

      

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=receipt.receiptid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = receipt.receiptdate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "journal":

            transactionid = tr.transactionid
            transaction_dict = {}
            journal = Journals.objects.filter(journalid=transactionid).first()
            if not journal:
                pass
            else:

                amount_type = ''
                accounts = ''
                # cash_list = ['CASH ACCOUNT']

                if journal.creditaccount == tr.accounts:
                    amount_type = 'Credit'
                elif journal.debitaccount == tr.accounts:
                    amount_type = 'Debit'

                invoicenumber_list.add(journal.referenceno)
                transaction_dict["invoicenumber"] = journal.referenceno
                transaction_dict["accounts"] = tr.accounts
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = journal.description
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Journal"
                transaction_dict["amounttype"] = amount_type
                transaction_dict['date'] = journal.journaldate


                # invoicenumber_list.add(journal.referenceno)
                # # accounts_list.add(sale.customer)
                # transaction_dict["invoicenumber"] = journal.referenceno
                # transaction_dict["accounts"] = ""
                # transaction_dict["paymentmode"] = tr.paymentmode
                # transaction_dict["transaction"] = tr
                # transaction_dict["remarks"] = journal.description
                # transaction_dict["branch"] = tr.branch
                # transaction_dict["title"] = "Journal"
                # transaction_dict["amounttype"] = ""
                # transaction_dict['date'] = journal.journaldate
         

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=journal.journalid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = journal.journaldate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "service":

            transactionid = tr.transactionid
            transaction_dict = {}
            # expense =Expenses.objects.filter(expenseid = transactionid).first()
            service = Service.objects.filter(servicerefnumber=transactionid).first()
            if not service:
                pass
            else:

                ###########
                if service.duebalance:
                    service_due_balance += service.duebalance
                ###########

                invoicenumber_list.add(service.servicerefnumber)
                accounts_list.add(f"{service.firstname} {service.lastname}")
                transaction_dict["invoicenumber"] = service.servicerefnumber
                transaction_dict["accounts"] = f"{service.firstname} {service.lastname}"
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Service"
                transaction_dict["amounttype"] = "Debit"
             
                transaction_dict['date'] = service.memodate
           

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=service.servicerefnumber)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = service.memodate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)



    if startdate:
        startdate = datetime.strptime(startdate, "%d-%m-%Y").date()

    if enddate:
        enddate = datetime.strptime(enddate, "%d-%m-%Y").date()

    if startdate and enddate:
        transaction_list  = sorted(
        [
            transaction for transaction in transaction_list 
            if startdate <= transaction['createddate'] <= enddate
        ],
        key=lambda x: x['createddate'],
        reverse=False
        )
    else:
        transaction_list = sorted(
        transaction_list,
        key=lambda x: x['createddate'],
        reverse=False
    )

    for transaction in transaction_list:
        if transaction["amounttype"] == "Debit":
            total_debit += transaction["transaction"].amount
        elif transaction["amounttype"] == "Credit":
            total_credit += transaction["transaction"].amount

    total_balance = total_debit - total_credit

    paymentmodes = PaymentMode.objects.all()

    context = {
        'search':search,
        'filteredtotaldebit':total_debit,
        'filteredtotalcredit':total_credit,
        'filteredbalance':total_balance,
        "transaction": transaction_list,
        "invoicenumber_list": invoicenumber_list,
        "accounts_list": accounts_list,
        "paymentmodes": paymentmodes,
        "purchase_due_balance": purchase_due_balance,
        "sale_due_balance": sale_due_balance,
        "service_due_balance": service_due_balance,
    }

    return render(request, "daybook.html", context)


def ChartofAccounts(request):
    data = CoASubAccounts.objects.filter(is_adminonly=False).order_by("-pk")
    return render(request, "chartofaccounts.html", {"rootsubcoa": data})



def get_account_details(request):
    ledger_name = request.GET.get('ledger_name')
    try:
        ledger = AccountLedger.objects.get(name=ledger_name)
        account_group = ledger.account_group
        account_head = account_group.account_head
        
        data = {
            'success': True,
            'account_group': account_group.name,
            'account_head': account_head.name
        }
    except AccountLedger.DoesNotExist:
        data = {
            'success': False,
            'message': 'Ledger not found'
        }
    return JsonResponse(data)

def get_account_groups(request):
    head_name = request.GET.get('head_name')
    try:
        head = AccountHead.objects.get(name=head_name)
        groups = AccountGroup.objects.filter(account_head=head)
        data = {
            'success': True,
            'groups': list(groups.values('name'))
        }
    except AccountHead.DoesNotExist:
        data = {
            'success': False,
            'message': 'Account head not found'
        }
    return JsonResponse(data)

def get_account_ledgers(request):
    group_name = request.GET.get('group_name')
    try:
        group = AccountGroup.objects.get(name=group_name)
        ledgers = AccountLedger.objects.filter(account_group=group)
        data = {
            'success': True,
            'ledgers': list(ledgers.values('name'))
        }
    except AccountGroup.DoesNotExist:
        data = {
            'success': False,
            'message': 'Account group not found'
        }
    return JsonResponse(data)

def ChartofAccountsForm(request):
    all_heads = AccountHead.objects.all()
    all_groups = AccountGroup.objects.all()
    all_ledgers = AccountLedger.objects.all()
    all_ledgers_new = []
    for item in all_ledgers:
        if item.name != "CASH ACCOUNT":
            all_ledgers_new.append(item)
    
    context = {
        "account_heads": all_heads,
        "account_groups": all_groups,
        "account_ledgers": all_ledgers_new ,
    }
    return render(request, "chartofaccountsform.html", context)


# def ChartofAccountsForm(request):
#     root_coa = AccountLedger.objects.all()
#     return render(request, "chartofaccountsform.html", {"root_coa": root_coa})


def addChartOfAccounts(request):
    data = CoASubAccounts()
    expensecatagory = ExpenseCategory()
    # rootcoasub = request.POST["coa"]
    rootcoasub = request.POST["accountledger"]
    accountledgerobj = AccountLedger.objects.filter(name=rootcoasub).first()
    title = request.POST["title"]
    if '_' in title:
        messages.error(request, "There should not be '_' in the title!")
        return redirect("chartofaccountsform")
    data.head_root = accountledgerobj
    gstring = rootcoasub.replace(" ", "_")
    data.gstring = gstring
    data.title = title
    data.branch = request.user.userprofile.branch
    if CoASubAccounts.objects.filter(title=request.POST['title']).first():
        messages.error(request, "Title already exist!")
        return redirect("chartofaccountsform")


    data.description = request.POST["description"]
    data.save()

    # Save all expense coa to the expensecatagory table so that we can select this from the dropdown of the expense section
    if rootcoasub == "EXPENSE":
        expensecatagory.name = data.title
        expensecatagory.save()

    return redirect("chartofaccounts")


def deleteChartofAccounts(request, id):
    obj = CoASubAccounts.objects.filter(id=int(id)).first()
    obj.delete()
    data = CoASubAccounts.objects.all().order_by("-pk")
    return render(request, "chartofaccounts.html", {"rootsubcoa": data})


# def editChartofAccounts(request, id):
#     root_coa = coa.COA_GROUP_LIST
#     obj = CoASubAccounts.objects.filter(id=int(id)).first()
#     return render(
#         request, "chartofaccountsupdateform.html", {"root_coa": root_coa, "coa": obj}
#     )

def editChartofAccounts(request, id):

    obj = CoASubAccounts.objects.filter(id=int(id)).first()

    all_heads = AccountHead.objects.all()
    all_groups = AccountGroup.objects.all()
    all_ledgers = AccountLedger.objects.all()
    all_ledgers_new = []
    for item in all_ledgers:
        if item.name != "CASH ACCOUNT":
            all_ledgers_new.append(item)
    
    context = {
        "account_heads": all_heads,
        "account_groups": all_groups,
        "account_ledgers": all_ledgers_new,
        "coa": obj,
        "account_group":obj.head_root.account_group,
        "account_head":obj.head_root.account_group.account_head
    }
    return render(
        request, "chartofaccountsupdateform.html",context
    )


def updateChartOfAccounts(request):
    id_no = request.POST["id"]
    data = CoASubAccounts.objects.filter(id=int(id_no)).first()
    expensecatagory = ExpenseCategory()
    rootcoasub = request.POST["accountledger"]
    accountledgerobj = AccountLedger.objects.filter(name=rootcoasub).first()
    # rootcoasub = request.POST["coa"]
    data.head_root = accountledgerobj
    gstring = rootcoasub.replace(" ", "_")
    data.gstring = gstring
    data.title = request.POST["title"]
    data.branch = request.user.userprofile.branch
    # if CoASubAccounts.objects.filter(title=request.POST['title']).first():
    #     messages.error(request, "Title already exist!")
    #     return redirect(reverse("editchartofaccounts", kwargs={"id": id_no}))
    data.description = request.POST["description"]
    data.save()

    if rootcoasub == "EXPENSE":
        expensecatagory.name = data.title
        expensecatagory.save()

    return redirect("chartofaccounts")


@user_passes_test(
    partial(check_permission, page="Generalledger"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def general_ledger(request):
    currentuser = request.user
    data = Ledger.objects.filter(branch=currentuser.userprofile.branch)
    account_heads = (
        Ledger.objects.filter(branch=currentuser.userprofile.branch)
        .order_by("account_subhead")
        .values("account_subhead")
        .distinct()
    )

    if request.user.is_superuser:
        all_branches = Branch.objects.filter(
            Q(branchtype="Own") | Q(branchtype="Franchise") | Q(name="WAREHOUSE")
        )
    else:
        all_branches = [request.user.userprofile.branch]

    totaldebit = 0
    totalcredit = 0
    for item in data:
        totaldebit += item.debit_amount
        totalcredit += item.credit_amount

        totaldebit = round(totaldebit, 2)
        totalcredit = round(totalcredit, 2)

    # check the balance and balance type based on the total value
    if totaldebit > totalcredit:
        balancetype = "Dr"
        balance = totaldebit - totalcredit
        balance = round(balance, 2)
    else:
        balancetype = "Cr"
        balance = totalcredit - totaldebit
        balance = round(balance, 2)

    # setting a variable so that opening balance row can be displayed
    search = "No"

    context = {
        "data": data,
        "branch_list": all_branches,
        "totaldebit": totaldebit,
        "totalcredit": totalcredit,
        "search": search,
        "balance": balance,
        "balancetype": balancetype,
        "account_heads": account_heads,
    }
    return render(request, "generalledger.html", context)


def generalLedgerSearch(request):

    currentuser = request.user
    selectedbranch = request.POST.get("branch")
    head = request.POST.get("head")
    startdate = request.POST.get("startdate")
    enddate = request.POST.get("enddate")

    # Convert the date string to YYYY-MM-DD format
    startdate_object = datetime.strptime(startdate, "%d-%m-%Y")
    formated_startdate = startdate_object.strftime("%Y-%m-%d")

    enddate_object = datetime.strptime(enddate, "%d-%m-%Y")
    formated_enddate = enddate_object.strftime("%Y-%m-%d")

    account_heads = (
        Ledger.objects.filter(branch=currentuser.userprofile.branch)
        .order_by("account_head")
        .values("account_head")
        .distinct()
    )
    if request.user.is_superuser:
        all_branches = Branch.objects.filter(
            Q(branchtype="Own") | Q(branchtype="Franchise") | Q(name="WAREHOUSE")
        )
    else:
        all_branches = [request.user.userprofile.branch]

    args = {}
    args["branch"] = selectedbranch
    args["account_head"] = head
    args["date__range"] = (formated_startdate, formated_enddate)

    datawithoutfilter = Ledger.objects.filter(branch=currentuser.userprofile.branch)
    data = Ledger.objects.filter(**args)

    totaldebit = 0
    totalcredit = 0
    for item in datawithoutfilter:
        totaldebit += item.debit_amount
        totalcredit += item.credit_amount

    # check the balance and balance type based on the total value
    if totaldebit > totalcredit:
        balancetype = "Dr"
        balance = totaldebit - totalcredit
        balance = round(balance, 2)
    else:
        balancetype = "Cr"
        balance = totalcredit - totaldebit
        balance = round(balance, 2)

    filteredtotaldebit = 0
    filteredtotalcredit = 0

    for item in data:
        filteredtotaldebit += item.debit_amount
        filteredtotalcredit += item.credit_amount

    # check the balance and balance type based on the total value
    if filteredtotaldebit > filteredtotalcredit:
        filteredbalancetype = "Dr"
        filteredbalance = filteredtotaldebit - filteredtotalcredit
        filteredbalance = round(filteredbalance, 2)
    else:
        filteredbalancetype = "Cr"
        filteredbalance = filteredtotalcredit - filteredtotaldebit
        filteredbalance = round(filteredbalance, 2)

    # calculate the opening balance with method date__lte which is 'less than or equal to'
    openingargs = {}
    openingargs["branch"] = selectedbranch
    openingargs["account_head"] = head
    openingargs["date__lte"] = formated_startdate

    # use the keyward argument with filter
    datalte = Ledger.objects.filter(**openingargs)
    openingdebit = 0
    openingcredit = 0
    for item in datalte:
        openingdebit += item.debit_amount
        openingcredit += item.credit_amount

    if openingdebit > openingcredit:
        openingbalancetype = "Dr"
        openingbalance = openingdebit - openingcredit
        openingbalance = round(openingbalance, 2)
    else:
        openingbalancetype = "Cr"
        openingbalance = openingcredit - openingdebit
        openingbalance = round(openingbalance, 2)
    # ending opening balance calculation

    # setting a variable so that opening balance row can be displayed
    search = "Yes"

    context = {
        "data": data,
        "startdate": startdate,
        "search": search,
        "account_heads": account_heads,
        "branch_list": all_branches,
        "totaldebit": totaldebit,
        "totalcredit": totalcredit,
        "balancetype": balancetype,
        "balance": balance,
        "filteredtotaldebit": filteredtotaldebit,
        "filteredtotalcredit": filteredtotalcredit,
        "filteredbalancetype": filteredbalancetype,
        "filteredbalance": filteredbalance,
        "openingbalancetype": openingbalancetype,
        "openingbalance": openingbalance,
    }

    return render(request, "generalledger.html", context)



@login_required
def general_ledger_new(request):

    gl_obj = GeneralLedger.objects.all().order_by("-pk")

    context={"gl_obj":gl_obj}

    all_ledgers = [item.ledger for item in gl_obj]
    all_subledgers = [item.subledger for item in gl_obj]
    all_voucher_nos = [item.voucher_no for item in gl_obj]
    context['all_ledgers'] = all_ledgers 
    context['all_subledgers'] = all_subledgers
    context['all_voucher_nos'] = all_voucher_nos
    context["search"] = "No"

    if request.method == "POST":
        context["search"] = "Yes"
        context['all_ledgers'] = all_ledgers 
        context['all_subledgers'] = all_subledgers
        context['all_voucher_nos'] = all_voucher_nos



        startdate = request.POST["startdate"]
        enddate = request.POST["enddate"]
        ledger = request.POST["acc_group"]
        subledger = request.POST["acc_ledger"]
        voucher_no = request.POST["voucher_nos"]

        filters = Q()

        search_dict = {}

        
        if ledger:
            acc_ledger_obj = AccountLedger.objects.filter(id=int(ledger)).first()
            filters &= Q(ledger=acc_ledger_obj)

            search_dict['ledger'] = acc_ledger_obj.name

        if subledger:
            sub_ledger_obj = CoASubAccounts.objects.filter(id=int(subledger)).first()
            filters &= Q(subledger=sub_ledger_obj)

            search_dict['subledger'] = sub_ledger_obj.title

        if voucher_no:
            filters &= Q(voucher_no=voucher_no)

            search_dict['voucher_no'] = voucher_no

        if startdate:
            startdate = datetime.strptime(startdate, "%d-%m-%Y")
            filters &= Q(date__gte=startdate)

            search_dict['startdate'] = startdate

        if enddate:
            enddate = datetime.strptime(enddate, "%d-%m-%Y")
            filters &= Q(date__lte=enddate)

            search_dict['enddate'] = enddate

        gl_obj = GeneralLedger.objects.filter(filters).order_by("-pk")

        balance = 0
        for item in gl_obj:
            if item.amount_type == "Debit":
                balance += item.amount
            else:
                balance -= item.amount

        context["gl_obj"] = gl_obj
        context["search_dict"] = search_dict
        context['balance'] = balance

    return render(request, "generalledgernew.html", context)


@login_required
def single_ledger(request):
    currentuser = request.user
    if currentuser.is_superuser:
        data = SingleLedger.objects.all()
    else:
        data = SingleLedger.objects.filter(branch=currentuser.userprofile.branch)

    context = {"data": data}
    return render(request, "singleledger.html", context)


@login_required
def single_ledger_form(request):
    if request.user.is_superuser:
        branch_list = Branch.objects.filter(
            Q(branchtype="Own") | Q(branchtype="Franchise") | Q(name="WAREHOUSE")
        )
    else:
        branch_list = [request.user.userprofile.branch]
    data = CoASubAccounts.objects.all().order_by("-pk")
    context = {
        "account_head": data,
        "branch_list": branch_list,
    }
    return render(request, "singleledgerform.html", context)


@login_required
def add_single_ledger(request):
    data = SingleLedger()
    data.account_head = request.POST["account_head"]
    data.narration = request.POST["narration"]
    ledger_date = request.POST["date"]
    data.date = datetime.strptime(ledger_date, "%d-%m-%Y")
    data.amount = request.POST["amount"]
    data.account_type = request.POST["account_type"]
    data.branch = request.POST["branch"]
    data.save()

    financial_statement = addaccounts.AccountStatement()

    ledger_params = {
        "account_head": data.account_head,
        "amount": data.amount,
        "userbranch": data.branch,
        "ledger_date": data.date,
        "narration": data.narration,
        "account_type": data.account_type,
    }

    financial_statement.add_ledger("SingleLedger", ledger_params)

    return redirect("singleledger")


@user_passes_test(
    partial(check_permission, page="Placcount"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def pl_accounts(request):

    if request.method == "POST":
        startdate = request.POST["startdate"]
        startdate = datetime.strptime(startdate, "%d-%m-%Y")

        enddate = request.POST["enddate"]
        enddate = datetime.strptime(enddate, "%d-%m-%Y")
        if request.user.is_superuser:
            branch = request.POST["branch"]
        else:
            branch = request.user.userprofile.branch
    else:
        if request.user.is_superuser:
            all_branches = Branch.objects.filter(
                Q(branchtype="Own") | Q(branchtype="Franchise") | Q(name="WAREHOUSE")
            )
        else:
            all_branches = [request.user.userprofile.branch]
        data = {"branch_list": all_branches}
        return render(request, "placcount.html", data)
    totalsale = 0
    totalpurchase = 0
    totalservice = 0
    total_indirect_expense = 0
    other_income = 0
    totalsalereturn = 0
    totalpurchasereturn = 0
    opening_stock = 0
    closing_stock = 0
    branchid = Branch.objects.filter(name=branch).first()
    cashbook = CashBook.objects.filter(
        Q(branch=branch) & Q(date__range=(startdate, enddate))
    )
    if cashbook:
        # take the total sale, purchase and service from the cashbook and expenses from the expense model
        # this is because expense is showing individually in the cashbook
        df = pd.DataFrame.from_records(cashbook.values())
        try:
            totalsale = df[df["description"] == "Sale"]["receipt"].sum()
        except:
            totalsale = 0
        try:
            totalpurchase = df[df["description"] == "Purchase"]["payment"].sum()
        except:
            totalpurchase = 0
        try:
            totalservice = df[df["description"] == "Service"]["receipt"].sum()
        except:
            totalservice = 0

        try:
            totalsalereturn = df[df["description"] == "Sale Return"]["payment"].sum()
        except:
            totalsalereturn = 0
        try:
            totalpurchasereturn = df[df["description"] == "Purchase Return"][
                "receipt"
            ].sum()
        except:
            totalpurchasereturn = 0
    payment = Payments.objects.filter(
        Q(branch=branchid) & Q(paymentdate__range=(startdate, enddate))
    )
    if payment:
        paymentdf = pd.DataFrame.from_records(payment.values())
        total_indirect_expense = paymentdf["amount"].sum()
    receipt = Receipts.objects.filter(
        Q(branch=branchid) & Q(receiptdate__range=(startdate, enddate))
    )
    if receipt:
        receiptdf = pd.DataFrame.from_records(receipt.values())
        other_income = receiptdf["amount"].sum()

    # Converting the date to datetime with timezone. for now setting timezone UTC as there is no significance of time here instead only date caluclated.
    startdate = timezone.make_aware(startdate, timezone=timezone.utc)
    opening_added_stock = (
        StockTransaction.objects.filter(
            Q(branch=branchid)
            & Q(transactiontype="Add")
            & Q(created_date__lte=startdate)
        ).aggregate(total=Sum("transaction_value"))["total"]
        or 0
    )
    opening_consumed_stock = (
        StockTransaction.objects.filter(
            Q(branch=branchid)
            & Q(transactiontype="Sub")
            & Q(created_date__lte=startdate)
        ).aggregate(total=Sum("transaction_value"))["total"]
        or 0
    )
    opening_stock = opening_added_stock - opening_consumed_stock

    enddate = timezone.make_aware(enddate, timezone=timezone.utc)
    closing_added_stock = (
        StockTransaction.objects.filter(
            Q(branch=branchid) & Q(transactiontype="Add") & Q(created_date__lte=enddate)
        ).aggregate(total=Sum("transaction_value"))["total"]
        or 0
    )
    closing_consumed_stock = (
        StockTransaction.objects.filter(
            Q(branch=branchid) & Q(transactiontype="Sub") & Q(created_date__lte=enddate)
        ).aggregate(total=Sum("transaction_value"))["total"]
        or 0
    )
    closing_stock = closing_added_stock - closing_consumed_stock

    # Calculate the spare parts cost for a particular period and then calculate the service cost
    spare_total = 0
    spare_parts = SpareParts.objects.filter(createddate__range=(startdate, enddate))
    for row in spare_parts:
        spare_total += int(row.price) * int(row.salegst) / 100

    # Service cost - spare parts cost is the actual service cost
    totalservice = totalservice - spare_total

    debittotal = (
        opening_stock + totalpurchase + total_indirect_expense + totalsalereturn
    )
    credittotal = (
        totalservice + totalsale + totalpurchasereturn + closing_stock + other_income
    )
    profit = 0
    loss = 0
    if debittotal > credittotal:
        loss = debittotal - credittotal
    else:
        profit = credittotal - debittotal
    if request.user.is_superuser:
        all_branches = Branch.objects.filter(
            Q(branchtype="Own") | Q(branchtype="Franchise") | Q(name="WAREHOUSE")
        )
    else:
        all_branches = [request.user.userprofile.branch]

    data = {
        "totalpurchase": round(totalpurchase, 2),
        "totalindirectexpense": round(total_indirect_expense, 2),
        "otherincome": round(other_income, 2),
        "totalsale": round(totalsale, 2),
        "totalservice": round(totalservice, 2),
        "totalsalereturn": round(totalsalereturn, 2),
        "totalpurchasereturn": round(totalpurchasereturn, 2),
        "openingstock": round(opening_stock, 2),
        "closingstock": round(closing_stock, 2),
        "profit": round(profit, 2),
        "loss": round(loss, 2),
        "spare_parts_cost": round(spare_total, 2),
        "debittotal": round(debittotal, 2),
        "credittotal": round(credittotal, 2),
        "branch_list": all_branches,
    }

    return render(request, "placcount.html", data)


# @user_passes_test(partial(check_permission, page="Placcount"),login_url='/accessdenied/',redirect_field_name=None)
# @login_required
# def searchPlAccount(request):
#     startdate = request.POST['startdate']
#     startdate = datetime.strptime(startdate,"%d-%m-%Y")

#     enddate = request.POST['enddate']
#     enddate  = datetime.strptime(enddate ,"%d-%m-%Y")

#     branch = request.POST['branch']
#     totalsale = 0
#     totalpurchase = 0
#     totalservice = 0
#     totalindirectexpense = 0
#     totalsalereturn = 0
#     totalpurchasereturn = 0
#     branchid = Branch.objects.filter(name=branch).first()
#     cashbook = CashBook.objects.filter(Q(branch=branch)&Q(date__range=(startdate, enddate)))
#     if cashbook:
#         # take the total sale, purchase and service from the cashbook and expenses from the expense model
#         # this is because expense is showing individually in the cashbook
#         df = pd.DataFrame.from_records(cashbook.values())
#         totalsale = df[df['description'] == "Sale"]['receipt'].sum()
#         totalpurchase = df[df['description'] == "Purchase"]['payment'].sum()
#         totalservice = df[df['description'] == "Service"]['receipt'].sum()
#         totalsalereturn = df[df['description'] == "Sale Return"]['payment'].sum()
#         totalpurchasereturn = df[df['description'] == 'Purchase Return']['receipt'].sum()
#     expense = Expenses.objects.filter(Q(branch=branchid)&Q(expensedate__range=(startdate, enddate)))
#     if expense:
#         expensedf = pd.DataFrame.from_records(expense.values())
#         totalindirectexpense = expensedf['amount'].sum()
#     debittotal = totalpurchase + totalindirectexpense + totalsalereturn
#     credittotal = totalservice + totalsale + totalpurchasereturn
#     profit = 0
#     loss = 0
#     if debittotal > credittotal:
#         loss = debittotal - credittotal
#     else:
#         profit = credittotal - debittotal
#     if request.user.is_superuser:
#         all_branches=Branch.objects.filter(Q(branchtype="Own")|Q(branchtype='Franchise'))
#     else:
#         all_branches=[request.user.userprofile.branch]
#     data = {
#         'totalpurchase': totalpurchase,
#         'totalindirectexpense': totalindirectexpense,
#         'totalsale': totalsale,
#         'totalservice': totalservice,
#         'totalsalereturn': totalsalereturn,
#         'totalpurchasereturn': totalpurchasereturn,
#         'profit': profit,
#         'loss': loss,
#         'debittotal': debittotal,
#         'credittotal': credittotal,
#         "branch_list":all_branches,
#     }
#     return render (request, 'placcount.html', data)


@user_passes_test(
    partial(check_permission, page="Cashbook"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def cash_book(request):
    if request.method == "POST":
        try:
            startdate = request.POST["startdate"]
            ss = startdate
            startdate = datetime.strptime(startdate, "%d-%m-%Y")
            enddate = request.POST["enddate"]
            enddate = datetime.strptime(enddate, "%d-%m-%Y")
        except:
            startdate = date.today()
            enddate = date.today()

        if request.user.is_superuser:
            branch = request.POST["branch"]
        else:
            branch = request.user.userprofile.branch
    else:
        branch = request.user.userprofile.branch
        startdate = date.today()
        enddate = date.today()

    # Cash Transactions
    # Identify the opening balance
    # TBD : Multiple database query, needs to be replaced with pandas query
   
    try:
        all_cashbook_cash = CashBook.objects.filter(Q(branch=branch) & Q(mode="Cash"))
        df_cash_opening = pd.DataFrame.from_records(all_cashbook_cash.values())
        df_cash_opening["date"] = pd.to_datetime(
            df_cash_opening["date"], errors="coerce"
        )
        df_cash_opening = df_cash_opening.dropna(subset=["date"])
        filtered_df = df_cash_opening[
            df_cash_opening["date"] < pd.to_datetime(startdate)
        ]
        opening_cash_payment = filtered_df["payment"].sum()
        opening_cash_receipt = filtered_df["receipt"].sum()
    except:
        opening_cash_payment = 0
        opening_cash_receipt = 0

    if opening_cash_payment > opening_cash_receipt:
        opening_cash_balance = opening_cash_payment - opening_cash_receipt
        opening_cash_balance_type = "payment"

    else:
        opening_cash_balance = opening_cash_receipt - opening_cash_payment
        opening_cash_balance_type = "receipt"

    opening_cash_balance = round(opening_cash_balance, 2)

    cashbook_cash = CashBook.objects.filter(
        Q(branch=branch) & Q(date__range=(startdate, enddate)) & Q(mode="Cash")
    )

    
    excluded_value_cash = [
        "Purchase",
        "Sale",
        "Service",
        "Sale Return",
        "Purchase Return",
        "PAYMENT",
        "RECEIPT",
    ]
    cashbookother_cash = CashBook.objects.exclude(
        Q(branch=branch) & Q(mode="Cash") & Q(date__range=(startdate, enddate)),
        description__in=excluded_value_cash,
    )
    df_cash = pd.DataFrame.from_records(cashbook_cash.values())

    try:
        totalsale_cash = (
            df_cash[df_cash["description"] == "Sale"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        # convert the above dataframes into django query sets for all the dfs
        totalsaleqs_cash = totalsale_cash.to_dict(orient="records")
    except KeyError:
        totalsaleqs_cash = None
    try:
        totalpurchase_cash = (
            df_cash[df_cash["description"] == "Purchase"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalpurchaseqs_cash = totalpurchase_cash.to_dict(orient="records")
    except KeyError:
        totalpurchaseqs_cash = None
    try:
        totalservice_cash = (
            df_cash[df_cash["description"] == "Service"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalserviceqs_cash = totalservice_cash.to_dict(orient="records")
    except KeyError:
        totalserviceqs_cash = None
    try:
        totalsalereturn_cash = (
            df_cash[df_cash["description"] == "Sale Return"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalsalereturnqs_cash = totalsalereturn_cash.to_dict(orient="records")
    except KeyError:
        totalsalereturnqs_cash = None
    try:
        totalpurchasereturn_cash = (
            df_cash[df_cash["description"] == "Purchase Return"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalpurchasereturnqs_cash = totalpurchasereturn_cash.to_dict(orient="records")
    except KeyError:
        totalpurchasereturnqs_cash = None
    try:
        totalpayment_cash = (
            df_cash[df_cash["description"] == "PAYMENT"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalpaymentqs_cash = totalpayment_cash.to_dict(orient="records")
    except KeyError:
        totalpaymentqs_cash = None
    try:
        totalreceipt_cash = (
            df_cash[df_cash["description"] == "RECEIPT"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalreceiptqs_cash = totalreceipt_cash.to_dict(orient="records")
    except KeyError:
        totalreceiptqs_cash = None

    # Calculate the closing balance
    # TBD: add the filter and then identify the opening balance as well
    totalpaymentbalance_cash = 0
    totalreceiptbalance_cash = 0
    for item in cashbook_cash:
        totalpaymentbalance_cash += item.payment
        totalreceiptbalance_cash += item.receipt

    if opening_cash_balance_type == "payment":
        totalpaymentbalance_cash += opening_cash_balance
    elif opening_cash_balance_type == "receipt":
        totalreceiptbalance_cash += opening_cash_balance

    if totalpaymentbalance_cash > totalreceiptbalance_cash:
        balancetype_cash = "payment"
        closingbalance_cash = totalpaymentbalance_cash - totalreceiptbalance_cash
    else:
        balancetype_cash = "receipt"
        closingbalance_cash = totalreceiptbalance_cash - totalpaymentbalance_cash

    closingbalance_cash = round(closingbalance_cash, 2)

    # UPI Transactions
    # Identify the opening balance for UPI
    # TBD : Multiple database query, needs to be replaced with pandas query
    try:
        all_cashbook_upi = CashBook.objects.filter(Q(branch=branch) & Q(mode="UPI"))
        df_upi_opening = pd.DataFrame.from_records(all_cashbook_upi.values())
        df_upi_opening["date"] = pd.to_datetime(df_upi_opening["date"], errors="coerce")
        df_upi_opening = df_upi_opening.dropna(subset=["date"])
        filtered_df_upi = df_upi_opening[
            df_upi_opening["date"] < pd.to_datetime(startdate)
        ]
        opening_upi_payment = filtered_df_upi["payment"].sum()
        opening_upi_receipt = filtered_df_upi["receipt"].sum()
    except:
        opening_upi_payment = 0
        opening_upi_receipt = 0

    if opening_upi_payment > opening_upi_receipt:
        opening_upi_balance = opening_upi_payment - opening_upi_receipt
        opening_upi_balance_type = "payment"

    else:
        opening_upi_balance = opening_upi_receipt - opening_upi_payment
        opening_upi_balance_type = "receipt"

    opening_upi_balance = round(opening_upi_balance, 2)

    cashbook_upi = CashBook.objects.filter(
        Q(branch=branch) & Q(date__range=(startdate, enddate)) & Q(mode="UPI")
    )
    excluded_value_upi = [
        "Purchase",
        "Sale",
        "Service",
        "Sale Return",
        "Purchase Return",
        "PAYMENT",
        "RECEIPT",
    ]
    cashbookother_upi = CashBook.objects.exclude(
        Q(branch=branch) & Q(mode="UPI") & Q(date__range=(startdate, enddate)),
        description__in=excluded_value_upi,
    )
    df_upi = pd.DataFrame.from_records(cashbook_upi.values())

    try:
        totalsale_upi = (
            df_upi[df_upi["description"] == "Sale"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        # convert the above dataframes into django query sets for all the dfs
        totalsaleqs_upi = totalsale_upi.to_dict(orient="records")
    except KeyError:
        totalsaleqs_upi = None
    try:
        totalpurchase_upi = (
            df_upi[df_upi["description"] == "Purchase"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalpurchaseqs_upi = totalpurchase_upi.to_dict(orient="records")
    except KeyError:
        totalpurchaseqs_upi = None
    try:
        totalservice_upi = (
            df_upi[df_upi["description"] == "Service"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalserviceqs_upi = totalservice_upi.to_dict(orient="records")
    except KeyError:
        totalserviceqs_upi = None
    try:
        totalsalereturn_upi = (
            df_upi[df_upi["description"] == "Sale Return"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalsalereturnqs_upi = totalsalereturn_upi.to_dict(orient="records")
    except KeyError:
        totalsalereturnqs_upi = None
    try:
        totalpurchasereturn_upi = (
            df_upi[df_upi["description"] == "Purchase Return"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalpurchasereturnqs_upi = totalpurchasereturn_upi.to_dict(orient="records")
    except KeyError:
        totalpurchasereturnqs_upi = None
    try:
        totalpayment_upi = (
            df_upi[df_upi["description"] == "PAYMENT"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalpaymentqs_upi = totalpayment_upi.to_dict(orient="records")
    except KeyError:
        totalpaymentqs_upi = None
    try:
        totalreceipt_upi = (
            df_upi[df_upi["description"] == "RECEIPT"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalreceiptqs_upi = totalreceipt_upi.to_dict(orient="records")
    except KeyError:
        totalreceiptqs_upi = None

    # Calculate the closing balance
    # TBD: add the filter and then identify the opening balance as well
    totalpaymentbalance_upi = 0
    totalreceiptbalance_upi = 0
    for item in cashbook_upi:
        totalpaymentbalance_upi += item.payment
        totalreceiptbalance_upi += item.receipt

    if opening_upi_balance_type == "payment":
        totalpaymentbalance_upi += opening_upi_balance
    elif opening_upi_balance_type == "receipt":
        totalreceiptbalance_upi += opening_upi_balance

    if totalpaymentbalance_upi > totalreceiptbalance_upi:
        balancetype_upi = "payment"
        closingbalance_upi = totalpaymentbalance_upi - totalreceiptbalance_upi
    else:
        balancetype_upi = "receipt"
        closingbalance_upi = totalreceiptbalance_upi - totalpaymentbalance_upi

    closingbalance_upi = round(closingbalance_upi, 2)

    # Bank Transactions
    # Identify the opening balance for Bank
    # TBD : Multiple database query, needs to be replaced with pandas query
    try:
        all_cashbook_bank = CashBook.objects.filter(Q(branch=branch) & Q(mode="Bank"))
        df_bank_opening = pd.DataFrame.from_records(all_cashbook_bank.values())
        df_bank_opening["date"] = pd.to_datetime(
            df_bank_opening["date"], errors="coerce"
        )
        df_bank_opening = df_bank_opening.dropna(subset=["date"])
        filtered_df_bank = df_bank_opening[
            df_bank_opening["date"] < pd.to_datetime(startdate)
        ]
        opening_bank_payment = filtered_df_bank["payment"].sum()
        opening_bank_receipt = filtered_df_bank["receipt"].sum()
    except:
        opening_bank_payment = 0
        opening_bank_receipt = 0

    if opening_bank_payment > opening_bank_receipt:
        opening_bank_balance = opening_bank_payment - opening_bank_receipt
        opening_bank_balance_type = "payment"

    else:
        opening_bank_balance = opening_bank_receipt - opening_bank_payment
        opening_bank_balance_type = "receipt"

    opening_bank_balance = round(opening_bank_balance, 2)

    cashbook_bank = CashBook.objects.filter(
        Q(branch=branch) & Q(date__range=(startdate, enddate)) & Q(mode="Bank")
    )
    excluded_value_bank = [
        "Purchase",
        "Sale",
        "Service",
        "Sale Return",
        "Purchase Return",
        "PAYMENT",
        "RECEIPT",
    ]
    cashbookother_bank = CashBook.objects.exclude(
        Q(branch=branch) & Q(mode="Bank") & Q(date__range=(startdate, enddate)),
        description__in=excluded_value_bank,
    )
    df_bank = pd.DataFrame.from_records(cashbook_bank.values())
    try:
        totalsale_bank = (
            df_bank[df_bank["description"] == "Sale"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        # convert the above dataframes into django query sets for all the dfs
        totalsaleqs_bank = totalsale_bank.to_dict(orient="records")
    except KeyError:
        totalsaleqs_bank = None
    try:
        totalpurchase_bank = (
            df_bank[df_bank["description"] == "Purchase"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalpurchaseqs_bank = totalpurchase_bank.to_dict(orient="records")
    except KeyError:
        totalpurchaseqs_bank = None
    try:
        totalservice_bank = (
            df_bank[df_bank["description"] == "Service"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalserviceqs_bank = totalservice_bank.to_dict(orient="records")
    except KeyError:
        totalserviceqs_bank = None
    try:
        totalsalereturn_bank = (
            df_bank[df_bank["description"] == "Sale Return"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalsalereturnqs_bank = totalsalereturn_bank.to_dict(orient="records")
    except KeyError:
        totalsalereturnqs_bank = None
    try:
        totalpurchasereturn_bank = (
            df_bank[df_bank["description"] == "Purchase Return"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalpurchasereturnqs_bank = totalpurchasereturn_bank.to_dict(orient="records")
    except KeyError:
        totalpurchasereturnqs_bank = None
    try:
        totalpayment_bank = (
            df_bank[df_bank["description"] == "PAYMENT"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalpaymentqs_bank = totalpayment_bank.to_dict(orient="records")
    except KeyError:
        totalpaymentqs_bank = None
    try:
        totalreceipt_bank = (
            df_bank[df_bank["description"] == "RECEIPT"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalreceiptqs_bank = totalreceipt_bank.to_dict(orient="records")
    except KeyError:
        totalreceiptqs_bank = None

    # Calculate the closing balance
    # TBD: add the filter and then identify the opening balance as well
    totalpaymentbalance_bank = 0
    totalreceiptbalance_bank = 0
    for item in cashbook_bank:
        totalpaymentbalance_bank += item.payment
        totalreceiptbalance_bank += item.receipt

    if opening_bank_balance_type == "payment":
        totalpaymentbalance_bank += opening_bank_balance
    elif opening_bank_balance_type == "receipt":
        totalreceiptbalance_bank += opening_bank_balance

    if totalpaymentbalance_bank > totalreceiptbalance_bank:
        balancetype_bank = "payment"
        closingbalance_bank = totalpaymentbalance_bank - totalreceiptbalance_bank
    else:
        balancetype_bank = "receipt"
        closingbalance_bank = totalreceiptbalance_bank - totalpaymentbalance_bank

    closingbalance_bank = round(closingbalance_bank, 2)



    #### added on 4/10/2024 ################
    

    try:
        all_cashbook_card = CashBook.objects.filter(Q(branch=branch) & Q(mode="Card"))
        df_card_opening = pd.DataFrame.from_records(all_cashbook_card.values())
        df_card_opening["date"] = pd.to_datetime(df_card_opening["date"], errors="coerce")
        df_card_opening = df_card_opening.dropna(subset=["date"])
        filtered_df_card = df_card_opening[
            df_card_opening["date"] < pd.to_datetime(startdate)
        ]
        opening_card_payment = filtered_df_card["payment"].sum()
        opening_card_receipt = filtered_df_card["receipt"].sum()
    except:
        opening_card_payment = 0
        opening_card_receipt = 0

    if opening_card_payment > opening_card_receipt:
        opening_card_balance = opening_card_payment - opening_card_receipt
        opening_card_balance_type = "payment"
    else:
        opening_card_balance = opening_card_receipt - opening_card_payment
        opening_card_balance_type = "receipt"

    opening_card_balance = round(opening_card_balance, 2)


    # ######################### added on 4/10/2024 ##########################
    
    # Card Transactions

    cashbook_card = CashBook.objects.filter(
        Q(branch=branch) & Q(date__range=(startdate, enddate)) & Q(mode="Card")
    )
    excluded_value_card = [
        "Purchase",
        "Sale",
        "Service",
        "Sale Return",
        "Purchase Return",
        "PAYMENT",
        "RECEIPT",
    ]
    cashbookother_card = CashBook.objects.exclude(
        Q(branch=branch) & Q(mode="Card") & Q(date__range=(startdate, enddate)),
        description__in=excluded_value_card,
    )
    df_card = pd.DataFrame.from_records(cashbook_card.values())
    try:
        totalsale_card = (
            df_card[df_card["description"] == "Sale"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        # convert the above dataframes into django query sets for all the dfs
        totalsaleqs_card = totalsale_card.to_dict(orient="records")
    except KeyError:
        totalsaleqs_card = None
    try:
        totalpurchase_card = (
            df_card[df_card["description"] == "Purchase"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalpurchaseqs_card = totalpurchase_card.to_dict(orient="records")
    except KeyError:
        totalpurchaseqs_card = None
    try:
        totalservice_card = (
            df_card[df_card["description"] == "Service"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalserviceqs_card = totalservice_card.to_dict(orient="records")
    except KeyError:
        totalserviceqs_card = None
    try:
        totalsalereturn_card = (
            df_card[df_card["description"] == "Sale Return"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalsalereturnqs_card = totalsalereturn_card.to_dict(orient="records")
    except KeyError:
        totalsalereturnqs_card = None
    try:
        totalpurchasereturn_card = (
            df_card[df_card["description"] == "Purchase Return"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalpurchasereturnqs_card = totalpurchasereturn_card.to_dict(orient="records")
    except KeyError:
        totalpurchasereturnqs_card = None
    try:
        totalpayment_card = (
            df_card[df_card["description"] == "PAYMENT"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalpaymentqs_card = totalpayment_card.to_dict(orient="records")
    except KeyError:
        totalpaymentqs_card = None
    try:
        totalreceipt_card = (
            df_card[df_card["description"] == "RECEIPT"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalreceiptqs_card = totalreceipt_card.to_dict(orient="records")
    except KeyError:
        totalreceiptqs_card = None

    # Calculate the closing balance
    # TBD: add the filter and then identify the opening balance as well
    totalpaymentbalance_card = 0
    totalreceiptbalance_card = 0
    for item in cashbook_card:
        totalpaymentbalance_card += item.payment
        totalreceiptbalance_card += item.receipt

    ## Added on 7/0/2024 ######
    # Add the opening balance for card
    if opening_card_balance_type == "payment":
        totalpaymentbalance_card += opening_card_balance
    elif opening_card_balance_type == "receipt":
        totalreceiptbalance_card += opening_card_balance
    ########################

    if totalpaymentbalance_card > totalreceiptbalance_card:
        balancetype_card = "payment"
        closingbalance_card = totalpaymentbalance_card - totalreceiptbalance_card
    else:
        balancetype_card = "receipt"
        closingbalance_card = totalreceiptbalance_card - totalpaymentbalance_card

    closingbalance_card = round(closingbalance_card, 2)

    if request.user.is_superuser:
        all_branches = Branch.objects.filter(
            Q(branchtype="Own") | Q(branchtype="Franchise") | Q(name="WAREHOUSE")
        )
    else:
        all_branches = [request.user.userprofile.branch]

    data = {
        "sale_cash": totalsaleqs_cash,
        "purchase_cash": totalpurchaseqs_cash,
        "service_cash": totalserviceqs_cash,
        "salereturn_cash": totalsalereturnqs_cash,
        "purchasereturn_cash": totalpurchasereturnqs_cash,
        "payments_cash": totalpaymentqs_cash,
        "receipts_cash": totalreceiptqs_cash,
        "other_cash": cashbookother_cash,
        "balancetype_cash": balancetype_cash,
        "closingbalance_cash": closingbalance_cash,
        "opening_cash_balance": opening_cash_balance,
        "opening_cash_balance_type": opening_cash_balance_type,
        "sale_upi": totalsaleqs_upi,
        "purchase_upi": totalpurchaseqs_upi,
        "service_upi": totalserviceqs_upi,
        "salereturn_upi": totalsalereturnqs_upi,
        "purchasereturn_upi": totalpurchasereturnqs_upi,
        "payments_upi": totalpaymentqs_upi,
        "receipts_upi": totalreceiptqs_upi,
        "other_upi": cashbookother_upi,
        "balancetype_upi": balancetype_upi,
        "closingbalance_upi": closingbalance_upi,
        "opening_upi_balance": opening_upi_balance,
        "opening_upi_balance_type": opening_upi_balance_type,
        "sale_bank": totalsaleqs_bank,
        "purchase_bank": totalpurchaseqs_bank,
        "service_bank": totalserviceqs_bank,
        "salereturn_bank": totalsalereturnqs_bank,
        "purchasereturn_bank": totalpurchasereturnqs_bank,
        "payments_bank": totalpaymentqs_bank,
        "receipts_bank": totalreceiptqs_bank,
        "other_bank": cashbookother_bank,
        "balancetype_bank": balancetype_bank,
        "closingbalance_bank": closingbalance_bank,
        "opening_bank_balance": opening_bank_balance,
        "opening_bank_balance_type": opening_bank_balance_type,
        "sale_card": totalsaleqs_card,
        "purchase_card": totalpurchaseqs_card,
        "service_card": totalserviceqs_card,
        "salereturn_card": totalsalereturnqs_card,
        "purchasereturn_card": totalpurchasereturnqs_card,
        "payments_card": totalpaymentqs_card,
        "receipts_card": totalreceiptqs_card,
        "other_card": cashbookother_card,
        "balancetype_card": balancetype_card,
        "closingbalance_card": closingbalance_card,
        ###### added on 4/10/2024 ######
        "opening_card_balance": opening_card_balance,
        "opening_card_balance_type": opening_card_balance_type,
        ###### added on 4/10/2024 ######
        "branch_list": all_branches,
        "startdate": startdate,
        "enddate": enddate,
        "branch": branch,
    }


  

    return render(request, "cashbook.html", data)


# Accounts function end

# payment function starts here


@login_required
def payment(request):
    currentuser = request.user
    if currentuser.is_superuser:
        payment_data = Payments.objects.all()
    else:
        payment_data = Payments.objects.filter(branch=currentuser.userprofile.branch)
    return render(request, "payment.html", {"payment_data": payment_data})


def payment_form(request):
    debit_dropdown = CoASubAccounts.objects.filter(is_adminonly=False)
    cash_list = ['CASH ACCOUNT']
    debit_dropdown_new = []
    for item in debit_dropdown:
        if item.head_root.name not in cash_list:
            debit_dropdown_new.append(item)
    # Below filter filters only cash related accounts because credits in payments are always cash related
    # credit_dropdown = coa.COA_GROUP_LIST
    # credit_dropdown = CoASubAccounts.objects.all()
    # credit_dropdown = [account.head_root.name for account in credit_dropdown 
    #             if account.head_root.name in ['CASH ACCOUNT']]
    credit_dropdown = ['CASH ACCOUNT']

    return render(
        request,
        "paymentform.html",
        {"debit_dropdown": debit_dropdown_new, "credit_dropdown": credit_dropdown},
    )


def payment_details(request, id):

    data = Payments.objects.filter(paymentid=id).first()

    context = {"data": data}

    return render(request, "paymentdetails.html", context)


@login_required
def add_payment(request):
    if request.method == "POST":
        data = Payments()
        currentuser = request.user
        today_date = datetime.today().date()
        paymentdate = today_date.strftime("%Y-%m-%d")
        data.paymentdate = paymentdate
        paymentid = generate_unique_id("Payments", "PY")
        data.paymentid = paymentid
        if request.POST.get("referenceno"):
            data.referenceno = request.POST.get("referenceno")
        else:
            data.referenceno = None

        data.creditaccount = 'CASH ACCOUNT'
        debit_acc = CoASubAccounts.objects.filter(title=request.POST.get("debitaccount")).first()
        data.debitaccount = debit_acc
        data.narration = request.POST.get("narration")
        data.amount = request.POST.get("paidamount")
        data.branch = currentuser.userprofile.branch
        data.description = request.POST.get("description")
        data.paymentmode = request.POST.get("paymentmode")
        data.save()

        transaction = Transaction()
        transaction.transactionid = paymentid
        transaction.amount = float(request.POST.get("paidamount"))
        transaction.transactiontype = "payment"
        transaction.paymentmode = request.POST.get("paymentmode")
        transaction.branch = currentuser.userprofile.branch
        transaction.invoice_number = request.POST.get("referenceno")
        transaction.accounts = "NA"
        transaction.remarks = request.POST.get("description")
        transaction.transactiondate = datetime.now()
        transaction.subledger = debit_acc
        transaction.save()

        financial_statement = addaccounts.AccountStatement()

        ledger_params = {
            "id": paymentid,
            "amount": data.amount,
            "narration": data.narration,
            "userbranch": data.branch,
            "date": today_date,
            "debitac": data.debitaccount,
            "creditac": data.creditaccount,
             "paymentmode": request.POST.get("paymentmode"),
        }

        transaction_type = "Payment"
        financial_statement.add_ledger(transaction_type, ledger_params)


        general_ledger_params = {
            "id": paymentid,
            "voucherid": paymentid,
            "description": data.narration,
            "amount": data.amount,
            "userbranch": data.branch,
            "date": today_date,
            "debitac": data.debitaccount,
             "paymentmode": request.POST.get("paymentmode"),
        }
        financial_statement.add_generalledger(transaction_type, general_ledger_params)


        cashbook_params = {
            "userbranch": data.branch,
            "amount": data.amount,
            "paymentmode": data.paymentmode,
            "category": "PAYMENT",
            "branch_wid":request.user.userprofile.branch,
             'subledger' : debit_acc
        }

        financial_statement.add_cashbook(transaction_type, cashbook_params)

        # payment_ledger = ledgercli.LedgerBook(data.branch)

        # debit_coa, debit_coa_level1 = get_coa_root(data.debitaccount)
        # credit_coa, credit_coa_level1 = get_coa_root(data.creditaccount)

        # params = {
        #     "paymentdate": today_date,
        #     "narration": data.narration,
        #     "debit_head": debit_coa,
        #     "debit_coa_level1": debit_coa_level1,
        #     "debit_sub_head": data.debitaccount,
        #     "credit_head": credit_coa,
        #     "credit_coa_level1": credit_coa_level1,
        #     "credit_sub_head": data.creditaccount,
        #     "amount": data.amount,
        # }

        # payment_ledger.post_payment(**params)

    return redirect("payment")



@login_required
def payment_print(request, paymentid):
    
    branch=request.user.userprofile.branch
    company = request.user.userprofile.company
    company_name = company.company_name
    if branch.name == "WAREHOUSE":
        address_line1 = company.address_line1
        address_line2 = company.address_line2
        address_line3 = company.address_line3
        phone = ""
    else:
        address_line1 = branch.address
        phone = branch.phone
        address_line2 = ""
        address_line3 = ""
    logo = company.logo_url
    currentuser = request.user

    payment_obj = Payments.objects.filter(paymentid=paymentid).first()
    date=payment_obj.paymentdate 
    narration=payment_obj.narration
    paymentmode =payment_obj.paymentmode
    amount=payment_obj.amount
    totalworden = func_price_in_words(round(amount, 2), "en")
    totalwordar = func_price_in_words(round(amount, 2), "ar")
    

    context = {
        "logo":GLOBAL_VARIABLES["current_host"] + logo.url,
        "voucher_number":paymentid,
        "date":date,
        "narration":narration,
        "paymentmode":paymentmode,
        "amount":amount,
        "totalworden":totalworden,
        "totalwordar":totalwordar,
        
    }



    language = Language.objects.first()
    if language:
        language = language.language
    else:
        language = None

    # create a template object
    if language == "ar":
        template = get_template("paymentpdfarabic.html")
    else:
        template = get_template("paymentpdfarabic.html")
    css = os.path.join(BASE_DIR, "core", "static", "css", "salespdf.css")
  

    try:
        PAGESIZE = PageSize.objects.filter(active=True).first().size
    except:
        PAGESIZE = "A4"

    # render the context dictionary values
    html = template.render(context)
    options = {"quiet": "", "encoding": "UTF-8", "page-size": PAGESIZE}
    # generate the pdf from html
    pdf = pdfkit.from_string(html, False, options=options,css=css)
    response = HttpResponse(content_type="application/pdf")


    response["Content-Disposition"] = (
        f'inline; filename="Payment_slip_{date.today()}.pdf"'
    )
    response.write(pdf)
    return response


# Payment function ends here

# Journal Functions start here


@login_required
def journal(request):
    currentuser = request.user
    if currentuser.is_superuser:
        journal_data = Journals.objects.all()
    else:
        journal_data = Journals.objects.filter(branch=currentuser.userprofile.branch)
    return render(request, "journal.html", {"journal_data": journal_data})




def journal_form(request):
 
    all_coa = []
    db_dropdown = CoASubAccounts.objects.filter(is_adminonly=False)
    cash_list = ['CASH ACCOUNT']
    # coa_dropdown = coa.COA_GROUP_LIST
    for item in db_dropdown:
        if item.head_root.name not in cash_list:
            all_coa.append(item.title)

    # for item in coa_dropdown:
    #     if item["name"] in cash_list:
    #         all_coa.append(item["name"])
    return render(request, "journalform.html", {"all_dropdown": all_coa})


def cashtocash_form(request):
    all_coa = []
    # db_dropdown = CoASubAccounts.objects.all()
    cash_list = ['CASH ACCOUNT']
    coa_dropdown = coa.COA_GROUP_LIST
    # for item in db_dropdown:
    #     if item.head_root.name not in cash_list:
    #         all_coa.append(item.title)

    for item in coa_dropdown:
        if item["name"] in cash_list:
            all_coa.append(item["name"])
    return render(request, "cashtocashform.html", {"all_dropdown": all_coa})


def journal_details(request, id):

    data = Journals.objects.filter(journalid=id).first()

    context = {"data": data}

    return render(request, "journaldetails.html", context)


@login_required
def add_journal(request):
    if request.method == "POST":

        data = Journals()
        currentuser = request.user
        today_date = datetime.today().date()
        journaldate = today_date.strftime("%Y-%m-%d")
        data.journaldate = journaldate
        journalid = generate_unique_id("Journals", "JN")
        data.journalid = journalid
        if request.POST.get("referenceno"):
            data.referenceno = request.POST.get("referenceno")
        else:
            data.referenceno = None

        credit_acc = CoASubAccounts.objects.filter(title=request.POST.get("creditaccount")).first()
        data.creditaccount = credit_acc
        
        # data.creditaccount =credit_account
        debit_acc = CoASubAccounts.objects.filter(title=request.POST.get("debitaccount")).first()
        data.debitaccount = debit_acc
        data.narration = request.POST.get("narration")
        data.amount = request.POST.get("amount")
        data.branch = currentuser.userprofile.branch
        data.description = request.POST.get("description")
        data.mode = request.POST.get("mode")
        data.save()


        credit_account = request.POST.get("creditaccount")
        debit_account = request.POST.get("debitaccount")

        # cash_list = ['CASH ACCOUNT']

        credit_account_head_title = credit_account_head_title2 = CoASubAccounts.objects.filter(
            title=credit_account
        ).first()
        cred = credit_account_head_title
        if credit_account_head_title:
            credit_account_head_title = credit_account_head_title.title
        else:
            credit_account_head_title = credit_account

        # if debit_account in cash_list:
        #     debit_account_head_title = debit_account
        # else:

        debit_account_head_title = debit_account_head_title2 = CoASubAccounts.objects.filter(
            title=debit_account
        ).first()
        deb = debit_account_head_title
        if debit_account_head_title:
            debit_account_head_title = debit_account_head_title.title
        else:
            debit_account_head_title = debit_account


        transaction = Transaction()
        transaction.transactionid = journalid
        transaction.amount = float(request.POST.get("amount"))
        transaction.transactiontype = "journal"
        transaction.paymentmode = request.POST.get("mode")
        transaction.branch = currentuser.userprofile.branch
        transaction.invoice_number = request.POST.get("referenceno")
        transaction.accounts = debit_account_head_title
        transaction.remarks = request.POST.get("narration")
        transaction.transactiondate = datetime.now()
        transaction.subledger = deb
        transaction.save()

        transaction = Transaction()
        transaction.transactionid = journalid
        transaction.amount = float(request.POST.get("amount"))
        transaction.transactiontype = "journal"
        transaction.paymentmode = request.POST.get("mode")
        transaction.branch = currentuser.userprofile.branch
        transaction.invoice_number = request.POST.get("referenceno")
        transaction.accounts = credit_account_head_title
        transaction.remarks = request.POST.get("narration")
        transaction.transactiondate = datetime.now()
        transaction.subledger = cred
        transaction.save()

        # debit_coa, debit_coa_level1 = get_coa_root(data.debitaccount)
        # credit_coa, credit_coa_level1 = get_coa_root(data.creditaccount)

        debit_account_head = credit_account_head_title2.head_root.account_group.account_head

        credit_account_head = debit_account_head_title2.head_root.account_group.account_head

        financial_statement = addaccounts.AccountStatement()

        ledger_params = {
            "id": journalid,
            "amount": data.amount,
            "narration": data.narration,
            "userbranch": data.branch,
            "date": today_date,
            "debitac": data.debitaccount,
            "creditac": data.creditaccount,
            'paymentmode':request.POST.get("mode"),
        }

        transaction_type = "Journal"
        financial_statement.add_ledger(transaction_type, ledger_params)


        general_ledger_params = {
            "id": journalid,
            "voucherid": journalid,
            "amount": data.amount,
            "description": data.narration,
            "userbranch": data.branch,
            "date": today_date,
            "debitac": data.debitaccount,
            "creditac": data.creditaccount,
            'paymentmode':request.POST.get("mode"),
        }

        financial_statement.add_generalledger(transaction_type, general_ledger_params)


        # Determine the cash flow
        # Below logic is not 100% fool proof
        # Need to correct it
        payment_type = None
        # if debit_coa == "Assets":
        #     # Assuming cash Inflow
        #     payment_type = "Receipt"
        # elif credit_coa == "Assets":
        #     # Assuming Cash Outflow
        #     payment_type = "Payment"

        ################ COMMENDED ON 28-12-2024 ###################
        # if debit_account_head == 'ASSET':
        #     payment_type = 'Receipt'
        #     subledger = data.debitaccount
        # elif credit_account_head == 'ASSET':
        #     payment_type = 'Payment'
        #     subledger = data.creditaccount


        # cashbook_params = {
        #     "payment_type": payment_type,
        #     "userbranch": data.branch,
        #     "amount": data.amount,
        #     "mode": data.mode,
        #     "category": "JOURNAL",
        #     "branch_wid":request.user.userprofile.branch,
        #     'subledger' : subledger
        # }
        ################ COMMENDED ON 28-12-2024 ###################

        # financial_statement.add_cashbook(transaction_type, cashbook_params)

        # journal_ledger = ledgercli.LedgerBook(data.branch)

        # params = {
        #     "journaldate": today_date,
        #     "narration": data.narration,
        #     "debit_head": debit_coa,
        #     "debit_coa_level1": debit_coa_level1,
        #     "debit_sub_head": data.debitaccount,
        #     "credit_head": credit_coa,
        #     "credit_coa_level1": credit_coa_level1,
        #     "credit_sub_head": data.creditaccount,
        #     "amount": data.amount,
        # }

        # journal_ledger.post_journal(**params)

    return redirect("journal")


# Journal function ends here

# Receipt function starts here


@login_required
def receipt(request):

    currentuser = request.user
    if currentuser.is_superuser:
        receipt_data = Receipts.objects.all()
    else:
        receipt_data = Receipts.objects.filter(branch=currentuser.userprofile.branch)
    return render(request, "receipt.html", {"receipt_data": receipt_data})


def receipt_form(request):
    credit_dropdown = CoASubAccounts.objects.filter(is_adminonly=False)
    cash_list = ['CASH ACCOUNT']
    credit_dropdown_new = []
    for item in credit_dropdown:
        if item.head_root.name not in cash_list:
            credit_dropdown_new.append(item)
    # Below filter filters only cash related accounts because credits in Receipts are always cash related
    # debit_dropdown = coa.COA_GROUP_LIST
    # debit_dropdown = CoASubAccounts.objects.all()
    # debit_dropdown = [account for account in debit_dropdown 
    #             if account.head_root.name in ['CASH ACCOUNT']]
    debit_dropdown = ['CASH ACCOUNT']
    return render(
        request,
        "receiptform.html",
        {"debit_dropdown": debit_dropdown, "credit_dropdown": credit_dropdown_new},
    )


def receipt_details(request, id):

    data = Receipts.objects.filter(receiptid=id).first()

    context = {"data": data}

    return render(request, "receiptdetails.html", context)


@login_required
def add_receipt(request):
    if request.method == "POST":
        data = Receipts()
        currentuser = request.user
        today_date = datetime.today().date()
        receiptdate = today_date.strftime("%Y-%m-%d")
        data.receiptdate = receiptdate
        receiptid = generate_unique_id("Receipts", "RC")
        data.receiptid = receiptid
        if request.POST.get("referenceno"):
            data.referenceno = request.POST.get("referenceno")
        else:
            data.referenceno = None

        credit_acc = CoASubAccounts.objects.filter(title=request.POST.get("creditaccount")).first()
        data.creditaccount = credit_acc


        data.debitaccount = 'CASH ACCOUNT'
        data.narration = request.POST.get("narration")
        data.amount = request.POST.get("receivedamount")
        data.branch = currentuser.userprofile.branch
        data.description = request.POST.get("description")
        data.receiptmode = request.POST.get("receiptmode")
        data.save()

        transaction = Transaction()
        transaction.transactionid = receiptid
        transaction.amount = float(request.POST.get("receivedamount"))
        transaction.transactiontype = "receipt"
        transaction.paymentmode = request.POST.get("receiptmode")
        transaction.branch = currentuser.userprofile.branch
        transaction.invoice_number = request.POST.get("referenceno")
        transaction.accounts = "NA"
        transaction.remarks = request.POST.get("description")
        transaction.transactiondate = datetime.now()
        transaction.subledger = credit_acc
        transaction.save()

        financial_statement = addaccounts.AccountStatement()
        ledger_params = {
            "id": receiptid,
            "amount": data.amount,
            "narration": data.narration,
            "userbranch": data.branch,
            "date": today_date,
            "debitac": data.debitaccount,
            "creditac": data.creditaccount,
            "paymentmode":request.POST.get("receiptmode")
        }

        transaction_type = "Receipt"
        financial_statement.add_ledger(transaction_type, ledger_params)

        general_ledger_params = {
            "id": receiptid,
            "voucherid": receiptid,
            "description": data.narration,
            "amount": data.amount,
            "userbranch": data.branch,
            "date": today_date,
            "creditac": data.creditaccount,
            "paymentmode": request.POST.get("receiptmode"),
        }

        financial_statement.add_generalledger(transaction_type, general_ledger_params)

        cashbook_params = {
            "userbranch": data.branch,
            "amount": data.amount,
            "paymentmode": data.receiptmode,
            "category": "RECEIPT",
            "branch_wid":request.user.userprofile.branch,
            "subledger":data.creditaccount
        }

        financial_statement.add_cashbook(transaction_type, cashbook_params)


        

        # receipt_ledger = ledgercli.LedgerBook(data.branch)
        # debit_coa, debit_coa_level1 = get_coa_root(data.debitaccount)
        # credit_coa, credit_coa_level1 = get_coa_root(data.creditaccount)

        # params = {
        #     "receiptdate": today_date,
        #     "narration": data.narration,
        #     "debit_head": debit_coa,
        #     "debit_coa_level1": debit_coa_level1,
        #     "debit_sub_head": data.debitaccount,
        #     "credit_head": credit_coa,
        #     "credit_coa_level1": credit_coa_level1,
        #     "credit_sub_head": data.creditaccount,
        #     "amount": data.amount,
        # }

        # receipt_ledger.post_receipt(**params)

    return redirect("receipt")


@login_required
def receipt_print(request, receiptid):
    
    branch=request.user.userprofile.branch
    company = request.user.userprofile.company
    company_name = company.company_name
    if branch.name == "WAREHOUSE":
        address_line1 = company.address_line1
        address_line2 = company.address_line2
        address_line3 = company.address_line3
        phone = ""
    else:
        address_line1 = branch.address
        phone = branch.phone
        address_line2 = ""
        address_line3 = ""
    logo = company.logo_url
    currentuser = request.user

    receipt_obj = Receipts.objects.filter(receiptid=receiptid).first()
    date=receipt_obj.receiptdate
    narration=receipt_obj.narration
    paymentmode =receipt_obj.receiptmode
    amount=receipt_obj.amount
    totalworden = func_price_in_words(round(amount, 2), "en")
    totalwordar = func_price_in_words(round(amount, 2), "ar")
    

    context = {
        "logo":GLOBAL_VARIABLES["current_host"] + logo.url,
        "voucher_number":receiptid,
        "date":date,
        "narration":narration,
        "paymentmode":paymentmode,
        "amount":amount,
        "totalworden":totalworden,
        "totalwordar":totalwordar,
        
    }



    language = Language.objects.first()
    if language:
        language = language.language
    else:
        language = None

    # create a template object
    if language == "ar":
        template = get_template("receiptpdfarabic.html")
    else:
        template = get_template("receiptpdfarabic.html")
    css = os.path.join(BASE_DIR, "core", "static", "css", "salespdf.css")
  

    try:
        PAGESIZE = PageSize.objects.filter(active=True).first().size
    except:
        PAGESIZE = "A4"

    # render the context dictionary values
    html = template.render(context)
    options = {"quiet": "", "encoding": "UTF-8", "page-size": PAGESIZE}
    # generate the pdf from html
    pdf = pdfkit.from_string(html, False, options=options,css=css)
    response = HttpResponse(content_type="application/pdf")


    response["Content-Disposition"] = (
        f'inline; filename="Receipt_slip_{date.today()}.pdf"'
    )
    response.write(pdf)
    return response


# Receipt function ends here


# Balance Sheet starts here

# def balance_sheet(request):
#    if request.method == "POST":
#        startdate = request.POST['startdate']
#        startdate = datetime.strptime(startdate,"%d-%m-%Y")
#        enddate = request.POST['enddate']
#        enddate  = datetime.strptime(enddate ,"%d-%m-%Y")
#        if request.user.is_superuser:
#            branch = request.POST['branch']
#        else:
#            branch=request.user.userprofile.branch
#    else:
#        if request.user.is_superuser:
#            all_branches=Branch.objects.filter(Q(branchtype="Own")|Q(branchtype='Franchise')|Q(name='WAREHOUSE'))
#        else:
#            all_branches=[request.user.userprofile.branch]
#        data={"branch_list":all_branches}
#        return render (request, 'balancesheet.html', data)
#
#    branchid = Branch.objects.filter(name=branch).first()
#    ledger_asset = Ledger.objects.filter(Q(branch=branch)&Q(date__range=(startdate, enddate))&Q(account_head="ASSET"))
#    ledger_liability = Ledger.objects.filter(Q(branch=branch)&Q(date__range=(startdate, enddate))&Q(account_head="LIABILITY"))
#
#    asset_list_df = pd.DataFrame()
#    liability_list_df = pd.DataFrame()
#    asset_list_qs = []
#    liability_list_qs = []
#    liability_list_sum = 0
#    asset_list_sum = 0
#
#    if ledger_asset:
#        df_asset = pd.DataFrame.from_records(ledger_asset.values())
#        try:
#            asset_list_df = df_asset.groupby('narration')['debit_amount'].sum().reset_index()
#            asset_list_sum = asset_list_df['debit_amount'].sum()
#        except:
#            asset_list_df = pd.DataFrame()
#    if ledger_liability:
#        df_liability = pd.DataFrame.from_records(ledger_liability.values())
#        try:
#            liability_list_df = df_liability.groupby('narration')['credit_amount'].sum().reset_index()
#            liability_list_sum = liability_list_df['credit_amount'].sum()
#        except:
#            liability_list_df = pd.DataFrame()
#
#    if not asset_list_df.empty:
#        asset_list_qs = asset_list_df.to_dict('records')
#    if not liability_list_df.empty:
#        liability_list_qs = liability_list_df.to_dict('records')
#
#    zipped_qs = zip(liability_list_qs, asset_list_qs)
#
#    data = {
#            'total_liability': liability_list_sum,
#            'total_asset': asset_list_sum,
#            'zipped_qs': zipped_qs
#        }
#    return render (request, "balancesheet.html", data )


# Balance Sheet ends here


# Ledger CLI reports START


def balance_sheet(request):

    if request.method == "POST":
        startdate = request.POST["startdate"]
        startdate = datetime.strptime(startdate, "%d-%m-%Y")
        startdate = datetime.strftime(startdate, "%Y-%m-%d")
        enddate = request.POST["enddate"]
        enddate = datetime.strptime(enddate, "%d-%m-%Y")
        enddate = datetime.strftime(enddate, "%Y-%m-%d")
        if request.user.is_superuser:
            branch = request.POST["branch"]
        else:
            branch = request.user.userprofile.branch
    else:
        startdate = None
        enddate = None
        branch = request.user.userprofile.branch

    # If UI doesnt show any branch, just keep the home branch
    if not branch:
        branch = request.user.userprofile.branch

    finreport = ledgercli.FinReport(branch)
    assets, liabilities, equity = finreport.balance_sheet(startdate, enddate)
    branch = request.user.userprofile.branch
    data = {
        "assets": assets,
        "liabilities": liabilities,
        "equity": equity,
        "branch": branch,
    }
    return render(request, "balancesheet.html", {"data": data})


def l_cashbook(request):
    finreport = ledgercli.FinReport(request.user.userprofile.branch)
    data = finreport.cash_book()
    return render(request, "lcashbook.html", {"data": data})


def l_ledger(request):
    finreport = ledgercli.FinReport(request.user.userprofile.branch)
    lr = finreport.ledger_report()
    data = {
        "lr": lr,
    }
    return render(request, "lledger.html", {"data": data})


# Ledger CLI reports ENDS


@login_required
def search_money_reciept(request):

    customer_supplier_selected = request.POST.get("supplier_customer_money")
    invoice_number_selected = request.POST.get("invoice_number_money")
    payment_mode = request.POST.get("payment_mode")
    startdate = request.POST.get("startdate", None)
    enddate = request.POST.get("enddate", None)

    currentuser = request.user
    transaction = []

    filters = Q()

    if customer_supplier_selected:
        filters &= Q(accounts=customer_supplier_selected)

    if payment_mode:
        filters &= Q(paymentmode=payment_mode)

    if invoice_number_selected:
        filters &= Q(invoice_number=invoice_number_selected)

    # if startdate:
    #     start_date = datetime.strptime(startdate, "%d-%m-%Y").date()
    #     filters &= Q(createddate__gte=start_date)

    # if enddate:
    #     end_date = datetime.strptime(enddate, "%d-%m-%Y").date()
    #     filters &= Q(createddate__lte=end_date)

    if not currentuser.is_superuser:
        filters &= Q(branch=currentuser.userprofile.branch)

    if filters:
        transaction = Transaction.objects.filter(filters).order_by("-pk")

    invoicenumber_list = set()
    accounts_list = set()

    if currentuser.is_superuser:
        transactions_all = Transaction.objects.all().order_by("-pk")
    else:
        transactions_all = Transaction.objects.filter(
            branch=currentuser.userprofile.branch
        ).order_by("-pk")
    for trans in transactions_all:
        accounts_list.add(trans.accounts)
        invoicenumber_list.add(trans.invoice_number)

    transaction_list = []
    purchase_due_balance = 0
    sale_due_balance = 0
    service_due_balance = 0
    for tr in transaction:
        if tr.transactiontype == "purchase":

            transactionid = tr.transactionid

            transaction_dict = {}
            if currentuser.is_superuser:

                purchase_p = Purchase.objects.filter(purchaseid=transactionid).first()
                if not purchase_p:

                    pass
                else:
                    ###########
                    if purchase_p.duebalance:
                        purchase_due_balance += purchase_p.duebalance
                    ###########

                    invoicenumber_list.add(purchase_p.invoicenumber)
                    accounts_list.add(purchase_p.supplier.name)
                    transaction_dict["invoicenumber"] = purchase_p.invoicenumber
                    transaction_dict["accounts"] = purchase_p.supplier.name
                    transaction_dict["paymentmode"] = tr.paymentmode
                    transaction_dict["transaction"] = tr
                    transaction_dict["branch"] = tr.branch
                    transaction_dict['date'] = purchase_p.invoicedate

                

                    ###############
                    # trans_obj =Transaction.objects.filter(transactionid=purchase_p.purchaseid)
                    # is_first = False
                    # if tr==trans_obj.first():
                    #     is_first=True
                    # else:
                    #     is_first = False

                    # if is_first:
                    #     transaction_dict['createddate'] = purchase_p.invoicedate
                    # else:
                    #     transaction_dict['createddate'] = tr.createddate
                    transaction_date = tr.transactiondate
                    if transaction_date:
                        transaction_dict['createddate'] = transaction_date
                    else:
                        transaction_dict['createddate'] = tr.createddate
                    ###############

                    transaction_list.append(transaction_dict)
                purchase_b = BranchPurchase.objects.filter(
                    purchaseid=transactionid
                ).first()
                if not purchase_b:
                    pass
                else:

                    ###########
                    if purchase_b.duebalance:
                        purchase_due_balance += purchase_b.duebalance
                    ###########

                    if purchase_b.supplier == None:
                        accounts_list.add(purchase_b.externalsupplier.name)
                    else:
                        accounts_list.add(purchase_b.supplier.name)
                    transaction_dict["invoicenumber"] = purchase_b.invoicenumber
                    if purchase_b.supplier == None:
                        transaction_dict["accounts"] = purchase_b.externalsupplier.name
                    else:
                        transaction_dict["accounts"] = purchase_b.supplier.name

                    transaction_dict["paymentmode"] = tr.paymentmode
                    transaction_dict["transaction"] = tr
                    transaction_dict["branch"] = tr.branch
                    transaction_dict['date'] = purchase_b.invoicedate


                    ###############
                    # trans_obj =Transaction.objects.filter(transactionid=purchase_b.purchaseid)
                    # is_first = False
                    # if tr==trans_obj.first():
                    #     is_first=True
                    # else:
                    #     is_first = False
                   
                    # if is_first:
                    #     transaction_dict['createddate'] = purchase_b.invoicedate
                    # else:
                    #     transaction_dict['createddate'] = tr.createddate
                    transaction_date = tr.transactiondate
                    if transaction_date:
                        transaction_dict['createddate'] = transaction_date
                    else:
                        transaction_dict['createddate'] = tr.createddate
                    ###############

                    transaction_list.append(transaction_dict)

            else:
                purchase = BranchPurchase.objects.filter(
                    purchaseid=transactionid
                ).first()
                if not purchase:
                    pass
                else:

                    ###########
                    if purchase.duebalance:
                        purchase_due_balance += purchase.duebalance
                    ###########

                    invoicenumber_list.add(purchase.invoicenumber)
                    if purchase.supplier == None:
                        accounts_list.add(purchase.externalsupplier.name)
                    else:
                        accounts_list.add(purchase.supplier.name)
                    transaction_dict["invoicenumber"] = purchase.invoicenumber
                    if purchase.supplier == None:
                        transaction_dict["accounts"] = purchase.externalsupplier.name
                    else:
                        transaction_dict["accounts"] = purchase.supplier.name
                    transaction_dict["paymentmode"] = tr.paymentmode
                    transaction_dict["transaction"] = tr
                    transaction_dict["branch"] = tr.branch
                    transaction_dict['date'] = purchase.invoicedate

              

                    ###############
                    # trans_obj =Transaction.objects.filter(transactionid=purchase.purchaseid)
                    # is_first = False
                    # if tr==trans_obj.first():
                    #     is_first=True
                    # else:
                    #     is_first = False
                   
                    # if is_first:
                    #     transaction_dict['createddate'] = purchase.invoicedate
                    # else:
                    #     transaction_dict['createddate'] = tr.createddate
                    transaction_date = tr.transactiondate
                    if transaction_date:
                        transaction_dict['createddate'] = transaction_date
                    else:
                        transaction_dict['createddate'] = tr.createddate
                    ###############

                    transaction_list.append(transaction_dict)

        if tr.transactiontype == "purchasereturn":

            transactionid = tr.transactionid
            transaction_dict = {}
            if currentuser.is_superuser:

                purchase_p = PurchaseReturn.objects.filter(
                    purchasereturnid=transactionid
                ).first()
                if not purchase_p:
                    pass
                else:
                    invoicenumber_list.add(purchase_p.invoicenumber)
                    if purchase_p.supplier == None:
                        accounts_list.add(purchase_p.externalsupplier.name)
                    else:
                        accounts_list.add(purchase_p.supplier.name)
                    transaction_dict["invoicenumber"] = purchase_p.invoicenumber
                    if purchase_p.supplier == None:
                        transaction_dict["accounts"] = purchase_p.externalsupplier.name
                    else:
                        transaction_dict["accounts"] = purchase_p.supplier.name
                    transaction_dict["paymentmode"] = tr.paymentmode
                    transaction_dict["transaction"] = tr
                    transaction_dict["branch"] = tr.branch
                    transaction_dict['date'] = purchase_p.createddate

      

                    ###############
                    # trans_obj =Transaction.objects.filter(transactionid=purchase_p.purchasereturnid)
                    # is_first = False
                    # if tr==trans_obj.first():
                    #     is_first=True
                    # else:
                    #     is_first = False

                    # if is_first:
                    #     transaction_dict['createddate'] = purchase_p.createddate
                    # else:
                    #     transaction_dict['createddate'] = tr.createddate
                    transaction_date = tr.transactiondate
                    if transaction_date:
                        transaction_dict['createddate'] = transaction_date
                    else:
                        transaction_dict['createddate'] = tr.createddate
                    ###############

                    transaction_list.append(transaction_dict)

        if tr.transactiontype == "sale":

            transactionid = tr.transactionid
            transaction_dict = {}
            sale = Sale.objects.filter(saleid=transactionid).first()
            # invoicenumber_list.add(sale.invoicenumber)
            ###########
            if sale.duebalance:
                sale_due_balance += sale.duebalance
            ###########
            # accounts_list.add(sale.customer)
            transaction_dict["invoicenumber"] = sale.invoicenumber
            transaction_dict["accounts"] = sale.customer
            transaction_dict["paymentmode"] = tr.paymentmode
            transaction_dict["transaction"] = tr
            transaction_dict["branch"] = tr.branch
            transaction_dict['date'] = sale.invoicedate

        

            ###############
            # trans_obj =Transaction.objects.filter(transactionid=sale.saleid)
            # is_first = False
            # if tr==trans_obj.first():
            #     is_first=True
            # else:
            #     is_first = False

            # if is_first:
            #     transaction_dict['createddate'] = sale.invoicedate
            # else:
            #     transaction_dict['createddate'] = tr.createddate
            transaction_date = tr.transactiondate
            if transaction_date:
                transaction_dict['createddate'] = transaction_date
            else:
                transaction_dict['createddate'] = tr.createddate
            ###############

            transaction_list.append(transaction_dict)

        if tr.transactiontype == "salereturn":
            transactionid = tr.transactionid
            transaction_dict = {}
            sale = SaleReturn.objects.filter(salereturnid=transactionid).first()
            if not sale:
                pass
            else:
                invoicenumber_list.add(sale.invoicenumber)
                accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = sale.invoicenumber
                transaction_dict["accounts"] = sale.customer
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict['date'] = sale.createddate

           

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=sale.salereturnid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = sale.createddate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "expense":

            transactionid = tr.transactionid
            transaction_dict = {}
            expense = Expenses.objects.filter(expenseid=transactionid).first()
            transaction_dict["invoicenumber"] = expense.billnumber
            transaction_dict["accounts"] = ""
            transaction_dict["paymentmode"] = tr.paymentmode
            transaction_dict["transaction"] = tr
            transaction_dict["branch"] = tr.branch
            transaction_dict["remarks"] = expense.remarks
            transaction_dict['date'] = expense.expensedate

         

            ###############
            # trans_obj =Transaction.objects.filter(transactionid=expense.expenseid)
            # is_first = False
            # if tr==trans_obj.first():
            #     is_first=True
            # else:
            #     is_first = False

            # if is_first:
            #     transaction_dict['createddate'] = expense.expensedate
            # else:
            #     transaction_dict['createddate'] = tr.createddate
            transaction_date = tr.transactiondate
            if transaction_date:
                transaction_dict['createddate'] = transaction_date
            else:
                transaction_dict['createddate'] = tr.createddate
            ###############

            transaction_list.append(transaction_dict)

        if tr.transactiontype == "payment":

            transactionid = tr.transactionid
            transaction_dict = {}
            payment = Payments.objects.filter(paymentid=transactionid).first()
            if not payment:
                pass
            else:
                invoicenumber_list.add(payment.referenceno)
                # accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = payment.referenceno
                transaction_dict["accounts"] = ""
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = payment.description
                transaction_dict["branch"] = tr.branch
                transaction_dict['date'] = payment.paymentdate
           

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=payment.paymentid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = payment.paymentdate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)
        if tr.transactiontype == "receipt":

            transactionid = tr.transactionid
            transaction_dict = {}
            receipt = Receipts.objects.filter(receiptid=transactionid).first()
            if not receipt:
                pass
            else:
                invoicenumber_list.add(receipt.referenceno)
                # accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = receipt.referenceno
                transaction_dict["accounts"] = ""
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = receipt.description
                transaction_dict["branch"] = tr.branch
                transaction_dict['date'] = receipt.receiptdate

               

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=receipt.receiptid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = receipt.receiptdate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        # if tr.transactiontype == "journal":

        #     transactionid = tr.transactionid
        #     transaction_dict = {}
        #     journal = Journals.objects.filter(journalid=transactionid).first()
        #     if not journal:
        #         pass
        #     else:
        #         invoicenumber_list.add(journal.referenceno)
        #         transaction_dict["invoicenumber"] = journal.referenceno
        #         transaction_dict["accounts"] = ""
        #         transaction_dict["paymentmode"] = tr.paymentmode
        #         transaction_dict["transaction"] = tr
        #         transaction_dict["remarks"] = journal.description
        #         transaction_dict["branch"] = tr.branch
        #         transaction_dict['date'] = journal.journaldate

        #         transaction_date = tr.transactiondate
        #         if transaction_date:
        #             transaction_dict['createddate'] = transaction_date
        #         else:
        #             transaction_dict['createddate'] = tr.createddate

        #         transaction_list.append(transaction_dict)

        if tr.transactiontype == "service":

            transactionid = tr.transactionid
            transaction_dict = {}
            service = Service.objects.filter(servicerefnumber=transactionid).first()

            ###########
            if service.duebalance:
                service_due_balance += service.duebalance
            ###########

            accounts_list.add(f"{service.firstname} {service.lastname}")
            transaction_dict["invoicenumber"] = service.servicerefnumber
            transaction_dict["accounts"] = f"{service.firstname} {service.lastname}"
            transaction_dict["paymentmode"] = tr.paymentmode
            transaction_dict["transaction"] = tr
            transaction_dict["branch"] = tr.branch
            transaction_dict['date'] = service.memodate

            ###############
            # trans_obj =Transaction.objects.filter(transactionid=service.servicerefnumber)
            # is_first = False
            # if tr==trans_obj.first():
            #     is_first=True
            # else:
            #     is_first = False

            # if is_first:
            #     transaction_dict['createddate'] = service.memodate
            # else:
            #     transaction_dict['createddate'] = tr.createddate
            transaction_date = tr.transactiondate
            if transaction_date:
                transaction_dict['createddate'] = transaction_date
            else:
                transaction_dict['createddate'] = tr.createddate
            ###############

            transaction_list.append(transaction_dict)

    if startdate:
        startdate = datetime.strptime(startdate, "%d-%m-%Y").date()

    if enddate:
        enddate = datetime.strptime(enddate, "%d-%m-%Y").date()

    if startdate and enddate:
        transaction_list  = sorted(
        [
            transaction for transaction in transaction_list 
            if startdate <= transaction['createddate'] <= enddate
        ],
        key=lambda x: x['createddate'],
        reverse=True
        )
    else:
        transaction_list = sorted(
        transaction_list,
        key=lambda x: x['createddate'],
        reverse=True
    )


    

    paymentmodes = PaymentMode.objects.all()

    context = {
        "transaction": transaction_list,
        "invoicenumber_list": invoicenumber_list,
        "accounts_list": accounts_list,
        "paymentmodes": paymentmodes,
        "purchase_due_balance": purchase_due_balance,
        "sale_due_balance": sale_due_balance,
        "service_due_balance": service_due_balance,
    }

    return render(request, "moneyreciept.html", context)


# Accounts function end


# settings function


@user_passes_test(
    partial(check_permission, page="Companysettings"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def settings_view(request):
    data = {"customer_id_prefix": ""}
    customer_id_prefix = (
        UniqueIdGenerator.objects.filter(model="Customers").first().prefix
    )
    if customer_id_prefix:
        data["customer_id_prefix"] = customer_id_prefix
    countries = Country.objects.all()
    default_country = Country.objects.filter(default=True).first()
    pagesizes = PageSize.objects.all()
    data["countries"] = countries
    data["default_country"] = default_country
    data["paymentmode"] = PaymentMode.objects.all()
    data["pagesizes"] = pagesizes
    try:
        data["whatsapp_status"] = WhatsappStatus.objects.all().first().active
    except:
        data["whatsapp_status"] = None
    try:
        data["current_language"] = Language.objects.first().language
    except:
        data["current_language"] = None
    try:
        data["current_pagesize"] = PageSize.objects.filter(active=True).first().size
    except:
        data["current_pagesize"] = None
    try:
        data["company_logo_url"] = (
            GLOBAL_VARIABLES["current_host"]
            + request.user.userprofile.company.logo_url.url
        )
    except:
        data["company_logo_url"] = ""
    return render(request, "settings.html", data)


@login_required
def setdefaultcountry(request):
    try:
        country = request.POST.get("defcountry")
        country_obj = Country.objects.filter(id=int(country)).first()
        country_obj.default = True
        country_obj.save()
    except:
        pass
    return redirect("settings")


def update_whatsapp_status(request):
    user = request.user
    try:
        received_data = QueryDict(request.body)
        status = received_data.get("status")
        if status == "false":
            status = False
        elif status == "true":
            status = True
        else:
            return JsonResponse({"Response": "Something went wrong!", "status": 400})
        wppobj = WhatsappStatus.objects.all().first()
        wppobj.active = status
        wppobj.save()
        resp = {"Response": "Whatsapp status changed successfully", "status": 200}
    except:
        resp = {"Response": "Something went wrong!", "status": 500}

    return JsonResponse(resp)


@login_required
def editcustomeridprefix(request):
    if request.method == "POST":
        prefix = request.POST.get("prefix")
        obj = UniqueIdGenerator.objects.filter(model="Customers").first()
        obj.prefix = prefix
        obj.save()
    return redirect("customersettings")


@user_passes_test(
    partial(check_permission, page="Customersettings"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def customerSettings(request):
    data = {"customer_id_prefix": ""}
    customer_id_prefix = (
        UniqueIdGenerator.objects.filter(model="Customers").first().prefix
    )
    if customer_id_prefix:
        data["customer_id_prefix"] = customer_id_prefix
    return render(request, "customersettings.html", data)


@login_required
def editCompanyDetails(request):
    if request.method == "POST":
        company_id = int(request.POST.get("company_id"))
        company_name = request.POST.get("company_name")
        address_line1 = request.POST.get("address_line1")
        address_line2 = request.POST.get("address_line2")
        address_line3 = request.POST.get("address_line3")
        try:
            logo = request.FILES["logo"]
        except:
            logo = None
        country_id = request.POST.get("country")

        company = Company.objects.filter(id=company_id).first()
        if logo:
            fs = FileSystemStorage()
            logo = compress_image(logo)
            name = fs.save(logo.name, logo)
            logo_url = fs.url(name)
            # company.logo_url =logo_url
            company.logo_url = name

        company.company_name = company_name
        company.address_line1 = address_line1
        company.address_line2 = address_line2
        company.address_line3 = address_line3
        company.country = Country.objects.filter(id=int(country_id)).first()
        company.save()
    return redirect("settings")


@user_passes_test(
    partial(check_permission, page="Servicesettings"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def serviceSettings(request):

    countries = Country.objects.all()
    cities = City.objects.all()
    products = ServiceProduct.objects.all()
    brands = PhoneBrand.objects.all()
    modals = PhoneModal.objects.all()
    serviceissues = ServiceIssues.objects.all()
    charges = ServiceCharge.objects.all()
    rack_nos = Rack.objects.filter(branch=request.user.userprofile.branch)
    servicetax = ServiceTax.objects.all().first()
    url = LiveStreamUrl.objects.all().first()

    context = {
        "countries": countries,
        "cities": cities,
        "brands": brands,
        "modals": modals,
        "issues": serviceissues,
        "charges": charges,
        "racks": rack_nos,
        "servicetax": servicetax,
        "products": products,
        "url": url,
    }
    return render(request, "servicesettings.html", context)


def editServiceTax(request):
    tax = request.POST["tax"]
    if tax:
        tax = float(tax)
    serv_tax = ServiceTax.objects.all().first()
    serv_tax.tax = tax
    serv_tax.save()
    return render(request, "servicesettings.html", context)


@login_required
def addRack(request):

    name = request.POST["rack"]
    rack_obj = Rack()
    rack_obj.name = name
    rack_obj.branch = request.user.userprofile.branch
    rack_obj.save()

    return redirect("servicesettings")


# @login_required
def get_brands_by_product(request):
    user = request.user

    received_data = QueryDict(request.body)
    productid = received_data.get("id")

    modal_obj = PhoneBrand.objects.filter(product_id=int(productid))

    resp = []
    if modal_obj:
        for item in modal_obj:
            dic = {}
            dic["id"] = item.id
            dic["name"] = item.name
            resp.append(dic)

    return JsonResponse(resp, safe=False)


@login_required
def deleteRack(request, id):

    rack = Rack.objects.filter(id=id).first()
    rack.delete()

    return redirect("servicesettings")


@login_required
def addPaymentMode(request):

    name = request.POST["paymentmode"]
    pm_obj = PaymentMode()
    pm_obj.name = name
    pm_obj.save()

    return redirect("settings")


@login_required
def deletePaymentMode(request, id):

    pm = PaymentMode.objects.filter(id=id).first()
    pm.delete()

    return redirect("settings")


@login_required
def addCountry(request):

    try:
        name = request.POST["country"]
        calling_code = request.POST["calling_code"]
        digits = request.POST["digits"]
        currency_code = request.POST["currencycode"]
        unique_id = generate_unique_id("Country", "CNT")

        countryobj = Country()
        countryobj.name = name
        countryobj.code = unique_id
        countryobj.calling_code = calling_code
        countryobj.phone_number_digit = int(digits)
        countryobj.currency = currency_code
        countryobj.save()
    except:
        messages.error(request, f"Something went wrong!")

    return redirect("servicesettings")


@login_required
def deleteCountry(request, id):

    country = Country.objects.filter(id=id).first()
    country.delete()

    return redirect("servicesettings")


@login_required
def addPhoneBrand(request):
    try:
        name = request.POST["brand"]
        arabic_name = request.POST.get("brand_arabic")
        product_id = request.POST["product"]
        product = ServiceProduct.objects.filter(id=int(product_id)).first()
        unique_id = generate_unique_id("PhoneBrand", "PB")

        pb = PhoneBrand()
        pb.name = name
        pb.code = unique_id
        pb.product = product
        pb.arabic_name = arabic_name
        pb.save()
    except:
        messages.error(request, f"Something went wrong!")

    return redirect("servicesettings")


@login_required
def get_phone_brand_by_id(request):

    received_data = QueryDict(request.body)

    phone_brand_id = received_data.get("id")

    sp_obj = PhoneBrand.objects.filter(id=int(phone_brand_id)).first()

    response_data = {
        "id": sp_obj.id,
        "name": sp_obj.name,
        "code": sp_obj.code,
        "arabic_name": sp_obj.arabic_name,
    }

    return JsonResponse(response_data)


@login_required
def get_service_issue_by_id(request):

    received_data = QueryDict(request.body)

    service_issue_id = received_data.get("id")

    sp_obj = ServiceIssues.objects.filter(id=int(service_issue_id)).first()

    response_data = {
        "id": sp_obj.id,
        "name": sp_obj.name,
        "code": sp_obj.code,
        "arabic_name": sp_obj.arabic_name,
    }

    return JsonResponse(response_data)


@login_required
def editphonebrand(request):
    try:
        name = request.POST["brand_edit"]
        arabic_name = request.POST.get("brand_arabic_edit")
        brand_id = request.POST.get("brand_id_edit")
        pb = PhoneBrand.objects.filter(id=int(brand_id)).first()
        if name:
            pb.name = name
        if arabic_name:
            pb.arabic_name = arabic_name
        pb.save()
    except:
        messages.error(request, f"Something went wrong!")
    return redirect("servicesettings")


@login_required
def editissue(request):
    try:
        name = request.POST["issue"]
        arabic_name = request.POST.get("issue-arabic")
        issue_id = request.POST.get("issue-id")
        si = ServiceIssues.objects.filter(id=int(issue_id)).first()
        if name:
            si.name = name
        if arabic_name:
            si.arabic_name = arabic_name
        si.save()
    except:
        messages.error(request, f"Something went wrong!")
    return redirect("servicesettings")


@login_required
def addServiceProduct(request):
    try:
        name = request.POST["product"]
        arabic_name = request.POST.get("product_arabic")

        unique_id = generate_unique_id("ServiceProduct", "SP")

        pb = ServiceProduct()
        pb.name = name
        pb.code = unique_id
        pb.arabic_name = arabic_name
        pb.save()
    except:
        messages.error(request, f"Something went wrong!")

    return redirect("servicesettings")


@login_required
def deleteServiceProduct(request, id):

    sp = ServiceProduct.objects.filter(id=id).first()
    sp.delete()

    return redirect("servicesettings")


@login_required
def get_service_product_by_id(request):

    received_data = QueryDict(request.body)

    service_product_id = received_data.get("id")

    sp_obj = ServiceProduct.objects.filter(id=int(service_product_id)).first()

    response_data = {
        "id": sp_obj.id,
        "name": sp_obj.name,
        "code": sp_obj.code,
        "arabic_name": sp_obj.arabic_name,
    }

    return JsonResponse(response_data)


@login_required
def editserviceproduct(request):

    try:
        name = request.POST.get("product_edit")
        arabic_name = request.POST.get("product_arabic_edit")
        prod_id = request.POST.get("product_id_edit")

        pb = ServiceProduct.objects.filter(id=int(prod_id)).first()
        if name:
            pb.name = name
        if arabic_name:
            pb.arabic_name = arabic_name
        pb.save()
    except:
        messages.error(request, f"Something went wrong!")

    return redirect("servicesettings")


@login_required
def deletePhoneBrand(request, id):

    # product_id = request.POST['product']
    # product = ServiceProduct.objects.filter(id=int(product_id)).first()
    phonebrand = PhoneBrand.objects.filter(id=id).first()
    phonebrand.delete()

    return redirect("servicesettings")


@login_required
def addPhoneModal(request):
    try:
        name = request.POST["modal"]
        arabic_name = request.POST.get("modal_arabic")
        brand = request.POST["brand"]
        product_id = request.POST["product"]
        product = ServiceProduct.objects.filter(id=int(product_id)).first()
        unique_id = generate_unique_id("PhoneModal", "PM")

        pb = PhoneModal()
        pb.brand = PhoneBrand.objects.filter(id=int(brand)).first()
        pb.name = name
        pb.code = unique_id
        pb.product = product
        pb.arabic_name = arabic_name
        pb.save()
    except:
        messages.error(request, f"Something went wrong!")

    return redirect("servicesettings")


@login_required
def get_phone_modal_by_id(request):

    received_data = QueryDict(request.body)

    phone_modal_id = received_data.get("id")

    sp_obj = PhoneModal.objects.filter(id=int(phone_modal_id)).first()

    response_data = {
        "id": sp_obj.id,
        "name": sp_obj.name,
        "code": sp_obj.code,
        "arabic_name": sp_obj.arabic_name,
    }

    return JsonResponse(response_data)


@login_required
def editphonemodal(request):
    try:
        name = request.POST.get("modal_edit")
        arabic_name = request.POST.get("modal_arabic_edit")
        modal_id = request.POST.get("modal_id_edit")

        pb = PhoneModal.objects.filter(id=int(modal_id)).first()

        if name:
            pb.name = name
        if arabic_name:
            pb.arabic_name = arabic_name
        pb.save()
    except:
        messages.error(request, f"Something went wrong!")

    return redirect("servicesettings")


@login_required
def deletePhoneModal(request, id):

    phonemodal = PhoneModal.objects.filter(id=id).first()
    phonemodal.delete()

    return redirect("servicesettings")


@login_required
def editservicetax(request):
    tax = request.POST["tax"]

    if tax:
        serv_tax = ServiceTax.objects.all().first()
        if serv_tax:
            serv_tax.tax = tax
            serv_tax.save()
    return redirect("servicesettings")


@login_required
def addIssues(request):
    # try:
    issue = request.POST["issue"]
    arabic_name = request.POST["issues-arabic"]

    unique_id = generate_unique_id("ServiceIssues", "SI")

    si = ServiceIssues()
    si.name = issue
    si.code = unique_id
    si.arabic_name = arabic_name
    si.save()
    # except:
    #     messages.error(request, f"Something went wrong!")
    return redirect("servicesettings")


@login_required
def deleteIssues(request, id):

    si = ServiceIssues.objects.filter(id=id).first()
    si.delete()

    return redirect("servicesettings")


@login_required
def addCity(request):
    try:
        countryid = request.POST["country"]
        city = request.POST["city"]

        unique_id = generate_unique_id("City", "CT")

        ct = City()
        ct.name = city
        ct.code = unique_id
        ct.country = Country.objects.filter(id=int(countryid)).first()
        ct.save()
    except:
        messages.error(request, f"Something went wrong!")

    return redirect("servicesettings")


@login_required
def deleteCity(request, id):

    ct = City.objects.filter(id=id).first()
    ct.delete()

    return redirect("servicesettings")


@login_required
def saveServiceCharge(request):
    try:

        brand = PhoneBrand.objects.filter(id=int(request.POST["brand"])).first()
        modal = PhoneModal.objects.filter(id=int(request.POST["modal"])).first()
        issue = ServiceIssues.objects.filter(id=int(request.POST["issue"])).first()

        product = ServiceProduct.objects.filter(id=int(request.POST["product"])).first()
        charge = float(request.POST["charge"])

        service_charge = ServiceCharge()
        service_charge.brand = brand
        service_charge.modal = modal
        service_charge.issue = issue
        service_charge.charge = charge
        service_charge.product = product
        service_charge.save()
    except:
        messages.error(request, f"Something went wrong!")

    return redirect("servicesettings")


@login_required
def deleteServiceCharge(request, id):

    sc = ServiceCharge.objects.filter(id=id).first()
    sc.delete()

    return redirect("servicesettings")


@login_required
def get_phone_modals(request):

    received_data = QueryDict(request.body)
    brandid = received_data.get("brandid")

    # brand=None
    try:
        brand = PhoneBrand.objects.filter(id=int(brandid)).first()
    except:
        return JsonResponse({"Response": "error"})

    if brand:
        modals = PhoneModal.objects.filter(brand=brand)
    else:
        return JsonResponse({"Response": "error"})

    resp = []
    for item in modals:
        data = {}
        data["modal"] = item.name
        data["id"] = item.id
        data["code"] = item.code
        resp.append(data)
    return JsonResponse({"Response": resp})


@login_required
def get_service_charge(request):
    received_data = QueryDict(request.body)
    brandid = received_data.get("brandid")
    modalid = received_data.get("modalid")
    problemid = received_data.get("problemid")
    productid = received_data.get("productid")

    try:
        brand = PhoneBrand.objects.filter(id=int(brandid)).first()
    except:
        return JsonResponse({"Response": "error"})

    try:
        issue = ServiceIssues.objects.filter(id=int(problemid)).first()
    except:
        return JsonResponse({"Response": "error"})

    try:
        modal = PhoneModal.objects.filter(id=int(modalid)).first()
    except:
        return JsonResponse({"Response": "error"})
    try:
        product = ServiceProduct.objects.filter(id=int(productid)).first()
    except:
        return JsonResponse({"Response": "error"})

    default_charge = 0
    try:
        service_charge = ServiceCharge.objects.filter(
            Q(brand=brand) & Q(modal=modal) & Q(issue=issue) & Q(product=product)
        ).first()
    except:
        return JsonResponse({"Response": "error"})

    if service_charge:
        service_charge = service_charge.charge
    else:
        service_charge = default_charge

    return JsonResponse({"Response": service_charge})


# end of settings function


# Customers functions


@user_passes_test(
    partial(check_permission, page="Customerlist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def customers(request):
    currentuser = request.user
    if currentuser.is_superuser:
        data = Customers.objects.all()
    elif currentuser.userprofile.role == "Field Engineer":
        data = Customers.objects.filter(addedby=currentuser)
    elif (
        currentuser.userprofile.role == "Branch Admin"
        or currentuser.userprofile.role == "Franchise Admin"
    ):
        data = Customers.objects.filter(branch=currentuser.userprofile.branch)
    else:
        data = Customers.objects.filter(addedby=currentuser)

    try:
        branch = list(set([i.branch for i in data]))
    except:
        branch = []
    try:
        addedby = list(set([i.addedby for i in data]))
    except:
        addedby = []
    context = {"data": data, "branch": branch, "addedby": addedby, "user": currentuser}
    return render(request, "customers.html", context)


@login_required
def search_customers(request):

    try:
        customer_list_branch = request.POST.get("customer_list_branch")
    except:
        customer_list_branch = None
    try:
        customer_list_fieldengineer = request.POST["customer_list_fieldengineer"]
    except:
        customer_list_fieldengineer = None

    branch_obj = Branch.objects.filter(name=customer_list_branch).first()
    user_obj = User.objects.filter(username=customer_list_fieldengineer).first()

    currentuser = request.user
    if customer_list_branch and customer_list_fieldengineer:

        data = Customers.objects.filter(
            Q(branch=branch_obj) & Q(addedby=user_obj)
        ).order_by("-pk")
    elif customer_list_branch:

        data = Customers.objects.filter(branch=branch_obj).order_by("-pk")
    elif customer_list_fieldengineer:

        data = Customers.objects.filter(
            Q(branch=currentuser.userprofile.branch) & Q(addedby=user_obj)
        ).order_by("-pk")

    try:
        branch = list(set([i.branch for i in Customers.objects.all()]))
    except:
        branch = []

    if currentuser.is_superuser:
        data_2 = Customers.objects.all()
    else:
        data_2 = Customers.objects.filter(branch=currentuser.userprofile.branch)
    try:
        addedby = list(set([i.addedby for i in data_2]))
    except:
        addedby = []
    context = {"data": data, "branch": branch, "addedby": addedby, "user": currentuser}
    return render(request, "customers.html", context)


@user_passes_test(
    partial(check_permission, page="Customerform"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def customerform(request):
    context = {}
    return render(request, "addcustomer.html", context)


# @no_technician
@login_required
def addcustomer(request):

    data = Customers()
    data.firstname = request.POST["firstname"]
    data.lastname = request.POST["lastname"]
    data.phone = request.POST["phone"]
    data.phonemodel = request.POST["phonemodel"]
    unique_id = generate_unique_id("Customers", "MAGNUS")
    data.unique_id = unique_id
    if request.POST["purchasedate"]:
        data.purchasedate = request.POST["purchasedate"]
    if request.POST["dob"]:
        data.dob = request.POST["dob"]
    data.address = request.POST["address"]
    data.addedby = request.user
    data.branch = request.user.userprofile.branch
    try:
        data.save()
    except IntegrityError as e:
        messages.error(request, f"Phone number already exists.")
        return redirect("customerform")
    except:
        messages.error(request, f"An error occured.")
        return redirect("customerform")

    cust_obj = Customers.objects.filter(unique_id=unique_id).first()
    if cust_obj:
        func_create_customer_ledger(cust_obj,unique_id,request)


    return HttpResponseRedirect("/customers")


@login_required
def editcustomer(request, id):
    data = Customers.objects.get(id=id)
    context = {
        "data": data,
    }
    return render(request, "customeredit.html", context)


@login_required
def updatecustomer(request, id):
    data = Customers.objects.get(id=id)
    phonenumber = data.phone
    data.firstname = request.POST["firstname"]
    data.lastname = request.POST["lastname"]
    data.phone = request.POST["phone"]
    data.phonemodel = request.POST["phonemodel"]
    if request.POST["vatnumber"] != "" and request.POST["vatnumber"] != None:
        data.vatnumber = request.POST["vatnumber"]

    if request.POST["customertype"] != "" and request.POST["customertype"] != None:
        data.customertype = request.POST["customertype"]

    if request.POST["purchasedate"]:
        data.purchasedate = request.POST["purchasedate"]
    else:
        data.purchasedate = None
    if request.POST["dob"]:
        data.dob = request.POST["dob"]
    else:
        data.dob = None
    data.address = request.POST["address"]
    data.addedby = request.user
    data.branch = request.user.userprofile.branch
    try:
        data.save()
    except IntegrityError as e:
        if phonenumber != request.POST["phone"]:
            messages.error(request, "Phone number already exists.")
            return redirect(reverse("editcustomer", kwargs={"id": id}))
        else:
            data.save()

    return redirect(reverse("customerview", kwargs={"cid": id}))


@user_passes_test(
    partial(check_permission, page="Customerview"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def customerview(request, cid):
    data = Customers.objects.get(id=cid)
    context = {
        "data": data,
    }
    return render(request, "customerview.html", context)


@login_required
def exportcustomer(request):
    row = 0
    col = 0
    customerlist = range(0, 7)
    data = Customers.objects.all()
    buffer = io.BytesIO()
    workbook = xlsxwriter.Workbook(buffer)
    worksheet = workbook.add_worksheet()
    worksheet.write(row, 0, "FIRST NAME")
    worksheet.write(row, 1, "LAST NAME")
    worksheet.write(row, 2, "PHONE")
    worksheet.write(row, 3, "ADDRESS")
    worksheet.write(row, 4, "PHONE MODEL")
    worksheet.write(row, 5, "BRANCH")
    worksheet.write(row, 6, "FIELD EXECUTIVE")
    for item in data:
        branch = str(item.branch)
        addedby = str(item.addedby)
        customerdata = [
            item.firstname,
            item.lastname,
            item.phone,
            item.address,
            item.phonemodel,
            branch,
            addedby,
        ]
        for itemcustomer in customerlist:
            worksheet.write(row + 1, col + itemcustomer, customerdata[itemcustomer])
        row += 1
    workbook.close()
    buffer.seek(0)
    return FileResponse(buffer, as_attachment=True, filename="report.xlsx")


@login_required
def deletecustomer(request, id):
    data = Customers.objects.filter(id=id).first()
    data.delete()
    return redirect("customers")


@user_passes_test(
    partial(check_permission, page="Multiplecustomerform"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def addMultipleCustomersForm(request):
    if request.method == "POST":
        csv = request.FILES.get("multicustomers")
        if csv == None or csv == "":
            return render(
                request,
                "addmulticustomers.html",
                {
                    "error": None,
                },
            )
        df = pd.read_csv(csv)
        not_saved = []

        for i, j in enumerate(df["First Name"]):

            try:
                if df["Customer Type"][i] != "B2C" and df["Customer Type"][i] != "B2B":
                    not_saved.append(
                        f"{j} {df['Last Name'][i]} (Mobile Number:{df['Mobile Number'][i]})"
                    )
                    continue
                if j == "" or pd.isna(j):
                    not_saved.append(
                        f"{j} {df['Last Name'][i]} (Mobile Number:{df['Mobile Number'][i]})"
                    )
                    continue
                if df["Mobile Number"][i] == "" or pd.isna(df["Mobile Number"][i]):
                    not_saved.append(
                        f"{j} {df['Last Name'][i]} (Mobile Number:{df['Mobile Number'][i]})"
                    )
                    continue
                try:
                    purchasedate = datetime.strptime(
                        df["Mobile Purchase Date"][i], "%d/%m/%Y"
                    ).strftime("%Y-%m-%d")
                except:
                    purchasedate = None
                try:
                    dob = datetime.strptime(
                        df["Date Of Birth"][i], "%d/%m/%Y"
                    ).strftime("%Y-%m-%d")
                except:
                    dob = None
                customer_object = Customers(
                    firstname=j,
                    lastname=df["Last Name"][i],
                    phone=df["Mobile Number"][i],
                    phonemodel=df["Phone Modal"][i],
                    purchasedate=purchasedate,
                    dob=dob,
                    address=df["Address"][i],
                    addedby=request.user,
                    branch=request.user.userprofile.branch,
                    vatnumber=df["VAT Number"][i],
                    customertype=df["Customer Type"][i],
                    unique_id=generate_unique_id("Customers", "MAGNUS"),
                )
                customer_object.save()
            except:
                not_saved.append(
                    f"{j} {df['Last Name'][i]} (Mobile Number:{df['Mobile Number'][i]})"
                )
        if len(not_saved) == 0:
            return redirect("customers")
        else:
            return render(
                request,
                "addmulticustomers.html",
                {
                    "error": not_saved,
                },
            )
    return render(
        request,
        "addmulticustomers.html",
        {
            "error": None,
        },
    )


@login_required
def downloadCustomerFormCsv(request):
    current_directory = os.path.dirname(os.path.abspath(__file__))
    csv_filepath = os.path.join(
        current_directory, "static", "files", "AddMultipleEntries.csv"
    )
    response = FileResponse(open(csv_filepath, "rb"), content_type="text/csv")
    response["Content-Disposition"] = 'attachment; filename="AddMultipleEntries.csv"'
    return response


# end of customers functions


# Service functions start here


@login_required
def serviceChat(request):
    serviceref = request.POST["serviceref"]
    message = request.POST["message"]

    chat_obj = ServiceChat()
    chat_obj.service = Service.objects.filter(servicerefnumber=serviceref).first()
    chat_obj.chat_message = message
    chat_obj.user = request.user
    chat_obj.save()

    return redirect(reverse("servicecalllogs", kwargs={"serviceref": serviceref}))


@user_passes_test(
    partial(check_permission, page="Serviceprint"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def serviceprint(request, serviceref):
    action = None

    if request.method == "POST":
        if request.POST["flexRadioDefault"] == "order":
            action = "order"
        elif request.POST["flexRadioDefault"] == "invoice":
            action = "invoice"

    serviceobj = Service.objects.filter(servicerefnumber=serviceref).first()
    firstname = serviceobj.firstname
    lastname = serviceobj.lastname
    customerid = serviceobj.customerid
    phone_customer = serviceobj.phone
    expecteddate = serviceobj.expecteddate
    servicecharge = serviceobj.servicecharge
    estimatedprice = serviceobj.finalamount
    totalamount = serviceobj.totalamount
    discount = serviceobj.discount
    amountrecieved = serviceobj.amountrecieved
    duebalance = serviceobj.duebalance
    product = serviceobj.product
    brand = serviceobj.brand
    modal = serviceobj.model
    malfunction = serviceobj.problem
    currentdate = date.today()
    imei = serviceobj.imei
    address_customer = serviceobj.address
    invoicenumber = serviceobj.invoicenumber
    discountmethod = serviceobj.discountmethod
    discountperc = serviceobj.discountpercentage

    if serviceobj.image1:
        image1 = GLOBAL_VARIABLES["current_host"] + serviceobj.image1.url
    else:
        image1 = ""
    if serviceobj.image2:
        image2 = GLOBAL_VARIABLES["current_host"] + serviceobj.image2.url
    else:
        image2 = ""
    if serviceobj.image3:
        image3 = GLOBAL_VARIABLES["current_host"] + serviceobj.image3.url
    else:
        image3 = ""
    if serviceobj.image4:
        image4 = GLOBAL_VARIABLES["current_host"] + serviceobj.image4.url
    else:
        image4 = ""
    if serviceobj.image5:
        image5 = GLOBAL_VARIABLES["current_host"] + serviceobj.image5.url
    else:
        image5 = ""
    if serviceobj.image6:
        image6 = GLOBAL_VARIABLES["current_host"] + serviceobj.image6.url
    else:
        image6 = ""

    branch = serviceobj.branch

    if serviceobj.totaltax == None or serviceobj.totaltax == "":
        totaltax = 0
    else:
        totaltax = serviceobj.totaltax

    if serviceobj.servicetax == None or serviceobj.servicetax == "":
        servicetax = 0
    else:
        servicetax = serviceobj.servicetax

    company = request.user.userprofile.company
    company_name = company.company_name
    if branch.name == "WAREHOUSE":
        address_line1 = company.address_line1
        address_line2 = company.address_line2
        address_line3 = company.address_line3
        phone = ""
    else:
        address_line1 = branch.address
        phone = branch.phone
        address_line2 = ""
        address_line3 = ""
    logo = company.logo_url
    currentuser = request.user
    barcode_image_url = None
    barcode_base64 = ""
    if action == "order":

        barcode_number = serviceobj.barcode_number
        writer_options = {
            "module_width": 0.3,
            "module_height": 10.0,
            "font_size": 12,
            "text_distance": 5.0,
            "center_text": True,
        }
        barcode_bytes_io = BytesIO()
        barcode_format = barcode.get_barcode_class("code128")
        my_barcode = barcode_format(barcode_number, writer=ImageWriter()).write(
            barcode_bytes_io, options=writer_options
        )
        barcode_bytes_io.seek(0)
        barcode_image_bytes = barcode_bytes_io.getvalue()
        barcode_base64 = base64.b64encode(barcode_image_bytes).decode()

    if action == "invoice":
        customertype = serviceobj.customertype
        customer = f"{firstname} {lastname}"
        if customertype == "B2B":
            vatnumber = serviceobj.customer_gst_number
        else:
            vatnumber = ""
    else:
        customertype = ""
        customer = ""
        vatnumber = ""

    # total_wo_discount = round(totalamount, 2) + (
    #     round(servicecharge * (servicetax / 100), 2)
    # )

    # total_tax_amount = (round(servicecharge * (servicetax / 100), 2))

    total_wo_discount = round(totalamount, 2) + (
        round((round(servicecharge / (1 + servicetax / 100), 2)) * (servicetax/100),2)
    )

    total_tax_amount = round((round(servicecharge / (1 + servicetax / 100), 2)) * (servicetax/100),2)

    ###### spare tax calculation 11/10/2024 ###########

    ##### 25/10/2024 #####

    discount_dict = {
        "discount":'',
        "total_excl_tax":'',
        "total_tx":'',
        "tot":'',
        'total_excl_tax_afterdic':'',
        "total_tx_afterdisc":'',
        "total_excl_tax_beforedic":'',
        "total_tx_beforedisc":'',
        "tot_beforedisc":'' ,
        'total_tx_beforedisc':''
    }
    if round(discount, 2) > 0:
        sparecostafter_discount_excltax=0
        sparetax_afterdiscount=0
        servivcecost_excltax_beforediscount = 0
        servicetaxtotal_beforediscount = 0
        service_cost_afterdiscount = 0
        servicetax_aftrdiscount = 0
        spare_tx_total_beforediscount = 0
        spare_total_beforediscount = 0
        servicediscountobj =ServiceDiscountDetails.objects.filter(servicerefnumber=serviceref).first()
        if servicediscountobj:
            sparecostafter_discount_excltax = servicediscountobj.sparetotal_excltax_afterdiscount 
            sparetax_afterdiscount=servicediscountobj.sparetaxtotal_afterdiscount
            servivcecost_excltax_beforediscount =servicediscountobj.servivcecost_excltax_beforediscount 
            servicetaxtotal_beforediscount=servicediscountobj.servicetaxtotal_beforediscount
            service_cost_afterdiscount = servicediscountobj.servivcecost_excltax_afterdiscount
            servicetax_aftrdiscount = servicediscountobj.servicetaxtotal_afterdiscount
            spare_obj = SpareParts.objects.filter(servicerefnumber=serviceref)
            for item in spare_obj:
                tx= (item.price * (float(item.salegst)/100)) * item.totalquantity
                spare_tx_total_beforediscount += tx
                ttl = item.price * item.totalquantity
                spare_total_beforediscount += ttl

        total_excl_tax_afterdic = sparecostafter_discount_excltax + service_cost_afterdiscount
        total_tx_afterdisc = sparetax_afterdiscount + servicetax_aftrdiscount

        total_excl_tax_beforedic = servivcecost_excltax_beforediscount + spare_total_beforediscount
        total_tx_beforedisc = servicetaxtotal_beforediscount + spare_tx_total_beforediscount
        tot_beforedisc = total_excl_tax_beforedic + total_tx_beforedisc
     
        discou='yes'
        
        discount_dict['discount'] = discou
        discount_dict['total_excl_tax_afterdic'] = total_excl_tax_afterdic
        discount_dict['total_tx_afterdisc'] = total_tx_afterdisc
        discount_dict['total_excl_tax_beforedic'] = total_excl_tax_beforedic
        discount_dict['tot_beforedisc'] = tot_beforedisc
        discount_dict['total_tx_beforedisc'] = total_tx_beforedisc
    else:
        service_costt_incltx = servicecharge
        servicetax_a = total_tax_amount
        service_costt_excltx = servicecharge - total_tax_amount
        
        spare_tx_total_beforediscount = 0
        spare_total_beforediscount = 0
        spare_obj = SpareParts.objects.filter(servicerefnumber=serviceref)
        for item in spare_obj:
            tx= (item.price * (float(item.salegst)/100)) * item.totalquantity
            spare_tx_total_beforediscount += tx
            ttl = item.price * item.totalquantity
            spare_total_beforediscount += ttl

        total_excl_tax = spare_total_beforediscount + service_costt_excltx
        
        total_tx = spare_tx_total_beforediscount + servicetax_a
        tot = total_excl_tax + total_tx
        discou='no'

        discount_dict['discount'] = discou
        discount_dict['total_excl_tax'] =total_excl_tax
        discount_dict['total_tx'] = total_tx
        discount_dict['tot'] = tot

    
  
    ######################

    spare_obj = SpareParts.objects.filter(servicerefnumber=serviceref)
    spare_tx = 0
    for item in spare_obj:
        tx= (item.price * (float(item.salegst)/100)) * item.totalquantity
        spare_tx += tx
    totaltax =totaltax + round(spare_tx,2)

    ###### 25/10/2024 ######
    if round(discount, 2) > 0:
        totaltax = total_tx_afterdisc
    else:
        totaltax = total_tx

    ###################################################

    totalworden = func_price_in_words(round(estimatedprice, 2), "en")
    totalwordar = func_price_in_words(round(estimatedprice, 2), "ar")

    finalamount = round(estimatedprice, 2)
    totaltax = round(totaltax, 2)
    invoicedate  = serviceobj.invoicedate
    qrcode_base64 = func_generate_invoice_qrcode(finalamount,totaltax,invoicedate)


    total_excluding_tax = totalamount - totaltax

    context = {
        "discountdict":discount_dict,
        "total_excluding_tax":total_excluding_tax,
        "invoicedate":invoicedate,
        'qrcode_base64':qrcode_base64,
        "invoicenumber":invoicenumber,
        "totalworden": totalworden,
        "totalwordar": totalwordar,
        "total_wo_discount": total_wo_discount,
        "total_tax_amount":total_tax_amount,
        "billmode": serviceobj.paymentmode,
        "customer": customer,
        "vatnumber": vatnumber,
        "customertype": customertype,
        "servicetax": servicetax,
        "servicecharge": servicecharge,
        "totalamount": round(totalamount, 2),
        "totaltax": round(totaltax, 2),
        "finalamount": round(estimatedprice, 2),
        "discount": round(discount, 2),
        "amountrecieved": round(amountrecieved, 2),
        "duebalance": round(duebalance, 2),
        "product": product,
        "customerid": customerid,
        "phone": phone,
        "price": round(estimatedprice, 2),
        "estimateddate": expecteddate,
        "firstname": firstname,
        "lastname": lastname,
        "serviceref": serviceref,
        "brand": brand,
        "modal": modal,
        "malfunction": malfunction,
        "company_name": company_name,
        "address_line1": address_line1,
        "address_line2": address_line2,
        "address_line3": address_line3,
        "logo": GLOBAL_VARIABLES["current_host"] + logo.url,
        "currentdate": currentdate,
        "imei": imei,
        "barcode": barcode_base64,
        "image1": image1,
        "image2": image2,
        "image3": image3,
        "image4": image4,
        "image5": image5,
        "image6": image6,
        "phone": phone,
        "current_user": currentuser,
        "branch": branch,
        "current_host": str(request.get_host()),
        "phone_customer": phone_customer,
        "address_customer": address_customer,
        "discountmethod":discountmethod,
        "discountperc":discountperc
    }

    spare = SpareParts.objects.filter(servicerefnumber=serviceref)
    spare_list = []
    for i in spare:
        data = {}
        data["name"] = i.name
        data["price"] = i.price
        data["salegst"] = i.salegst
        data["totalquantity"] = i.totalquantity
        data["barcodenumber"] = i.barcodenumber
        if i.price and i.salegst:
            try:
                data["total"] = (
                    float(i.price) + ((float(i.salegst) / 100) * float(i.price))
                ) * int(i.totalquantity)
            except:
                data["total"] = ""
        else:
            data["total"] = ""

        spare_list.append(data)

    if spare:
        context["spare"] = spare_list
    else:
        context["spare"] = 0

    language = Language.objects.first()
    if language:
        language = language.language
    else:
        language = None

    # create a template object
    if action == "order":
        if language == "ar":
            template = get_template("serviceorderpdfarabic.html")
        else:
            template = get_template("serviceorderpdf.html")
        css = os.path.join(BASE_DIR, "core", "static", "css", "serviceorder.css")
    elif action == "invoice":
        if language == "ar":
            template = get_template("serviceinvoicepdfarabic.html")
        else:
            template = get_template("serviceinvoicepdf.html")
        css = os.path.join(BASE_DIR, "core", "static", "css", "salespdf.css")

    try:
        PAGESIZE = PageSize.objects.filter(active=True).first().size
    except:
        PAGESIZE = "A4"

    # render the context dictionary values
    html = template.render(context)
    options = {"quiet": "", "encoding": "UTF-8", "page-size": PAGESIZE}
    # generate the pdf from html
    pdf = pdfkit.from_string(html, False, options=options, css=css)
    response = HttpResponse(content_type="application/pdf")

    if action == "order":
        response["Content-Disposition"] = (
            f'inline; filename="service_jobsheet_{date.today()}.pdf"'
        )
    elif action == "invoice":
        response["Content-Disposition"] = (
            f'inline; filename="service_invoice_{date.today()}.pdf"'
        )
    response.write(pdf)
    return response





def service_print_page(request, serviceref):
    action = None

    if request.method == "POST":
        if request.POST["flexRadioDefault"] == "order":
            action = "order"
        elif request.POST["flexRadioDefault"] == "invoice":
            action = "invoice"

    serviceobj = Service.objects.filter(servicerefnumber=serviceref).first()
    firstname = serviceobj.firstname
    lastname = serviceobj.lastname
    customerid = serviceobj.customerid
    phone_customer = serviceobj.phone
    expecteddate = serviceobj.expecteddate
    servicecharge = serviceobj.servicecharge
    estimatedprice = serviceobj.finalamount
    totalamount = serviceobj.totalamount
    discount = serviceobj.discount
    amountrecieved = serviceobj.amountrecieved
    duebalance = serviceobj.duebalance
    product = serviceobj.product
    brand = serviceobj.brand
    modal = serviceobj.model
    malfunction = serviceobj.problem
    currentdate = date.today()
    imei = serviceobj.imei
    address_customer = serviceobj.address
    invoicenumber = serviceobj.invoicenumber
    discountmethod = serviceobj.discountmethod
    discountperc = serviceobj.discountpercentage

    if serviceobj.image1:
        image1 = GLOBAL_VARIABLES["current_host"] + serviceobj.image1.url
    else:
        image1 = ""
    if serviceobj.image2:
        image2 = GLOBAL_VARIABLES["current_host"] + serviceobj.image2.url
    else:
        image2 = ""
    if serviceobj.image3:
        image3 = GLOBAL_VARIABLES["current_host"] + serviceobj.image3.url
    else:
        image3 = ""
    if serviceobj.image4:
        image4 = GLOBAL_VARIABLES["current_host"] + serviceobj.image4.url
    else:
        image4 = ""
    if serviceobj.image5:
        image5 = GLOBAL_VARIABLES["current_host"] + serviceobj.image5.url
    else:
        image5 = ""
    if serviceobj.image6:
        image6 = GLOBAL_VARIABLES["current_host"] + serviceobj.image6.url
    else:
        image6 = ""

    branch = serviceobj.branch

    if serviceobj.totaltax == None or serviceobj.totaltax == "":
        totaltax = 0
    else:
        totaltax = serviceobj.totaltax

    if serviceobj.servicetax == None or serviceobj.servicetax == "":
        servicetax = 0
    else:
        servicetax = serviceobj.servicetax

    company = request.user.userprofile.company
    company_name = company.company_name
    if branch.name == "WAREHOUSE":
        address_line1 = company.address_line1
        address_line2 = company.address_line2
        address_line3 = company.address_line3
        phone = ""
    else:
        address_line1 = branch.address
        phone = branch.phone
        address_line2 = ""
        address_line3 = ""
    logo = company.logo_url
    currentuser = request.user
    barcode_image_url = None
    barcode_base64 = ""
    if action == "order":

        barcode_number = serviceobj.barcode_number
        writer_options = {
            "module_width": 0.3,
            "module_height": 10.0,
            "font_size": 12,
            "text_distance": 5.0,
            "center_text": True,
        }
        barcode_bytes_io = BytesIO()
        barcode_format = barcode.get_barcode_class("code128")
        my_barcode = barcode_format(barcode_number, writer=ImageWriter()).write(
            barcode_bytes_io, options=writer_options
        )
        barcode_bytes_io.seek(0)
        barcode_image_bytes = barcode_bytes_io.getvalue()
        barcode_base64 = base64.b64encode(barcode_image_bytes).decode()

    if action == "invoice":
        customertype = serviceobj.customertype
        customer = f"{firstname} {lastname}"
        if customertype == "B2B":
            vatnumber = serviceobj.customer_gst_number
        else:
            vatnumber = ""
    else:
        customertype = ""
        customer = ""
        vatnumber = ""

    total_wo_discount = round(totalamount, 2) + (
        round((round(servicecharge / (1 + servicetax / 100), 2)) * (servicetax/100),2)
    )

    # total_tax_amount = (round(servicecharge * (servicetax / 100), 2))

    total_tax_amount = round((round(servicecharge / (1 + servicetax / 100), 2)) * (servicetax/100),2)

    

    ###### spare tax calculation 11/10/2024 ###########

    ##### 25/10/2024 #####

    discount_dict = {
        "discount":'',
        "total_excl_tax":'',
        "total_tx":'',
        "tot":'',
        'total_excl_tax_afterdic':'',
        "total_tx_afterdisc":'',
        "total_excl_tax_beforedic":'',
        "total_tx_beforedisc":'',
        "tot_beforedisc":'' ,
        'total_tx_beforedisc':''
    }
    if round(discount, 2) > 0:
        sparecostafter_discount_excltax=0
        sparetax_afterdiscount=0
        servivcecost_excltax_beforediscount = 0
        servicetaxtotal_beforediscount = 0
        service_cost_afterdiscount = 0
        servicetax_aftrdiscount = 0
        spare_tx_total_beforediscount = 0
        spare_total_beforediscount = 0
        servicediscountobj =ServiceDiscountDetails.objects.filter(servicerefnumber=serviceref).first()
        if servicediscountobj:
            sparecostafter_discount_excltax = servicediscountobj.sparetotal_excltax_afterdiscount 
            sparetax_afterdiscount=servicediscountobj.sparetaxtotal_afterdiscount
            servivcecost_excltax_beforediscount =servicediscountobj.servivcecost_excltax_beforediscount 
            servicetaxtotal_beforediscount=servicediscountobj.servicetaxtotal_beforediscount
            service_cost_afterdiscount = servicediscountobj.servivcecost_excltax_afterdiscount
            servicetax_aftrdiscount = servicediscountobj.servicetaxtotal_afterdiscount
            spare_obj = SpareParts.objects.filter(servicerefnumber=serviceref)
            for item in spare_obj:
                tx= (item.price * (float(item.salegst)/100)) * item.totalquantity
                spare_tx_total_beforediscount += tx
                ttl = item.price * item.totalquantity
                spare_total_beforediscount += ttl

        total_excl_tax_afterdic = sparecostafter_discount_excltax + service_cost_afterdiscount
        total_tx_afterdisc = sparetax_afterdiscount + servicetax_aftrdiscount

        total_excl_tax_beforedic = servivcecost_excltax_beforediscount + spare_total_beforediscount
        total_tx_beforedisc = servicetaxtotal_beforediscount + spare_tx_total_beforediscount
        tot_beforedisc = total_excl_tax_beforedic + total_tx_beforedisc
     
        discou='yes'
        
        discount_dict['discount'] = discou
        discount_dict['total_excl_tax_afterdic'] = total_excl_tax_afterdic
        discount_dict['total_tx_afterdisc'] = total_tx_afterdisc
        discount_dict['total_excl_tax_beforedic'] = total_excl_tax_beforedic
        discount_dict['tot_beforedisc'] = tot_beforedisc
        discount_dict['total_tx_beforedisc'] = total_tx_beforedisc
    else:
        service_costt_incltx = servicecharge
        servicetax_a = total_tax_amount
        service_costt_excltx = servicecharge - total_tax_amount
    
        spare_tx_total_beforediscount = 0
        spare_total_beforediscount = 0
        spare_obj = SpareParts.objects.filter(servicerefnumber=serviceref)
        for item in spare_obj:
            tx= (item.price * (float(item.salegst)/100)) * item.totalquantity
            spare_tx_total_beforediscount += tx
            ttl = item.price * item.totalquantity
            spare_total_beforediscount += ttl

        total_excl_tax = spare_total_beforediscount + service_costt_excltx
        total_tx = spare_tx_total_beforediscount + servicetax_a
        tot = total_excl_tax + total_tx
        discou='no'

        discount_dict['discount'] = discou
        discount_dict['total_excl_tax'] =total_excl_tax
        discount_dict['total_tx'] = total_tx
        discount_dict['tot'] = tot

    
  
    ######################

    spare_obj = SpareParts.objects.filter(servicerefnumber=serviceref)
    spare_tx = 0
    for item in spare_obj:
        tx= (item.price * (float(item.salegst)/100)) * item.totalquantity
        spare_tx += tx
    totaltax =totaltax + round(spare_tx,2)

    ###### 25/10/2024 ######
    if round(discount, 2) > 0:
        totaltax = total_tx_afterdisc
    else:
        totaltax = total_tx

    ###################################################

    totalworden = func_price_in_words(round(estimatedprice, 2), "en")
    totalwordar = func_price_in_words(round(estimatedprice, 2), "ar")

    finalamount = round(estimatedprice, 2)
    totaltax = round(totaltax, 2)
    invoicedate  = serviceobj.invoicedate
    qrcode_base64 = func_generate_invoice_qrcode(finalamount,totaltax,invoicedate)

    # print("total amount",totalamount)
    # print("final amount",finalamount)


    total_excluding_tax = totalamount - totaltax

    context = {
        "discountdict":discount_dict,
        "total_excluding_tax":total_excluding_tax,
        "invoicedate":invoicedate,
        'qrcode_base64':qrcode_base64,
        "invoicenumber":invoicenumber,
        "totalworden": totalworden,
        "totalwordar": totalwordar,
        "total_wo_discount": total_wo_discount,
        "total_tax_amount":total_tax_amount,
        "billmode": serviceobj.paymentmode,
        "customer": customer,
        "vatnumber": vatnumber,
        "customertype": customertype,
        "servicetax": servicetax,
        "servicecharge": servicecharge,
        "totalamount": round(totalamount, 2),
        "totaltax": round(totaltax, 2),
        "finalamount": round(estimatedprice, 2),
        "discount": round(discount, 2),
        "amountrecieved": round(amountrecieved, 2),
        "duebalance": round(duebalance, 2),
        "product": product,
        "customerid": customerid,
        "phone": phone,
        "price": round(estimatedprice, 2),
        "estimateddate": expecteddate,
        "firstname": firstname,
        "lastname": lastname,
        "serviceref": serviceref,
        "brand": brand,
        "modal": modal,
        "malfunction": malfunction,
        "company_name": company_name,
        "address_line1": address_line1,
        "address_line2": address_line2,
        "address_line3": address_line3,
        "logo": GLOBAL_VARIABLES["current_host"] + logo.url,
        "currentdate": currentdate,
        "imei": imei,
        "barcode": barcode_base64,
        "image1": image1,
        "image2": image2,
        "image3": image3,
        "image4": image4,
        "image5": image5,
        "image6": image6,
        "phone": phone,
        "current_user": currentuser,
        "branch": branch,
        "current_host": str(request.get_host()),
        "phone_customer": phone_customer,
        "address_customer": address_customer,
        "discountmethod":discountmethod,
        "discountperc":discountperc
    }

    spare = SpareParts.objects.filter(servicerefnumber=serviceref)
    spare_list = []
    for i in spare:
        data = {}
        data["name"] = i.name
        data["price"] = i.price
        data["salegst"] = i.salegst
        data["totalquantity"] = i.totalquantity
        data["barcodenumber"] = i.barcodenumber
        if i.price and i.salegst:
            try:
                data["total"] = (
                    float(i.price) + ((float(i.salegst) / 100) * float(i.price))
                ) * int(i.totalquantity)
            except:
                data["total"] = ""
        else:
            data["total"] = ""

        spare_list.append(data)

    if spare:
        context["spare"] = spare_list
    else:
        context["spare"] = 0

    language = Language.objects.first()
    if language:
        language = language.language
    else:
        language = None

    # create a template object
    if action == "order":
        if language == "ar":
            template = get_template("serviceorderpdfarabic.html")
        else:
            template = get_template("serviceorderpdf.html")
        css = os.path.join(BASE_DIR, "core", "static", "css", "serviceorder.css")
    elif action == "invoice":
        if language == "ar":
            template = get_template("serviceinvoicepdfarabic.html")
        else:
            template = get_template("serviceinvoicepdf.html")
        css = os.path.join(BASE_DIR, "core", "static", "css", "salespdf.css")

    try:
        PAGESIZE = PageSize.objects.filter(active=True).first().size
    except:
        PAGESIZE = "A4"

    # render the context dictionary values
    # html = template.render(context)
    # options = {"quiet": "", "encoding": "UTF-8", "page-size": PAGESIZE}
    # # generate the pdf from html
    # pdf = pdfkit.from_string(html, False, options=options, css=css)
    # response = HttpResponse(content_type="application/pdf")

    # if action == "order":
    #     response["Content-Disposition"] = (
    #         f'inline; filename="service_jobsheet_{date.today()}.pdf"'
    #     )
    # elif action == "invoice":
    #     response["Content-Disposition"] = (
    #         f'inline; filename="service_invoice_{date.today()}.pdf"'
    #     )
    # response.write(pdf)
    # return response
    if action == "invoice":
        return render(request,"serviceinvoicepage.html",context)
    else:
        return render(request,"serviceorderpage.html",context)







@user_passes_test(
    partial(check_permission, page="Serviceform"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@never_cache
@login_required
def serviceForm(request):

    customer_phone_numbers = list(
        Customers.objects.filter(branch=request.user.userprofile.branch).values(
            "phone", "firstname"
        )
    )

    user = request.user

    servicerefnumber = UniqueIdGenerator.objects.filter(model="Service").last()
    servicerefnumber = str(servicerefnumber.prefix) + str(servicerefnumber.uniqueid)

    invoicenumber = UniqueIdGenerator.objects.filter(model="Invoice").last()
    invoicenumber = (
        str(invoicenumber.prefix)
        + f'-{str(date.today().year)[2:]}{datetime.now().strftime("%m")}'
        + str(invoicenumber.uniqueid)
    )

    branch = request.user.userprofile.branch

    if user.is_superuser:
        product_names = (
            Stock.objects.filter(quantity__gt=0)
            .values_list("name__id", flat=True)
            .distinct()
        )
        product_names = [
            Stock.objects.filter(name__id=pr).first().name for pr in product_names
        ]
        technician = UserProfile.objects.filter(role="Technician")
    else:
        product_names = (
            BranchStock.objects.filter(Q(quantity__gt=0) & Q(branch=branch))
            .values_list("name__id", flat=True)
            .distinct()
        )

        product_names = [
            BranchStock.objects.filter(name__id=pr).first().name for pr in product_names
        ]
        technician = UserProfile.objects.filter(Q(role="Technician") & Q(branch=branch))

    salegst = Tax.objects.filter(branch=request.user.userprofile.branch)

    service_status = {}
    user = request.user
    if user.is_superuser:
        for serv in Service.objects.all():
            if serv.technician:
                if serv.technician.username in technician.values_list(
                    "user__username", flat=True
                ):
                    if serv.technician.username not in service_status.keys():
                        service_status[serv.technician.username] = {
                            "Assigned": 0,
                            "InProgress": 0,
                            "Completed": 0,
                            "Rejected": 0,
                            "Delivered": 0,
                        }
                    if serv.status == "Assigned":
                        service_status[serv.technician.username]["Assigned"] += 1
                    if serv.status == "In Progress":
                        service_status[serv.technician.username]["InProgress"] += 1
                    if serv.status == "Completed":
                        service_status[serv.technician.username]["Completed"] += 1
                    # if serv.status == "Pending":
                    #     service_status[serv.technician.username]['Pending'] +=1
                    if serv.status == "Rejected":
                        service_status[serv.technician.username]["Rejected"] += 1
        service_technicians = [
            tec[0] for tec in Service.objects.all().values_list("technician__username")
        ]
        for j in technician.values_list("user__username", flat=True):
            if j not in service_technicians:
                service_status[j] = {
                    "Assigned": 0,
                    "InProgress": 0,
                    "Completed": 0,
                    "Rejected": 0,
                    "Delivered": 0,
                }

    else:
        for serv in Service.objects.filter(branch=user.userprofile.branch):
            if serv.technician:
                if serv.technician.username in technician.values_list(
                    "user__username", flat=True
                ):
                    if serv.technician.username not in service_status.keys():
                        service_status[serv.technician.username] = {
                            "Assigned": 0,
                            "InProgress": 0,
                            "Completed": 0,
                            "Rejected": 0,
                            "Delivered": 0,
                        }
                    if serv.status == "Assigned":
                        service_status[serv.technician.username]["Assigned"] += 1
                    if serv.status == "In Progress":
                        service_status[serv.technician.username]["InProgress"] += 1
                    if serv.status == "Completed":
                        service_status[serv.technician.username]["Completed"] += 1
                    # if serv.status == "Pending":
                    #     service_status[serv.technician.username]['Pending'] +=1
                    if serv.status == "Rejected":
                        service_status[serv.technician.username]["Rejected"] += 1

        service_technicians = [
            tec[0]
            for tec in Service.objects.filter(
                branch=user.userprofile.branch
            ).values_list("technician__username")
        ]
        for j in technician.values_list("user__username", flat=True):
            if j not in service_technicians:
                service_status[j] = {
                    "Assigned": 0,
                    "InProgress": 0,
                    "Completed": 0,
                    "Rejected": 0,
                    "Delivered": 0,
                }

    if user.is_superuser:
        stocks = Stock.objects.filter(quantity__gt=0)
    else:
        stocks = BranchStock.objects.filter(
            Q(quantity__gt=0) & Q(branch=user.userprofile.branch)
        )
    stock_dict = {}
    for i in stocks:
        stock_dict[i.name] = i.quantity

    brands = PhoneBrand.objects.all().order_by("-pk")
    problems = ServiceIssues.objects.all().order_by("-pk")
    paymentmode = PaymentMode.objects.all()
    products = ServiceProduct.objects.all()
    customerbooking = CustomerBookingRepair.objects.filter(
        Q(branch=request.user.userprofile.branch)
        & Q(status="Verified")
        & Q(service__isnull=True)
    )

    context = {
        "technician_status": service_status,
        "phone": customer_phone_numbers,
        "today": date.today(),
        "servicenumber": servicerefnumber,
        "products": product_names,
        "tax": salegst,
        "technicians": technician,
        "brands": brands,
        "stock_list": stock_dict,
        "problems": problems,
        "paymentmode": paymentmode,
        "products": products,
        "customerbooking": customerbooking,
        "invoicenumber": invoicenumber,
    }
    return render(request, "serviceform.html", context)


def compress_image_service(image_data):
    image = Image.open(io.BytesIO(image_data))
    # image.thumbnail(max_size, Image.LANCZOS)
    image_io = io.BytesIO()
    image.save(image_io, format="PNG", optimize=True, quality=30)
    return image_io.getvalue()


def func_printServiceBarcode(request, serviceref):

    if request.user.is_superuser:
        service = Service.objects.filter(servicerefnumber=serviceref).first()
    else:
        service = Service.objects.filter(
            Q(servicerefnumber=serviceref) & Q(branch=request.user.userprofile.branch)
        ).first()

    date_now = datetime.now().strftime("%d/%m/%Y %I:%M %p")
    customer = f"{service.firstname} {service.lastname}"
    phone = service.phone
    problem = service.problem
    barcode_number = service.barcode_number
    barcode_type = "Service"
    barcode_qty = 1
    service_ref = service.servicerefnumber

    return printBarcodeHelper(
        barcode_type,
        barcode_number,
        barcode_qty,
        company_name="MAGNUS CARE",
        date_now=date_now,
        customer=customer,
        mobile=phone,
        problem=problem,
        bc_type=barcode_type,
        sr_no=service_ref,
    )


def func_serviceprint(request, serviceref, action):

    serviceobj = Service.objects.filter(servicerefnumber=serviceref).first()
    firstname = serviceobj.firstname
    lastname = serviceobj.lastname
    customerid = serviceobj.customerid
    phone_customer = serviceobj.phone
    expecteddate = serviceobj.expecteddate
    servicecharge = serviceobj.servicecharge
    estimatedprice = serviceobj.finalamount
    totalamount = serviceobj.totalamount
    discount = serviceobj.discount
    amountrecieved = serviceobj.amountrecieved
    duebalance = serviceobj.duebalance
    product = serviceobj.product
    brand = serviceobj.brand
    modal = serviceobj.model
    malfunction = serviceobj.problem
    currentdate = date.today()
    imei = serviceobj.imei
    address_customer = serviceobj.address
    invoicenumber = serviceobj.invoicenumber
    discountmethod = serviceobj.discountmethod
    discountperc = serviceobj.discountpercentage

    if serviceobj.image1:
        image1 = GLOBAL_VARIABLES["current_host"] + serviceobj.image1.url
    else:
        image1 = ""
    if serviceobj.image2:
        image2 = GLOBAL_VARIABLES["current_host"] + serviceobj.image2.url
    else:
        image2 = ""
    if serviceobj.image3:
        image3 = GLOBAL_VARIABLES["current_host"] + serviceobj.image3.url
    else:
        image3 = ""
    if serviceobj.image4:
        image4 = GLOBAL_VARIABLES["current_host"] + serviceobj.image4.url
    else:
        image4 = ""
    if serviceobj.image5:
        image5 = GLOBAL_VARIABLES["current_host"] + serviceobj.image5.url
    else:
        image5 = ""
    if serviceobj.image6:
        image6 = GLOBAL_VARIABLES["current_host"] + serviceobj.image6.url
    else:
        image6 = ""

    branch = serviceobj.branch

    if serviceobj.totaltax == None or serviceobj.totaltax == "":
        totaltax = 0
    else:
        totaltax = serviceobj.totaltax

    if serviceobj.servicetax == None or serviceobj.servicetax == "":
        servicetax = 0
    else:
        servicetax = serviceobj.servicetax
    # servicetax = float(serviceobj.servicetax)

    company = request.user.userprofile.company
    company_name = company.company_name
    if branch.name == "WAREHOUSE":
        address_line1 = company.address_line1
        address_line2 = company.address_line2
        address_line3 = company.address_line3
        phone = ""
    else:
        address_line1 = branch.address
        phone = branch.phone
        address_line2 = ""
        address_line3 = ""
    logo = company.logo_url
    currentuser = request.user
    barcode_image_url = None
    barcode_base64 = ""
    if action == "order":

        barcode_number = serviceobj.barcode_number
        writer_options = {
            "module_width": 0.3,
            "module_height": 10.0,
            "font_size": 12,
            "text_distance": 5.0,
            "center_text": True,
        }
        barcode_bytes_io = BytesIO()
        barcode_format = barcode.get_barcode_class("code128")
        my_barcode = barcode_format(barcode_number, writer=ImageWriter()).write(
            barcode_bytes_io, options=writer_options
        )
        barcode_bytes_io.seek(0)
        barcode_image_bytes = barcode_bytes_io.getvalue()
        barcode_base64 = base64.b64encode(barcode_image_bytes).decode()

    if action == "invoice":
        customertype = serviceobj.customertype
        customer = f"{firstname} {lastname}"
        if customertype == "B2B":
            vatnumber = serviceobj.customer_gst_number
        else:
            vatnumber = ""
    else:
        customertype = ""
        customer = ""
        vatnumber = ""

    total_wo_discount = round(totalamount, 2) + (
        round(servicecharge * (servicetax / 100), 2)
    )

    total_tax_amount = (round(servicecharge * (servicetax / 100), 2))

    totalworden = func_price_in_words(round(estimatedprice, 2), "en")
    totalwordar = func_price_in_words(round(estimatedprice, 2), "ar")

    finalamount = round(estimatedprice, 2)
    totaltax = round(totaltax, 2)
    invoicedate  = serviceobj.invoicedate
    qrcode_base64 = func_generate_invoice_qrcode(finalamount,totaltax,invoicedate)

    total_excluding_tax = totalamount - totaltax

    context = {
        "total_excluding_tax":total_excluding_tax,
        'qrcode_base64':qrcode_base64,
        "invoicenumber":invoicenumber,
        "totalworden": totalworden,
        "totalwordar": totalwordar,
        "total_wo_discount": total_wo_discount,
        "total_tax_amount":total_tax_amount,
        "billmode": serviceobj.paymentmode,
        "customer": customer,
        "vatnumber": vatnumber,
        "customertype": customertype,
        "servicetax": servicetax,
        "servicecharge": servicecharge,
        "totalamount": round(totalamount, 2),
        "totaltax": round(totaltax, 2),
        "finalamount": round(estimatedprice, 2),
        "discount": round(discount, 2),
        "amountrecieved": round(amountrecieved, 2),
        "duebalance": round(duebalance, 2),
        "product": product,
        "customerid": customerid,
        "phone": phone,
        "price": round(estimatedprice, 2),
        "estimateddate": expecteddate,
        "firstname": firstname,
        "lastname": lastname,
        "serviceref": serviceref,
        "brand": brand,
        "modal": modal,
        "malfunction": malfunction,
        "company_name": company_name,
        "address_line1": address_line1,
        "address_line2": address_line2,
        "address_line3": address_line3,
        "logo": GLOBAL_VARIABLES["current_host"] + logo.url,
        "currentdate": currentdate,
        "imei": imei,
        "barcode": barcode_base64,
        "image1": image1,
        "image2": image2,
        "image3": image3,
        "image4": image4,
        "image5": image5,
        "image6": image6,
        "phone": phone,
        "current_user": currentuser,
        "branch": branch,
        "current_host": str(request.get_host()),
        "phone_customer": phone_customer,
        "address_customer": address_customer,
        "discountmethod":discountmethod,
        "discountperc":discountperc
    }

    spare = SpareParts.objects.filter(servicerefnumber=serviceref)
    spare_list = []
    for i in spare:
        data = {}
        data["name"] = i.name
        data["price"] = i.price
        data["salegst"] = i.salegst
        data["totalquantity"] = i.totalquantity
        data["barcodenumber"] = i.barcodenumber
        if i.price and i.salegst:
            try:
                data["total"] = (
                    float(i.price) + ((float(i.salegst) / 100) * float(i.price))
                ) * int(i.totalquantity)
            except:
                data["total"] = ""
        else:
            data["total"] = ""

        spare_list.append(data)

    if spare:
        context["spare"] = spare_list
    else:
        context["spare"] = 0

    language = Language.objects.first()
    if language:
        language = language.language
    else:
        language = None

    # create a template object
    if action == "order":
        if language == "ar":
            template = get_template("serviceorderpdfarabic.html")
        else:
            template = get_template("serviceorderpdf.html")
        css = os.path.join(BASE_DIR, "core", "static", "css", "serviceorder.css")
    elif action == "invoice":
        if language == "ar":
            template = get_template("serviceinvoicepdfarabic.html")
        else:
            template = get_template("serviceinvoicepdf.html")
        css = os.path.join(BASE_DIR, "core", "static", "css", "salespdf.css")

    try:
        PAGESIZE = PageSize.objects.filter(active=True).first().size
    except:
        PAGESIZE = "A4"

    # render the context dictionary values
    html = template.render(context)
    options = {"quiet": "", "encoding": "UTF-8", "page-size": PAGESIZE}
    # generate the pdf from html
    pdf = pdfkit.from_string(html, False, options=options, css=css)
    response = HttpResponse(content_type="application/pdf")

    if action == "order":
        response["Content-Disposition"] = (
            f'inline; filename="service_jobsheet_{date.today()}.pdf"'
        )
    elif action == "invoice":
        response["Content-Disposition"] = (
            f'inline; filename="service_invoice_{date.today()}.pdf"'
        )
    response.write(pdf)
    return response


def get_service_pdf_bytes(request, action, serviceref):
    currentuser = request.user
    serviceobj = Service.objects.filter(servicerefnumber=serviceref).first()
    firstname = serviceobj.firstname
    lastname = serviceobj.lastname
    customerid = serviceobj.customerid
    phone_customer = serviceobj.phone
    expecteddate = serviceobj.expecteddate
    servicecharge = serviceobj.servicecharge
    estimatedprice = serviceobj.finalamount
    totalamount = serviceobj.totalamount
    discount = serviceobj.discount
    amountrecieved = serviceobj.amountrecieved
    duebalance = serviceobj.duebalance
    product = serviceobj.product
    brand = serviceobj.brand
    modal = serviceobj.model
    malfunction = serviceobj.problem
    currentdate = date.today()
    imei = serviceobj.imei
    address_customer = serviceobj.address
    invoicenumber = serviceobj.invoicenumber
    discountmethod = serviceobj.discountmethod
    discountperc = serviceobj.discountpercentage

    if serviceobj.image1:
        image1 = GLOBAL_VARIABLES["current_host"] + serviceobj.image1.url
    else:
        image1 = ""
    if serviceobj.image2:
        image2 = GLOBAL_VARIABLES["current_host"] + serviceobj.image2.url
    else:
        image2 = ""
    if serviceobj.image3:
        image3 = GLOBAL_VARIABLES["current_host"] + serviceobj.image3.url
    else:
        image3 = ""
    if serviceobj.image4:
        image4 = GLOBAL_VARIABLES["current_host"] + serviceobj.image4.url
    else:
        image4 = ""
    if serviceobj.image5:
        image5 = GLOBAL_VARIABLES["current_host"] + serviceobj.image5.url
    else:
        image5 = ""
    if serviceobj.image6:
        image6 = GLOBAL_VARIABLES["current_host"] + serviceobj.image6.url
    else:
        image6 = ""

    branch = serviceobj.branch

    if serviceobj.totaltax == None or serviceobj.totaltax == "":
        totaltax = 0
    else:
        totaltax = serviceobj.totaltax

    if serviceobj.servicetax == None or serviceobj.servicetax == "":
        servicetax = 0
    else:
        servicetax = serviceobj.servicetax
    # servicetax = float(serviceobj.servicetax)

    company = request.user.userprofile.company
    company_name = company.company_name
    if branch.name == "WAREHOUSE":
        address_line1 = company.address_line1
        address_line2 = company.address_line2
        address_line3 = company.address_line3
        phone = ""
    else:
        address_line1 = branch.address
        phone = branch.phone
        address_line2 = ""
        address_line3 = ""
    logo = company.logo_url

    currentuser = request.user

    barcode_image_url = None
    barcode_base64 = ""
    if action == "order":

        barcode_number = serviceobj.barcode_number
        writer_options = {
            "module_width": 0.3,
            "module_height": 10.0,
            "font_size": 12,
            "text_distance": 5.0,
            "center_text": True,
        }
        barcode_bytes_io = BytesIO()
        barcode_format = barcode.get_barcode_class("code128")
        my_barcode = barcode_format(barcode_number, writer=ImageWriter()).write(
            barcode_bytes_io, options=writer_options
        )
        barcode_bytes_io.seek(0)
        barcode_image_bytes = barcode_bytes_io.getvalue()
        barcode_base64 = base64.b64encode(barcode_image_bytes).decode()

    if action == "invoice":
        customertype = serviceobj.customertype
        customer = f"{firstname} {lastname}"
        if customertype == "B2B":
            vatnumber = serviceobj.customer_gst_number
        else:
            vatnumber = ""
    else:
        customertype = ""
        customer = ""
        vatnumber = ""

    # total_wo_discount = round(totalamount, 2) + (
    #     round(servicecharge * (servicetax / 100), 2)
    # )

    # total_tax_amount = (round(servicecharge * (servicetax / 100), 2))

    total_wo_discount = round(totalamount, 2) + (
        round((round(servicecharge / (1 + servicetax / 100), 2)) * (servicetax/100),2)
    )

    total_tax_amount = round((round(servicecharge / (1 + servicetax / 100), 2)) * (servicetax/100),2)

    ###### spare tax calculation 11/10/2024 ###########


    ##### 25/10/2024 #####

    discount_dict = {
        "discount":'',
        "total_excl_tax":'',
        "total_tx":'',
        "tot":'',
        'total_excl_tax_afterdic':'',
        "total_tx_afterdisc":'',
        "total_excl_tax_beforedic":'',
        "total_tx_beforedisc":'',
        "tot_beforedisc":'' ,
        'total_tx_beforedisc':''
    }

    if round(discount, 2) > 0:
        sparecostafter_discount_excltax=0
        sparetax_afterdiscount=0
        servivcecost_excltax_beforediscount = 0
        servicetaxtotal_beforediscount = 0
        service_cost_afterdiscount = 0
        servicetax_aftrdiscount = 0
        spare_tx_total_beforediscount = 0
        spare_total_beforediscount = 0
        servicediscountobj =ServiceDiscountDetails.objects.filter(servicerefnumber=serviceref).first()
        if servicediscountobj:
            sparecostafter_discount_excltax = servicediscountobj.sparetotal_excltax_afterdiscount 
            sparetax_afterdiscount=servicediscountobj.sparetaxtotal_afterdiscount
            servivcecost_excltax_beforediscount =servicediscountobj.servivcecost_excltax_beforediscount 
            servicetaxtotal_beforediscount=servicediscountobj.servicetaxtotal_beforediscount
            service_cost_afterdiscount = servicediscountobj.servivcecost_excltax_afterdiscount
            servicetax_aftrdiscount = servicediscountobj.servicetaxtotal_afterdiscount
            spare_obj = SpareParts.objects.filter(servicerefnumber=serviceref)
            for item in spare_obj:
                tx= (item.price * (float(item.salegst)/100)) * item.totalquantity
                spare_tx_total_beforediscount += tx
                ttl = item.price * item.totalquantity
                spare_total_beforediscount += ttl

        total_excl_tax_afterdic = sparecostafter_discount_excltax + service_cost_afterdiscount
        total_tx_afterdisc = sparetax_afterdiscount + servicetax_aftrdiscount
        total_excl_tax_beforedic = servivcecost_excltax_beforediscount + spare_total_beforediscount
        total_tx_beforedisc = servicetaxtotal_beforediscount + spare_tx_total_beforediscount
        tot_beforedisc = total_excl_tax_beforedic + total_tx_beforedisc
        discou='yes'
        discount_dict['discount'] = discou
        discount_dict['total_excl_tax_afterdic'] = total_excl_tax_afterdic
        discount_dict['total_tx_afterdisc'] = total_tx_afterdisc
        discount_dict['total_excl_tax_beforedic'] = total_excl_tax_beforedic
        discount_dict['tot_beforedisc'] = tot_beforedisc
        discount_dict['total_tx_beforedisc'] = total_tx_beforedisc
    else:
        service_costt_incltx = servicecharge
        servicetax_a = total_tax_amount
        service_costt_excltx = servicecharge - total_tax_amount
        spare_tx_total_beforediscount = 0
        spare_total_beforediscount = 0
        spare_obj = SpareParts.objects.filter(servicerefnumber=serviceref)
        for item in spare_obj:
            tx= (item.price * (float(item.salegst)/100)) * item.totalquantity
            spare_tx_total_beforediscount += tx
            ttl = item.price * item.totalquantity
            spare_total_beforediscount += ttl

        total_excl_tax = spare_total_beforediscount + service_costt_excltx
        total_tx = spare_tx_total_beforediscount + servicetax_a
        tot = total_excl_tax + total_tx
        discou='no'
        discount_dict['discount'] = discou
        discount_dict['total_excl_tax'] =total_excl_tax
        discount_dict['total_tx'] = total_tx
        discount_dict['tot'] = tot
    ######################

    spare_obj = SpareParts.objects.filter(servicerefnumber=serviceref)

 
    spare_tx = 0
    for item in spare_obj:
        tx= (item.price * (float(item.salegst)/100)) * item.totalquantity
        spare_tx += tx


    totaltax =totaltax + round(spare_tx,2)
    ###### 25/10/2024 ######

    if round(discount, 2) > 0:
        totaltax = total_tx_afterdisc
    else:
        totaltax = total_tx

    ###################################################

    totalworden = func_price_in_words(round(estimatedprice, 2), "en")
    totalwordar = func_price_in_words(round(estimatedprice, 2), "ar")

    finalamount = round(estimatedprice, 2)
    totaltax = round(totaltax, 2)
    invoicedate  = serviceobj.invoicedate
    qrcode_base64 = func_generate_invoice_qrcode(finalamount,totaltax,invoicedate)

    total_excluding_tax = totalamount - totaltax

    context = {
        "discountdict":discount_dict,
        "total_excluding_tax":total_excluding_tax,
        "invoicedate":invoicedate,
        'qrcode_base64':qrcode_base64,
        "invoicenumber":invoicenumber,
        "totalworden": totalworden,
        "totalwordar": totalwordar,
        "total_wo_discount": total_wo_discount,
        "total_tax_amount":total_tax_amount,
        "billmode": serviceobj.paymentmode,
        "customer": customer,
        "vatnumber": vatnumber,
        "customertype": customertype,
        "servicetax": servicetax,
        "servicecharge": servicecharge,
        "totalamount": round(totalamount, 2),
        "totaltax": round(totaltax, 2),
        "finalamount": round(estimatedprice, 2),
        "discount": round(discount, 2),
        "amountrecieved": round(amountrecieved, 2),
        "duebalance": round(duebalance, 2),
        "product": product,
        "customerid": customerid,
        "phone": phone,
        "price": round(estimatedprice, 2),
        "estimateddate": expecteddate,
        "firstname": firstname,
        "lastname": lastname,
        "serviceref": serviceref,
        "brand": brand,
        "modal": modal,
        "malfunction": malfunction,
        "company_name": company_name,
        "address_line1": address_line1,
        "address_line2": address_line2,
        "address_line3": address_line3,
        "logo": GLOBAL_VARIABLES["current_host"] + logo.url,
        "currentdate": currentdate,
        "imei": imei,
        "barcode": barcode_base64,
        "image1": image1,
        "image2": image2,
        "image3": image3,
        "image4": image4,
        "image5": image5,
        "image6": image6,
        "phone": phone,
        "current_user": currentuser,
        "branch": branch,
        "current_host": str(request.get_host()),
        "phone_customer": phone_customer,
        "address_customer": address_customer,
        "discountmethod":discountmethod,
        "discountperc":discountperc
    }
    spare = SpareParts.objects.filter(servicerefnumber=serviceref)
    spare_list = []
    for i in spare:
        data = {}
        data["name"] = i.name
        data["price"] = i.price
        data["salegst"] = i.salegst
        data["totalquantity"] = i.totalquantity
        data["barcodenumber"] = i.barcodenumber
        if i.price and i.salegst:
            try:
                data["total"] = (
                    float(i.price) + ((float(i.salegst) / 100) * float(i.price))
                ) * int(i.totalquantity)
            except:
                data["total"] = ""
        else:
            data["total"] = ""

        spare_list.append(data)

    if spare:
        context["spare"] = spare_list
    else:
        context["spare"] = 0

    language = Language.objects.first()
    if language:
        language = language.language
    else:
        language = None

    # create a template object
    if action == "order":
        if language == "ar":
            template = get_template("serviceorderpdfarabic.html")
        else:
            template = get_template("serviceorderpdf.html")
        css = os.path.join(BASE_DIR, "core", "static", "css", "serviceorder.css")
    elif action == "invoice":
        if language == "ar":
            template = get_template("serviceinvoicepdfarabic.html")
        else:
            template = get_template("serviceinvoicepdf.html")
        css = os.path.join(BASE_DIR, "core", "static", "css", "salespdf.css")

    # render the context dictionary values
    html = template.render(context)
    options = {"quiet": "", "encoding": "UTF-8", "page-size": "A4"}
    # generate the pdf from html
    pdf = pdfkit.from_string(html, False, options=options, css=css)

    return pdf


@login_required
def addService(request):
    
    if request.method == "POST":

        performance_logger.debug(f'Service entry form submission start {request.POST.get("refnumber")}')
        start_time = time.time()
        
        customer_ledger = None
        for i in range(1, 2):

            product = request.POST.get("product" + str(i))
            if not product:
                continue
            brand = request.POST["brand" + str(i)]
            model = request.POST["model" + str(i)]
            series = request.POST["series" + str(i)]
            imei = request.POST["imei" + str(i)]
            servicecharge = request.POST["serviceprice" + str(i)]
            firstname = request.POST["firstnameservice"]
            lastname = request.POST.get("lastnameservice")
            address = request.POST.get("addressservice")
            phone = request.POST.get("mobilenumber")
            servicerefnumber = request.POST.get("refnumber")
            invoicenumber = request.POST.get("invoicenumber")
            customerid = request.POST.get("customeridservice")
            memodate = request.POST.get("serviceentrydate")
            paymentmode = request.POST.get("paymentmode")
            technician = request.POST.get("technician")
            pattern = request.POST.get("pattern")
            screen_password = request.POST.get("phonepassword")
            # SG-28
            customer_gst = request.POST.get("customergst", None)
            customertype = request.POST.get("customertypeservice")

            # try:
            newcustomerid=None
            if Customers.objects.filter(phone=phone).first():
                f_name=Customers.objects.filter(phone=phone).first().firstname
                l_name=Customers.objects.filter(phone=phone).first().lastname
                if f_name != firstname or l_name != lastname:
                    messages.error(request, "Customer with same phone number already exist, please select the customer from the customer dropdown!")
                    return redirect(
                                reverse("serviceform")
                            )

                try:
                    cust_obj = Customers.objects.filter(phone=phone).first()
                    if cust_obj:
                        ledger_title = f"{cust_obj.firstname} {cust_obj.lastname} {cust_obj.unique_id}"
                        cust_ledger = CoASubAccounts.objects.filter(Q(title=ledger_title)&Q(is_adminonly=True)).first()
                        customer_ledger = cust_ledger
                except:
                    pass

            else:
                cust = Customers()
                unq_id = generate_unique_id("Customers", "MAGNUS")
                cust.unique_id = unq_id
                cust.firstname = firstname
                cust.lastname = lastname
                cust.phone = phone
                cust.phonemodel = f"{brand} {model}"
                cust.address = address
                cust.addedby = request.user
                cust.branch = request.user.userprofile.branch
                if (
                    customer_gst != ""
                    and customer_gst != "None"
                    and customer_gst != None
                ):
                    cust.vatnumber = customer_gst
                cust.customertype = customertype
                cust.save()
                newcustomerid = unq_id

                cust_obj = Customers.objects.filter(unique_id=newcustomerid).first()
                if cust_obj:
                    func_create_customer_ledger(cust_obj,newcustomerid,request)


                try:
                    if cust_obj:
                        ledger_title = f"{cust_obj.firstname} {cust_obj.lastname} {cust_obj.unique_id}"
                        cust_ledger = CoASubAccounts.objects.filter(Q(title=ledger_title)&Q(is_adminonly=True)).first()
                except:
                    pass
            # except:
            #     pass

            if memodate != None and memodate != "":
                memodate = datetime.strptime(memodate, "%d-%m-%Y").strftime("%Y-%m-%d")
            else:
                memodate = None
            estimateddate = request.POST.get("expecteddate")
            if estimateddate != None and estimateddate != "":
                estimateddate = datetime.strptime(estimateddate, "%d-%m-%Y").strftime(
                    "%Y-%m-%d"
                )
            else:
                estimateddate = None
            problemdetected = request.POST.get("problem")
            warrentystatus = request.POST.get("warrentystatus")
            remarks = request.POST.get("remarks")

            accessory_battery = request.POST.get("accessory[battery]")
            accessory_charger = request.POST.get("accessory[charger]")
            accessory_sim = request.POST.get("accessory[SIM]")
            accessory_memory = request.POST.get("accessory[memory]")
            accessories = list(
                filter(
                    lambda item: item is not None and item != "",
                    [
                        accessory_battery,
                        accessory_charger,
                        accessory_sim,
                        accessory_memory,
                    ],
                )
            )

            status = request.POST.get("status")
            total = request.POST.get("totalamount")
            discount = request.POST.get("discountservice")
            if discount == "" or discount == None:
                discount = 0
            final = request.POST.get("finalamount")
            recieved = request.POST.get("amountrecievedservice")
            due = request.POST.get("duebalance")

            ##### changed on 25-11-2024 #####
            tax_service_tax = ServiceTax.objects.all().first().tax
            tot_wo_tax = round((float(total) / (1 + (15/100))),2)
            total_ex_tax = round(tot_wo_tax  * (tax_service_tax/100),2)
            totaltax = total_ex_tax
            #################################


            booking_id = request.POST["customerbooking"]
            if booking_id:
                customer_booking_obj = CustomerBookingRepair.objects.filter(
                    id=int(booking_id)
                ).first()
            else:
                customer_booking_obj = None

            image1 = request.POST["image1"]
            image2 = request.POST["image2"]
            image3 = request.POST["image3"]
            image4 = request.POST["image4"]
            image5 = request.POST["image5"]
            image6 = request.POST["image6"]

            service = Service()

            try:
                service.customer_ledger = cust_ledger
            except:
                pass

            if technician:
                service.technician = User.objects.get(username=technician)

            if image1 == "no-image":
                pass
            else:
                if image1 != None and image1 != "":

                    image1 = urlopen(image1).read()
                    optimized_image_data = compress_image_service(image1)
                    uploaded_file = ContentFile(
                        optimized_image_data, name=f"{servicerefnumber}.png"
                    )
                    fs = FileSystemStorage()
                    name = fs.save(uploaded_file.name, uploaded_file)
                    image1_url = fs.url(name)
                    filename1 = name
                    service.image1 = filename1


            if image2 == "no-image":
                pass
            else:
                if image2 != None and image2 != "":
                    image2 = urlopen(image2).read()
                    optimized_image_data = compress_image_service(image2)
                    uploaded_file = ContentFile(
                        optimized_image_data, name=f"{servicerefnumber}.png"
                    )
                    fs = FileSystemStorage()
                    name = fs.save(uploaded_file.name, uploaded_file)
                    image2_url = fs.url(name)
                    filename2 = name
                    service.image2 = filename2

            if image3 == "no-image":
                pass
            else:
                if image3 != None and image3 != "":
                    image3 = urlopen(image3).read()
                    optimized_image_data = compress_image_service(image3)
                    uploaded_file = ContentFile(
                        optimized_image_data, name=f"{servicerefnumber}.png"
                    )
                    fs = FileSystemStorage()
                    name = fs.save(uploaded_file.name, uploaded_file)
                    image3_url = fs.url(name)
                    filename3 = name
                    service.image3 = filename3

            if image4 == "no-image":
                pass
            else:
                if image4 != None and image4 != "":
                    image4 = urlopen(image4).read()
                    optimized_image_data = compress_image_service(image4)
                    uploaded_file = ContentFile(
                        optimized_image_data, name=f"{servicerefnumber}.png"
                    )
                    fs = FileSystemStorage()
                    name = fs.save(uploaded_file.name, uploaded_file)
                    image4_url = fs.url(name)
                    filename4 = name
                    service.image4 = filename4

            if image5 == "no-image":
                pass
            else:
                if image5 != None and image5 != "":
                    image5 = urlopen(image5).read()
                    optimized_image_data = compress_image_service(image5)
                    uploaded_file = ContentFile(
                        optimized_image_data, name=f"{servicerefnumber}.png"
                    )
                    fs = FileSystemStorage()
                    name = fs.save(uploaded_file.name, uploaded_file)
                    image5_url = fs.url(name)
                    filename5 = name
                    service.image5 = filename5

            if image6 == "no-image":
                pass
            else:
                if image6 != None and image6 != "":

                    image6 = urlopen(image6).read()
                    optimized_image_data = compress_image_service(image6)
                    uploaded_file = ContentFile(
                        optimized_image_data, name=f"{servicerefnumber}.png"
                    )
                    fs = FileSystemStorage()
                    name = fs.save(uploaded_file.name, uploaded_file)
                    image6_url = fs.url(name)
                    filename6 = name
                    service.image6 = filename6

            servicetax = ServiceTax.objects.all().first()
            if servicetax:
                servicetax = servicetax.tax
            else:
                servicetax = 0

            service.servicerefnumber = servicerefnumber
            service.invoicenumber = invoicenumber
            service.servicetax = servicetax
            if newcustomerid:
                service.customerid = newcustomerid
            else:
                service.customerid = customerid
            service.firstname = firstname
            service.lastname = lastname
            service.address = address
            service.phone = phone
            service.memodate = memodate
            service.expecteddate = estimateddate
            service.problem = problemdetected
            service.remarks = remarks
            service.warrenty = warrentystatus
            service.status = status
            service.totalamount = total
            service.totaltax = totaltax
            service.discount = discount
            service.finalamount = final
            service.amountrecieved = recieved
            service.duebalance = due
            service.branch = request.user.userprofile.branch
            service.set_accessories(accessories)
            service.product = product
            service.brand = brand
            service.model = model
            service.series = series
            service.imei = imei
            service.frontdesk = request.user
            service.entry_by = request.user
            service.entry_type = "FDE"
            service.screen_password = screen_password
            service.entry_validated = True
            # SG-28
            if customer_gst != "" and customer_gst != "None" and customer_gst != None:
                service.customer_gst_number = customer_gst
            service.customertype = customertype
            service.barcode_number = generate_unique_id("ServiceBarcode", "SB")[2::]
            if servicecharge == "" or servicecharge == None:
                servicecharge = 0
            service.servicecharge = servicecharge
            service.paymentmode = paymentmode
            service.pattern = pattern
            if customer_booking_obj:
                service.booking = customer_booking_obj
                customer_booking_obj.status = "Picked"
                customer_booking_obj.save()

            service.save()

            ############ send whatsapp message ####################
            try:
                fullname = f"{firstname} {lastname}"
                device = f"{brand} {model}"
                sr_number = servicerefnumber
                pdf_byte = get_service_pdf_bytes(request, "order", servicerefnumber)
                whatsapp(
                    phone, pdf_byte, "service_jobsheet", fullname, sr_number, device
                )
            except:
                pass
            ########################################################

            entry_message = f"Service Reference Number : {servicerefnumber} is created by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')} of customer {firstname} {lastname}"
            service_history = ServiceHistory()
            service_history.service = service
            service_history.description = entry_message
            service_history.save()

            try:
                notification = BroadcastNotification()
                notification.message = entry_message
                notification.broadcast_on = timezone.now() + timedelta(seconds=5)
                notification.notification_type = "service_entry"
                notification.notification_id = servicerefnumber
                branch = request.user.userprofile.branch
                notification.user = (
                    UserProfile.objects.filter(
                        Q(branch=branch)
                        & (Q(role="Branch Admin") | Q(role="Franchise Admin"))
                    )
                    .first()
                    .user
                )
                notification.save()
            except:
                pass

            '''try:
                email = (
                    UserProfile.objects.filter(
                        Q(branch=branch)
                        & (Q(role="Branch Admin") | Q(role="Franchise Admin"))
                    )
                    .first()
                    .user.email
                )
                sendEmail(email, "Service Entry", entry_message)
            except:
                pass'''

            if float(recieved) > 0:
                transaction = Transaction()
                transaction.transactionid = servicerefnumber
                transaction.amount = float(recieved)
                transaction.transactiontype = "service"
                transaction.paymentmode = paymentmode
                transaction.branch = request.user.userprofile.branch
                transaction.invoice_number = servicerefnumber
                transaction.accounts = f"{firstname} {lastname}"
                transaction.remarks = ""
                transaction.transactiondate = datetime.now()
                transaction.subledger = func_get_sub_ledgers(request,'Service')
                transaction.save()

      

        servicerefnumber = request.POST.get("refnumber")
        recieved = request.POST.get("amountrecievedservice")
        paymentmode = request.POST.get("paymentmode")
        firstname = request.POST["firstnameservice"]
        lastname = request.POST.get("lastnameservice")

        generate_unique_id("Service", "SR")

    financial_statement = addaccounts.AccountStatement()

    ledger_params = {
        "invoicenumber": servicerefnumber,
        "invoicedate": date.today(),
        "totalamount": final,
        "customer_or_vendor": f"{firstname} {lastname}",
        "userbranch": request.user.userprofile.branch,
        "amountrecieved": request.POST.get("amountrecievedservice"),
        "duebalance": due,
        "paymentmode": paymentmode,
    }

    financial_statement.add_ledger("ServiceEntry", ledger_params)




    

    cashbook_params = {
        "userbranch": request.user.userprofile.branch,
        "amountrecieved": request.POST.get("amountrecievedservice"),
        "paymentmode": paymentmode,
        "invoicedate": date.today(),
        "branch_wid":request.user.userprofile.branch,
        'subledger' : func_get_sub_ledgers(request,'Service')
    }

    financial_statement.add_cashbook("ServiceEntry", cashbook_params)

    generate_unique_id("Invoice", "INV")

    ###### Log the time taken for form submission ######
    end_time = time.time()
    time_taken = end_time - start_time
    performance_logger.debug(f'Service entry form submission end')
    performance_logger.debug(f'Form submission took {time_taken:.2f} seconds.')
    ###### Log the time taken for form submission ######




    ################ Adding In Service Discount Details ###################################

    service_tax = ServiceTax.objects.all().first()
    if service_tax:
        servicetax = service_tax.tax
    else:
        servicetax = 0
    tot_wo_tax = round((float(total) / (1 + (15/100))),2)
    tax = round(tot_wo_tax * (servicetax/100),2) #tot_wo_tax * (servicetax/100)

    serv_discount = ServiceDiscountDetails()
    serv_discount.servicerefnumber = servicerefnumber
    serv_discount.sparetotal_excltax_afterdiscount  = 0
    serv_discount.sparetaxtotal_afterdiscount = 0
    serv_discount.sparetotal_excltax_beforediscount  = 0
    serv_discount.sparetaxtotal_beforediscount = 0
    serv_discount.servivcecost_excltax_afterdiscount = tot_wo_tax
    serv_discount.servicetaxtotal_afterdiscount = tax
    serv_discount.servivcecost_excltax_beforediscount = tot_wo_tax
    serv_discount.servicetaxtotal_beforediscount =tax
    serv_discount.discount_type = 'Flat'
    serv_discount.discount = 0
    serv_discount.save()
        
    #######################################################################################
    if not paymentmode:
        paymentmode = "Cash"
    general_ledger_params = {
        "invoicenumber": servicerefnumber,
        "voucherid": servicerefnumber,
        "invoicedate": date.today(),
        "totalamount": final,
        "description": f"Service Entry for {firstname} {lastname}",
        "userbranch": request.user.userprofile.branch,
        "amountrecieved": request.POST.get("amountrecievedservice"),
        "duebalance": due,
        "paymentmode": paymentmode,
        "customer":customer_ledger
    }

    financial_statement.add_generalledger("ServiceEntry", general_ledger_params)


    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": servicerefnumber})
    )
    # return func_serviceprint(request,servicerefnumber,'order')


@login_required
def serviceAssignReassign(request):

    servicerefnumber = request.POST["refnumber"]
    technician_name = request.POST["technician"]
    status = request.POST["status"]

    technician = User.objects.filter(username=technician_name).first()
    service = Service.objects.filter(servicerefnumber=servicerefnumber).first()
    service.technician = technician
    service.status = status
    service.modifieddate = date.today()
    service.save()

    notification_message = f"Service assigned to {technician} by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
    service_history = ServiceHistory()
    service_history.service = service
    service_history.description = notification_message
    service_history.save()

    try:
        notification = BroadcastNotification()
        notification.message = notification_message
        notification.broadcast_on = timezone.now() + timedelta(seconds=5)
        notification.notification_type = "service_assigned"
        notification.notification_id = servicerefnumber
        branch = request.user.userprofile.branch
        notification.user = technician
        notification.save()
    except:
        pass

    '''try:
        email = technician.email
        sendEmail(email, "Service Assigned", notification_message)
    except:
        pass'''

    

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": servicerefnumber})
    )


@login_required
def acknoledgeService(request):

    servicerefnumber = request.POST["refnumber"]
    status = request.POST["status"]

    service = Service.objects.filter(servicerefnumber=servicerefnumber).first()
    service.status = status
    service.modifieddate = date.today()
    service.save()

    service_history = ServiceHistory()
    service_history.service = service

    service_history.description = f"Service acknoledged by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"

    service_history.save()

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": servicerefnumber})
    )


@login_required
def addServiceInfo(request):

    if request.method == "POST":
        info = request.POST["info"]
        serviceref = request.POST["servicereff"]
        user = request.user

        serviceinfo_obj = ServiceInformations()
        serviceinfo_obj.service = Service.objects.filter(
            servicerefnumber=serviceref
        ).first()
        serviceinfo_obj.info = info
        serviceinfo_obj.user = user
        serviceinfo_obj.save()

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
    )


@login_required
def serviceCnpPending(request):

    if request.method == "POST":
        status = request.POST["pending"]
        cnp_remarks = request.POST["cnpremark"]
        serviceref = request.POST["refnumber"]
        service = Service.objects.filter(servicerefnumber=serviceref).first()
        service.status = status
        service.save()

        if cnp_remarks != None and cnp_remarks != "":
            serviceinfo = ServiceInformations()
            serviceinfo.service = service
            serviceinfo.user = request.user
            serviceinfo.info = cnp_remarks
            serviceinfo.save()

        notification_message = f"Service status changed to 'Pending' by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
        servicehistory = ServiceHistory()
        servicehistory.service = service
        servicehistory.description = notification_message
        servicehistory.save()

        try:
            notification = BroadcastNotification()
            notification.message = notification_message
            notification.broadcast_on = timezone.now() + timedelta(seconds=5)
            notification.notification_type = "cnp_pending"
            notification.notification_id = serviceref
            branch = request.user.userprofile.branch
            notification.user = (
                UserProfile.objects.filter(
                    Q(branch=branch)
                    & (Q(role="Branch Admin") | Q(role="Franchise Admin"))
                )
                .first()
                .user
            )
            notification.save()
        except:
            pass
        '''try:
            email = (
                UserProfile.objects.filter(
                    Q(branch=branch)
                    & (Q(role="Branch Admin") | Q(role="Franchise Admin"))
                )
                .first()
                .user.email
            )
            sendEmail(email, "CNP Pending", notification_message)
        except:
            pass'''

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
    )


@login_required
def verifyQcForm(request):

    if request.method == "POST":

        

        check_status_with_constant = partial(check_status_common, attribute="check")
        length_count = list(filter(check_status_with_constant, request.POST.keys()))


        qcoklist = []
        serviceref = request.POST["servicereff"]
        try:
            faultnofault = request.POST["faultnofault"]
        except:
            faultnofault = "nofault"
        faultremark = request.POST["qcfaultremark"]

        for parameter in range(1, ((len(length_count)+10))):
            try:
                qcoklist.append(request.POST[f"check{parameter}"])
            except:
                pass

        qcnotoklist = [
            param for param in QC_VERIFY_FORM_PARAMETERS_MOBILE if param not in qcoklist
        ]

        service = Service.objects.filter(servicerefnumber=serviceref).first()
        prevstatus = service.status

        if faultnofault == "fault":
            service.status = "QC Failed"
            service.qcremark = faultremark

            serviceinfo = ServiceInformations()
            serviceinfo.service = service
            serviceinfo.user = request.user
            serviceinfo.info = faultremark
            serviceinfo.save()

            notification_message = f"Service failed by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
            servicehistory = ServiceHistory()
            servicehistory.service = service
            servicehistory.description = notification_message
            servicehistory.save()

            try:
                notification = BroadcastNotification()
                notification.message = notification_message
                notification.broadcast_on = timezone.now() + timedelta(seconds=5)
                notification.notification_type = "qc_failed"
                notification.notification_id = serviceref
                branch = request.user.userprofile.branch
                notification.user = service.technician
                notification.save()
            except:
                pass
            '''try:
                email = service.technician.email
                sendEmail(email, "QC Failed", notification_message)
            except:
                pass'''

            try:
                notification = BroadcastNotification()
                notification.message = notification_message
                notification.broadcast_on = timezone.now() + timedelta(seconds=5)
                notification.notification_type = "qc_failed"
                notification.notification_id = serviceref
                branch = request.user.userprofile.branch
                notification.user = (
                    UserProfile.objects.filter(
                        Q(branch=branch)
                        & (Q(role="Branch Admin") | Q(role="Franchise Admin"))
                    )
                    .first()
                    .user
                )
                notification.save()
            except:
                pass
            '''try:
                email = (
                    UserProfile.objects.filter(
                        Q(branch=branch)
                        & (Q(role="Branch Admin") | Q(role="Franchise Admin"))
                    )
                    .first()
                    .user.email
                )
                sendEmail(email, "QC Failed", notification_message)
            except:
                pass'''

        else:
            if prevstatus == "Quality Checking(Ok)" or prevstatus == "Completed":
                service.status = "QC Passed(Ok)"
            elif (
                prevstatus == "Quality Checking(NotOk)" or prevstatus == "Beyond Repair"
            ):

                service.status = "QC Passed(NotOk)"

            notification_message = f"Service passed by {request.user.username} after QC on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"

            servicehistory = ServiceHistory()
            servicehistory.service = service
            servicehistory.description = notification_message
            servicehistory.save()

            try:
                branch = request.user.userprofile.branch
                users = UserProfile.objects.filter(
                    Q(branch=branch)
                    & (
                        Q(role="Branch Admin")
                        | Q(role="Franchise Admin")
                        | Q(role="TRC Cleaning and Packing")
                    )
                )
                for usr in users:
                    notification = BroadcastNotification()
                    notification.message = notification_message
                    notification.broadcast_on = timezone.now() + timedelta(seconds=5)
                    notification.notification_type = "qc_completed"
                    notification.notification_id = serviceref
                    notification.user = usr.user
                    notification.save()
            except:
                pass
            '''try:
                branch = request.user.userprofile.branch
                users = UserProfile.objects.filter(
                    Q(branch=branch)
                    & (
                        Q(role="Branch Admin")
                        | Q(role="Franchise Admin")
                        | Q(role="TRC Cleaning and Packing")
                    )
                )
                for usr in users:
                    sendEmail(usr.user.email, "QC Completed", notification_message)
            except:
                pass'''

        service.set_qcok(qcoklist)
        service.set_qcnotok(qcnotoklist)

        service.save()

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
    )


@login_required
def serviceQcStatusUpdate(request):

    if request.method == "POST":
        serviceref = request.POST["refnumber"]
        status = request.POST["status"]

        service = Service.objects.filter(servicerefnumber=serviceref).first()

        service.status = status
        service.qc = request.user
        service.modifieddate = date.today()
        service.save()

        service_history = ServiceHistory()
        service_history.service = service
        service_history.description = f"Service acknoledged by {request.user.username} for quality checking on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
        service_history.save()

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
    )


@login_required
def serviceRejectReassign(request):

    if request.method == "POST":
        serviceref = request.POST["refnumber"]
        status = request.POST["status"]

        service = Service.objects.filter(servicerefnumber=serviceref).first()
        service.modifieddate = date.today()

        service.status = status

        service.save()

        ############## returning spare parts if service rejected #####33
        spareparts = SpareParts.objects.filter(servicerefnumber=serviceref)
        if spareparts:
            for spare in spareparts:
                product = spare.name
                qty = spare.totalquantity
                stock_product = BranchStock.objects.filter(
                    Q(branch=request.user.userprofile.branch) & Q(name=product)
                ).first()
                stock_qty = stock_product.quantity
                stock_product.quantity = qty + stock_qty
                stock_product.save()

                strans_obj = StockTransaction.objects.filter(
                    Q(
                        product=Products.objects.filter(
                            Q(id=product.id) & Q(branch=request.user.userprofile.branch)
                        ).first()
                    )
                    & Q(branch=request.user.userprofile.branch)
                ).first()
                if strans_obj:
                    stocktr = StockTransaction()
                    stocktr.product = Products.objects.filter(
                        Q(id=product.id) & Q(branch=request.user.userprofile.branch)
                    ).first()
                    stocktr.initial_quantity = strans_obj.initial_quantity
                    stocktr.quantity = qty
                    stocktr.transactiontype = "Add"
                    stocktr.branch = request.user.userprofile.branch
                    try:
                        stocktr.reference_number  = request.POST["refnumber"]
                        stocktr.transaction_category  = 'Service Reject'
                    except:
                        stocktr.reference_number  = 'NA'
                        stocktr.transaction_category  = 'Service Reject'
                    stocktr.save()
                else:
                    stocktr = StockTransaction()
                    stocktr.product = Products.objects.filter(
                        Q(id=product.id) & Q(branch=request.user.userprofile.branch)
                    ).first()
                    stocktr.initial_quantity = 0
                    stocktr.quantity = qty
                    stocktr.transactiontype = "Add"
                    stocktr.branch = request.user.userprofile.branch
                    try:
                        stocktr.reference_number  = request.POST["refnumber"]
                        stocktr.transaction_category  = 'Service Reject'
                    except:
                        stocktr.reference_number  = 'NA'
                        stocktr.transaction_category  = 'Service Reject'
                    stocktr.save()
        ##########################################################

        notification_message = f"Service Rejected by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
        try:
            branch = request.user.userprofile.branch
            users = UserProfile.objects.filter(Q(branch=branch) & (Q(role="TRC QC")))

            for usr in users:
                notification = BroadcastNotification()
                notification.message = notification_message
                notification.broadcast_on = timezone.now() + timedelta(seconds=5)
                notification.notification_type = "not_serviced"
                notification.notification_id = serviceref
                notification.user = usr.user
                notification.save()
        except:
            pass

        try:
            notification = BroadcastNotification()
            notification.message = notification_message
            notification.broadcast_on = timezone.now() + timedelta(seconds=5)
            notification.notification_type = "not_serviced"
            notification.notification_id = serviceref
            notification.user = (
                Service.objects.filter(servicerefnumber=serviceref).first().technician
            )
            notification.save()
        except:
            pass

        service_history = ServiceHistory()
        service_history.service = service
        service_history.description = notification_message
        service_history.save()

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
    )


@login_required
def addServiceCompleteReject(request):

    if request.method == "POST":
        status = request.POST["oknotok"]
        serviceref = request.POST["servicereff"]
        notokcode = request.POST["notokcode"]
        technician_remark = request.POST["servicecompleteremark"]

        service = Service.objects.filter(servicerefnumber=serviceref).first()
        if status == "Rejected":
            service.reject_code = notokcode
        service.technician_remark = technician_remark
        service.modifieddate = date.today()
        service.status = status
        service.save()

        serviceinfo = ServiceInformations()
        serviceinfo.service = service
        serviceinfo.user = request.user
        serviceinfo.info = technician_remark
        serviceinfo.save()

        notification_message = f"Service {status} by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
        servicehistory = ServiceHistory()
        servicehistory.service = service
        servicehistory.description = notification_message
        servicehistory.save()

        if status == "Rejected":
            try:
                notification = BroadcastNotification()
                notification.message = notification_message
                notification.broadcast_on = timezone.now() + timedelta(seconds=5)
                notification.notification_type = "not_serviced"
                notification.notification_id = serviceref
                branch = request.user.userprofile.branch
                notification.user = (
                    UserProfile.objects.filter(
                        Q(branch=branch)
                        & (Q(role="Branch Admin") | Q(role="Franchise Admin"))
                    )
                    .first()
                    .user
                )
                notification.save()
            except:
                pass
            '''try:
                email = (
                    UserProfile.objects.filter(
                        Q(branch=branch)
                        & (Q(role="Branch Admin") | Q(role="Franchise Admin"))
                    )
                    .first()
                    .user.email
                )
                sendEmail(email, "Not Serviced", notification_message)
            except:
                pass'''
        else:
            try:
                branch = request.user.userprofile.branch
                users = UserProfile.objects.filter(
                    Q(branch=branch)
                    & (
                        Q(role="Branch Admin")
                        | Q(role="Franchise Admin")
                        | Q(role="TRC QC")
                    )
                )

                for usr in users:
                    notification = BroadcastNotification()
                    notification.message = notification_message
                    notification.broadcast_on = timezone.now() + timedelta(seconds=5)
                    notification.notification_type = "serviced"
                    notification.notification_id = serviceref
                    branch = request.user.userprofile.branch
                    notification.user = usr.user
                    notification.save()
            except:
                pass
            '''try:
                branch = request.user.userprofile.branch
                users = UserProfile.objects.filter(
                    Q(branch=branch)
                    & (
                        Q(role="Branch Admin")
                        | Q(role="Franchise Admin")
                        | Q(role="TRC QC")
                    )
                )
                for usr in users:
                    sendEmail(
                        usr.user.email, "Serviced Completed", notification_message
                    )
            except:
                pass'''

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
    )


@login_required
def get_customer_details(request):

    if request.method == "POST":

        received_data = QueryDict(request.body)

        phone = received_data.get("phone")

        customer = Customers.objects.filter(phone=phone).first()

        response_data = {
            "customerid": customer.unique_id,
            "firstname": customer.firstname,
            "lastname": customer.lastname,
            "phone": customer.phone,
            "address": customer.address,
            "vatnumber": customer.vatnumber,
            "customertype": customer.customertype,
        }

        return JsonResponse(response_data)


@login_required
def get_customer_details_by_id(request):

    if request.method == "POST":

        received_data = QueryDict(request.body)

        customer_id = received_data.get("customerId")

        customer = Customers.objects.filter(id=int(customer_id)).first()

        response_data = {
            "customerid": customer.unique_id,
            "firstname": customer.firstname,
            "lastname": customer.lastname,
            "phone": customer.phone,
            "address": customer.address,
        }

        return JsonResponse(response_data)


@login_required
def get_customer_booking_details(request):

    if request.method == "POST":

        received_data = QueryDict(request.body)

        id = received_data.get("id")

        customer = CustomerBookingRepair.objects.filter(id=int(id)).first()

        response_data = {
            # "customerid":customer.unique_id,
            "firstname": customer.name,
            # "lastname":customer.lastname,
            "phone": customer.phone,
            "address": customer.city,
            "product": customer.product,
            "brand": customer.brand,
            "issue": customer.issue,
        }

        return JsonResponse(response_data)


@login_required
def get_notifications(request):

    if request.method == "POST":

        received_data = QueryDict(request.body)

        # phone = received_data.get('phone')
        user = request.user

        notifications_list = []
        notifications = BroadcastNotification.objects.filter(user=user)
        active_notification_count = BroadcastNotification.objects.filter(
            Q(user=user) & Q(active=True)
        ).count()

        for notif in notifications:
            data = {}
            data["id"] = notif.id
            data["notification_id"] = notif.notification_id
            data["message"] = notif.message
            data["notification_type"] = notif.notification_type
            data["active"] = notif.active
            utc_time = notif.created_date.replace(tzinfo=timezone.utc)
            created_date = utc_time.astimezone(
                timezone.get_current_timezone()
            ).strftime("%b %d, %Y, %I:%M %p")
            data["created_date"] = created_date
            notifications_list.append(data)

        response_data = {
            "response": notifications_list,
            "active_count": active_notification_count,
        }

        return JsonResponse(response_data)


@login_required
def get_notifications_unseen(request):

    if request.method == "POST":

        received_data = QueryDict(request.body)

        # phone = received_data.get('phone')
        user = request.user

        notifications_list = []
        notifications = BroadcastNotification.objects.filter(
            Q(user=user) & Q(seen=False)
        )
        # active_notification_count = BroadcastNotification.objects.filter(Q(user=user)&Q(seen=False)).count()

        for notif in notifications:
            data = {}
            data["id"] = notif.id
            data["notification_id"] = notif.notification_id
            data["message"] = notif.message
            data["notification_type"] = notif.notification_type
            data["active"] = notif.active
            utc_time = notif.created_date.replace(tzinfo=timezone.utc)
            created_date = utc_time.astimezone(
                timezone.get_current_timezone()
            ).strftime("%b %d, %Y, %I:%M %p")
            data["created_date"] = created_date
            notifications_list.append(data)

        response_data = {
            "response": notifications_list,
            #    'active_count':active_notification_count
        }

        return JsonResponse(response_data)


@login_required
def update_notifications_seen(request):

    if request.method == "POST":

        received_data = QueryDict(request.body)

        id = int(received_data.get("id"))
        user = request.user

        try:
            notification = BroadcastNotification.objects.filter(id=id).first()
            notification.seen = True
            notification.save()

            response_data = {
                "response": "Updated Successfully",
            }
        except:
            response_data = {
                "response": "Updation Failed",
            }

        return JsonResponse(response_data)


@login_required
def update_notifications_active(request):

    if request.method == "POST":

        received_data = QueryDict(request.body)

        id = int(received_data.get("id"))
        user = request.user

        try:
            notification = BroadcastNotification.objects.filter(id=id).first()
            notification.active = False
            notification.save()

            response_data = {
                "response": "Updated Successfully",
            }
        except:
            response_data = {
                "response": "Updation Failed",
            }

        return JsonResponse(response_data)


@login_required
def serviceCnp(request):

    currentuser = request.user

    if currentuser.userprofile.role == "TRC Cleaning and Packing":
        data = Service.objects.filter(
            Q(branch=currentuser.userprofile.branch) & Q(cnp=currentuser)
        ).order_by("-pk")
    elif currentuser.userprofile.role == "TRC QC":
        data = Service.objects.filter(
            Q(branch=currentuser.userprofile.branch) & Q(qc=currentuser)
        ).order_by("-pk")
    elif currentuser.userprofile.role == "TRC Front Desk":
        data = Service.objects.filter(
            Q(branch=currentuser.userprofile.branch) & Q(frontdesk=currentuser)
        ).order_by("-pk")

    servicerefno_set = set()
    datafinal = [
        service
        for service in data
        if (
            service.servicerefnumber not in servicerefno_set
            and not servicerefno_set.add(service.servicerefnumber)
        )
    ]

    today = date.today()

    service_final = []
    for i in datafinal:

        service_dict = {
            "servicerefnumber": i.servicerefnumber,
            "customerid": i.customerid,
            "firstname": i.firstname,
            "lastname": i.lastname,
            "address": i.address,
            "phone": i.phone,
            "memodate": i.memodate,
            "expecteddate": i.expecteddate,
            "product": i.product,
            "brand": i.brand,
            "model": i.model,
            "imei": i.imei,
            "servicecharge": i.servicecharge,
            "problem": i.problem,
            "remarks": i.remarks,
            "status": i.status,
            "warrenty": i.warrenty,
            "totalamount": i.totalamount,
            "discount": i.discount,
            "finalamount": i.finalamount,
            "amountrecieved": i.amountrecieved,
            "duebalance": i.duebalance,
            "branch": i.branch,
            "createddate": i.createddate,
            "paymentmode": i.paymentmode,
            "technician": i.technician,
            "rack_no": i.rack_no,
        }
        if i.expecteddate != None and i.expecteddate != "":
            diff = i.expecteddate - today
            service_dict["datedifference"] = f"{diff.days} days left"
            if diff.days < 0:
                service_dict["datedifferencecolor"] = "red"
            elif diff.days == 0:
                service_dict["datedifferencecolor"] = "orange"
                service_dict["datedifference"] = "Today"
            elif diff.days >= 1:
                service_dict["datedifferencecolor"] = "green"
        else:
            service_dict["datedifference"] = ""
            service_dict["datedifferencecolor"] = ""

        service_final.append(service_dict)

    context = {
        "data": service_final,
    }
    return render(request, "myservice.html", context)


@login_required
def serviceCompletedFd(request):

    currentuser = request.user

    if (
        currentuser.userprofile.role == "TRC Front Desk"
        or request.user.userprofile.role == "Franchise Admin"
        or request.user.userprofile.role == "Branch Admin"
    ):
        data = Service.objects.filter(
            Q(branch=currentuser.userprofile.branch)
            & (Q(status="CNP Completed(Ok)") | Q(status="CNP Completed(NotOk)"))
        ).order_by("-pk")
    elif currentuser.is_superuser:
        data = Service.objects.filter(
            Q(status="CNP Completed(Ok)") | Q(status="CNP Completed(NotOk)")
        ).order_by("-pk")

    context = {
        "data": data,
    }
    return render(request, "servicecompletedfd.html", context)


# @never_cache
# @login_required
# def serviceCheckout(request, servicerefnumber):

#     currentuser = request.user

#     serviceobj = Service.objects.filter(servicerefnumber=servicerefnumber).first()
#     status = serviceobj.status
#     firstname = serviceobj.firstname
#     lastname = serviceobj.lastname
#     customerid = serviceobj.customerid
#     phone = serviceobj.phone
#     customer_phone = serviceobj.phone
#     expecteddate = serviceobj.expecteddate
#     receiveddate = serviceobj.memodate
#     paymentmode_selected = serviceobj.paymentmode
#     discountmethod_selected = serviceobj.discountmethod

#     if status == "CNP Completed(NotOk)":
#         servicecharge = 0
#         estimatedprice = 0
#         totalamount = 0
#         discount = 0
#         discountperc = 0
#         amountrecieved = 0
#         duebalance = 0
#         ###### delete allocated spare #######
#         SpareParts.objects.filter(servicerefnumber=servicerefnumber).delete()
#         ####### delete spare requests ########
#         SpareRequests.objects.filter(service=serviceobj).delete()
#         #####################################
#     else:
#         servicecharge = serviceobj.servicecharge
#         estimatedprice = serviceobj.finalamount
#         totalamount = serviceobj.totalamount
#         discount = serviceobj.discount
#         discountperc = serviceobj.discountpercentage
#         amountrecieved = serviceobj.amountrecieved
#         duebalance = serviceobj.duebalance


#     product = serviceobj.product
#     brand = serviceobj.brand
#     modal = serviceobj.model
#     malfunction = serviceobj.problem
#     currentdate = date.today()
#     imei = serviceobj.imei
#     address = serviceobj.address
#     rack_no = serviceobj.rack_no
#     technician = serviceobj.technician
#     image1 = serviceobj.image1
#     image2 = serviceobj.image2
#     image3 = serviceobj.image3
#     image4 = serviceobj.image4
#     image5 = serviceobj.image5
#     image6 = serviceobj.image6
#     branch = serviceobj.branch

#     if (
#         serviceobj.totaltax == None
#         or serviceobj.totaltax == ""
#         or status == "CNP Completed(NotOk)"
#     ):
#         totaltax = 0
#     else:
#         totaltax = serviceobj.totaltax

#     servicetax = serviceobj.servicetax

#     company = request.user.userprofile.company
#     company_name = company.company_name
#     if branch.name == "WAREHOUSE":
#         address_line1 = company.address_line1
#         address_line2 = company.address_line2
#         address_line3 = company.address_line3
#         phone = ""
#     else:
#         address_line1 = branch.address
#         phone = branch.phone
#         address_line2 = ""
#         address_line3 = ""
#     logo = company.logo_url
#     paymentmode = PaymentMode.objects.all()

#     try:
#         logo_url = GLOBAL_VARIABLES["current_host"] + logo.url
#     except:
#         logo_url = ""


#     ###### spare tax calculation 11/10/2024 ###########

#     spare_obj = SpareParts.objects.filter(servicerefnumber=servicerefnumber)
#     spare_tx = 0
#     for item in spare_obj:
#         tx= item.price * (float(item.salegst)/100)
#         spare_tx += tx

    

#     ###################################################

#     context = {
#         "spare_tax":spare_tx,
#         "customer_phone": customer_phone,
#         "servicetax": servicetax,
#         "service_charge": round(servicecharge, 2),
#         "totalamount": round(totalamount, 2),
#         "totaltax": round(totaltax, 2),
#         "finalamount": round(estimatedprice, 2),
#         "discount": round(discount, 2),
#         "discountperc":discountperc,
#         "amountrecieved": round(amountrecieved, 2),
#         "duebalance": round(duebalance, 2),
#         "product": product,
#         "address": address,
#         "customerid": customerid,
#         "phone": phone,
#         "price": estimatedprice,
#         "estimateddate": expecteddate,
#         "receiveddate": receiveddate,
#         "firstname": firstname,
#         "lastname": lastname,
#         "serviceref": servicerefnumber,
#         "brand": brand,
#         "modal": modal,
#         "malfunction": malfunction,
#         "company_name": company_name,
#         "address_line1": address_line1,
#         "address_line2": address_line2,
#         "address_line3": address_line3,
#         # 'logo':logo,
#         "logo": logo_url,
#         "currentdate": currentdate,
#         "imei": imei,
#         "rack_no": rack_no,
#         "technician": technician,
#         "image1": image1,
#         "image2": image2,
#         "image3": image3,
#         "image4": image4,
#         "image5": image5,
#         "image6": image6,
#         "current_user": currentuser,
#         "branch": branch,
#         "current_host": str(request.get_host()),
#         "status": status,
#         "paymentmode_selected": paymentmode_selected,
#         "paymentmode": paymentmode,
#         "discountmethod_selected":discountmethod_selected,
#     }

#     spare = SpareParts.objects.filter(servicerefnumber=servicerefnumber)
#     spare_list = []
#     for i in spare:
#         data = {}
#         data["name"] = i.name
#         data["price"] = i.price
#         data["salegst"] = i.salegst
#         data["totalquantity"] = i.totalquantity
#         data["barcodenumber"] = i.barcodenumber
#         if i.price and i.salegst:
#             try:
#                 data["total"] = (
#                     float(i.price) + ((float(i.salegst) / 100) * float(i.price))
#                 ) * int(i.totalquantity)
#             except:
#                 data["total"] = ""
#         else:
#             data["total"] = ""

#         spare_list.append(data)

#     if spare:
#         context["spare"] = spare_list
#     else:
#         context["spare"] = 0

#     return render(request, "servicecheckout.html", context)
   






@never_cache
@login_required
def serviceCheckout(request, servicerefnumber):

    currentuser = request.user



    serviceobj = Service.objects.filter(servicerefnumber=servicerefnumber).first()
    status = serviceobj.status
    firstname = serviceobj.firstname
    lastname = serviceobj.lastname
    customerid = serviceobj.customerid
    phone = serviceobj.phone
    customer_phone = serviceobj.phone
    expecteddate = serviceobj.expecteddate
    receiveddate = serviceobj.memodate
    paymentmode_selected = serviceobj.paymentmode
    discountmethod_selected = serviceobj.discountmethod

    if status == "CNP Completed(NotOk)":
        servicecharge = 0
        estimatedprice = 0
        totalamount = 0
        discount = 0
        discountperc = 0
        amountrecieved = 0
        duebalance = 0
        ###### delete allocated spare #######
        SpareParts.objects.filter(servicerefnumber=servicerefnumber).delete()
        ####### delete spare requests ########
        SpareRequests.objects.filter(service=serviceobj).delete()
        #####################################
    else:
        servicecharge = serviceobj.servicecharge
        estimatedprice = serviceobj.finalamount
        totalamount = serviceobj.totalamount
        discount = serviceobj.discount
        discountperc = serviceobj.discountpercentage
        amountrecieved = serviceobj.amountrecieved
        duebalance = serviceobj.duebalance


    product = serviceobj.product
    brand = serviceobj.brand
    modal = serviceobj.model
    malfunction = serviceobj.problem
    currentdate = date.today()
    imei = serviceobj.imei
    address = serviceobj.address
    rack_no = serviceobj.rack_no
    technician = serviceobj.technician
    image1 = serviceobj.image1
    image2 = serviceobj.image2
    image3 = serviceobj.image3
    image4 = serviceobj.image4
    image5 = serviceobj.image5
    image6 = serviceobj.image6
    branch = serviceobj.branch

    if (
        serviceobj.totaltax == None
        or serviceobj.totaltax == ""
        or status == "CNP Completed(NotOk)"
    ):
        totaltax = 0
    else:
        totaltax = serviceobj.totaltax

    servicetax = serviceobj.servicetax

    company = request.user.userprofile.company
    company_name = company.company_name
    if branch.name == "WAREHOUSE":
        address_line1 = company.address_line1
        address_line2 = company.address_line2
        address_line3 = company.address_line3
        phone = ""
    else:
        address_line1 = branch.address
        phone = branch.phone
        address_line2 = ""
        address_line3 = ""
    logo = company.logo_url
    paymentmode = PaymentMode.objects.all()

    try:
        logo_url = GLOBAL_VARIABLES["current_host"] + logo.url
    except:
        logo_url = ""


    ###### spare tax and spare total calculations calculation 11/10/2024 ###########

    spare_obj = SpareParts.objects.filter(servicerefnumber=servicerefnumber)
    spare_tx = 0
    spare_cost_total = 0

    for item in spare_obj:
        tx= (item.price * (float(item.salegst)/100)) * (item.totalquantity)
        spare_tx += tx
        spare_ttl = (item.price + (item.price * (float(item.salegst)/100))) * (item.totalquantity)
        spare_cost_total += spare_ttl
     
    #################### service charge excluding tax ###############################

    service_charge_excluding_tax = servicecharge - totaltax

    # print("service charge exclding tax",service_charge_excluding_tax,totaltax,servicecharge)

    ################## after discount calculations ########################
    sparecostafter_discount_excltax=0
    sparetax_afterdiscount=0
    sparecostafter_discount_incltax = 0

    service_charge_excluding_tax_wdiscount =0
    service_charge_excluding_tax_afterdiscount = 0
    service_tax_after_discount = 0

    # if round(discount, 2) > 0:
    if ServiceDiscountDetails.objects.filter(servicerefnumber=servicerefnumber).first():
        servicediscountobj =ServiceDiscountDetails.objects.filter(servicerefnumber=servicerefnumber).first()
        sparecostafter_discount_excltax = servicediscountobj.sparetotal_excltax_afterdiscount 
        sparetax_afterdiscount=servicediscountobj.sparetaxtotal_afterdiscount
        sparecostafter_discount_incltax = sparecostafter_discount_excltax + sparetax_afterdiscount
        service_charge_excluding_tax_wdiscount= servicediscountobj.servivcecost_excltax_beforediscount
        service_charge_excluding_tax_afterdiscount = servicediscountobj.servivcecost_excltax_afterdiscount
        service_tax_after_discount = servicediscountobj.servicetaxtotal_afterdiscount

    # print("-----",sparecostafter_discount_excltax,sparetax_afterdiscount,sparecostafter_discount_incltax)


    context = {
        "sparecostafter_discount_incltax":round(sparecostafter_discount_incltax,2),
        "sparetax_afterdiscount":round(sparetax_afterdiscount,2),
         "service_charge_excluding_tax":round(service_charge_excluding_tax,2),
        "service_charge_excluding_tax_wdiscount":round(service_charge_excluding_tax_wdiscount,2),
        "service_charge_excluding_tax_afterdiscount":round(service_charge_excluding_tax_afterdiscount,2),
        "service_tax_after_discount":round(service_tax_after_discount,2),
        "spare_cost_total":spare_cost_total,
        "spare_tax":spare_tx,
        "customer_phone": customer_phone,
        "servicetax": servicetax,
        "service_charge": round(servicecharge, 2),
        "totalamount": round(totalamount, 2),
        "totaltax": round(totaltax, 2),
        "finalamount": round(estimatedprice, 2),
        "discount": round(discount, 2),
        "discountperc":discountperc,
        "amountrecieved": round(amountrecieved, 2),
        "duebalance": round(duebalance, 2),
        "product": product,
        "address": address,
        "customerid": customerid,
        "phone": phone,
        "price": estimatedprice,
        "estimateddate": expecteddate,
        "receiveddate": receiveddate,
        "firstname": firstname,
        "lastname": lastname,
        "serviceref": servicerefnumber,
        "brand": brand,
        "modal": modal,
        "malfunction": malfunction,
        "company_name": company_name,
        "address_line1": address_line1,
        "address_line2": address_line2,
        "address_line3": address_line3,
        # 'logo':logo,
        "logo": logo_url,
        "currentdate": currentdate,
        "imei": imei,
        "rack_no": rack_no,
        "technician": technician,
        "image1": image1,
        "image2": image2,
        "image3": image3,
        "image4": image4,
        "image5": image5,
        "image6": image6,
        "current_user": currentuser,
        "branch": branch,
        "current_host": str(request.get_host()),
        "status": status,
        "paymentmode_selected": paymentmode_selected,
        "paymentmode": paymentmode,
        "discountmethod_selected":discountmethod_selected,
    }

    spare = SpareParts.objects.filter(servicerefnumber=servicerefnumber)
    spare_list = []
  
    for i in spare:
        data = {}
        data["name"] = i.name
        data["price"] = i.price
        data["salegst"] = i.salegst
        data["totalquantity"] = i.totalquantity
        data["barcodenumber"] = i.barcodenumber
        if i.price and i.salegst:
            try:
                data["total"] = round((
                    float(i.price) + ((float(i.salegst) / 100) * float(i.price))
                ) * int(i.totalquantity),2)
               
            except:
                data["total"] = ""
        else:
            data["total"] = ""

        spare_list.append(data)

    
    
    if spare:
        context["spare"] = spare_list
    else:
        context["spare"] = 0

    return render(request, "servicecheckoutduplicate.html", context)



@never_cache
@login_required
def serviceBillingCheckout(request, servicerefnumber):

    try:
        total = float(request.POST["finaltotal"])
    except:
        total = None
    try:
        discount = float(request.POST["finaldiscount"])
    except:
        discount = None
    try:
        final = float(request.POST["finalfinalamount"])
    except:
        final = None
    try:
        received = float(request.POST["finalamountreceived"])
    except:
        received = None
    try:
        due = float(request.POST["finalduebalance"])
    except:
        due = None
    try:
        paymentmode = request.POST["paymentmode"]
    except:
        paymentmode = None
    try:
        tax_service = request.POST["totaltaxcheckout"]
    except:
        tax_service = None
    try:
        service_charge = request.POST["servicecost"]
    except:
        service_charge = None

    try:
        discountmethod = request.POST["finaldiscountmethod"]
    except:
        discountmethod = None


    if final and received:
        if float(final) < float(received):
            messages.error(request, "Amount Received can't be more than Final Amount!")
            return redirect(
                reverse(
                    "servicecheckout", kwargs={"servicerefnumber": servicerefnumber}
                )
            )


    service = Service.objects.filter(servicerefnumber=servicerefnumber).first()
    prev_recieved = float(service.amountrecieved)
    prev_status = service.status
    prev_discount =service.discount
    prev_tot_tax = service.totaltax

    
    ###### 25/10/2024 ######

    # if float(request.POST.get('finaldiscount',0)) > 0:
    if prev_status == "CNP Completed(Ok)":

        if prev_discount != float(request.POST.get('finaldiscount',0)) or tax_service != prev_tot_tax:
            sparetotal_incltax_afterdiscount = request.POST.get('spare_cost_total',None)
            sparetaxtotal_afterdiscount = request.POST.get('sparetx2',None)
            sparetotal_excltax_afterdiscount = float(sparetotal_incltax_afterdiscount) - float(sparetaxtotal_afterdiscount)
            
            sparetotal_excltax_beforediscount = 0
            sparetaxtotal_beforediscount = 0
            spareparts_obj = SpareParts.objects.filter(servicerefnumber=servicerefnumber)
            for item in spareparts_obj:
                qty = item.totalquantity
                price = item.price
                tax = float(item.salegst)
                price_tax = (item.price * (tax/100)) * qty
                sparetotal_excltax_beforediscount += price
                sparetaxtotal_beforediscount += price_tax

            servicecost_excltax_afterdiscount = request.POST.get('servicecostexcltaxafterdiscount',None)
            servicetaxtotal_afterdiscount = request.POST.get('totaltaxcheckout',None)
            servicecost_excltax_beforediscount = request.POST.get('servicecostexcltax',None)
            tx = ServiceTax.objects.all().first().tax
            servicetaxtotal_beforediscount = round(float(servicecost_excltax_beforediscount) * (tx/100),2)


            serv_obj = ServiceDiscountDetails.objects.filter(servicerefnumber=servicerefnumber).first()
            if serv_obj:
                serv_discount=serv_obj
            else:
                serv_discount = ServiceDiscountDetails()
            serv_discount.servicerefnumber = servicerefnumber
            serv_discount.sparetotal_excltax_afterdiscount  = float(sparetotal_excltax_afterdiscount)
            serv_discount.sparetaxtotal_afterdiscount = float(sparetaxtotal_afterdiscount)
            serv_discount.sparetotal_excltax_beforediscount  = float(sparetotal_excltax_beforediscount)
            serv_discount.sparetaxtotal_beforediscount = float(sparetaxtotal_beforediscount)
            serv_discount.servivcecost_excltax_afterdiscount = float(servicecost_excltax_afterdiscount)
            serv_discount.servicetaxtotal_afterdiscount = float(servicetaxtotal_afterdiscount)
            serv_discount.servivcecost_excltax_beforediscount = float(servicecost_excltax_beforediscount)
            serv_discount.servicetaxtotal_beforediscount =float(servicetaxtotal_beforediscount)
            serv_discount.discount_type = request.POST["finaldiscountmethod"]
            serv_discount.discount = float(request.POST.get('finaldiscount',0))
            serv_discount.save()
        
            ########################

    if discountmethod == 'Percentage':
        ######## 12-9-2024 servicecharge with tax ##################
        # total_before_disc = float(total) + float(tax)
        total_before_disc = float(total) 
        ######## 12-9-2024 servicecharge with tax ##################
        discountpercentage = discount
        discount = (total_before_disc *(discountpercentage/100))

    else:
        discountpercentage = None


    

    service = Service.objects.filter(servicerefnumber=servicerefnumber).first()

    prev_recieved = float(service.amountrecieved)

    firstname = request.POST["firstname"]
    lastname = request.POST["lastname"]
    prev_status = service.status


    # Do not save anything if amount recieved is 0 or not larger than previous recieved
    if prev_status == "CNP Completed(Ok)":
        if received == prev_recieved or received == 0 or received < prev_recieved:
           if due != 0:
                ########### 2/11/2024 #########
                if total != None:
                    service.totalamount = total
                if discount != None:
                    service.discount = discount
                if final != None:
                    service.finalamount = final
                if received != None:
                    service.amountrecieved = received
                if due != None:
                    service.duebalance = due
                if paymentmode != None:
                    service.paymentmode = paymentmode
                if tax_service != None:
                    service.totaltax = tax_service
                    if float(tax_service) == 0.0:
                        service.servicetax = 0
                    else:
                        servicetax = ServiceTax.objects.all().first()
                        service.servicetax = servicetax.tax
                if service_charge:
                    service.servicecharge = float(service_charge)
                if discountmethod:
                    service.discountmethod = discountmethod
                service.discountpercentage = discountpercentage
                service.modifieddate = date.today()
                service.save()
                ########### 2/11/2024 #########
                
                return redirect(
                    reverse(
                        "servicecheckout", kwargs={"servicerefnumber": servicerefnumber}
                    )
                )

                

    if received:
        if prev_status == "CNP Completed(Ok)":
            if float(received) != 0:
                if prev_recieved != received and received > prev_recieved:
                    recieved_amount = received - prev_recieved
                    transaction = Transaction()
                    transaction.transactionid = servicerefnumber
                    transaction.amount = float(recieved_amount)
                    transaction.transactiontype = "service"
                    transaction.paymentmode = paymentmode
                    transaction.branch = request.user.userprofile.branch
                    transaction.invoice_number = servicerefnumber
                    transaction.accounts = f"{firstname} {lastname}"
                    transaction.remarks = ""
                    transaction.transactiondate = datetime.now()
                    transaction.subledger = func_get_sub_ledgers(request,'Service')
                    transaction.save()

    if total != None:
        service.totalamount = total
    if discount != None:
        service.discount = discount
    if final != None:
        service.finalamount = final
    if received != None:
        service.amountrecieved = received
    if due != None:
        service.duebalance = due
    if paymentmode != None:
        service.paymentmode = paymentmode
    if tax_service != None:
        service.totaltax = tax_service
        if float(tax_service) == 0.0:
            service.servicetax = 0
        else:
            servicetax = ServiceTax.objects.all().first()
            service.servicetax = servicetax.tax
    if service_charge:
        service.servicecharge = float(service_charge)
    if discountmethod:
        service.discountmethod = discountmethod
    service.discountpercentage = discountpercentage

    if due == 0:
        if prev_status == "CNP Completed(Ok)":
            service.status = "Delivered(Ok)"
        elif prev_status == "CNP Completed(NotOk)":
            service.status = "Delivered(NotOk)"
        service.invoicedate = datetime.now()


        servicehistory = ServiceHistory()
        servicehistory.service = service
        servicehistory.description = f"Item Delivered by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
        servicehistory.save()

    service.modifieddate = date.today()
    service.save()

    if due == 0:
        ############ send whatsapp message after full payment ####################
        try:
            fullname = f"{service.firstname} {service.lastname}"
            device = f"{service.brand} {service.model}"
            sr_number = service.servicerefnumber
            pdf_byte = get_service_pdf_bytes(request, "invoice", sr_number)
            phone = service.phone
            whatsapp(phone, pdf_byte, "service_invoice", fullname, sr_number, device)
        except:
            pass
        #######################################################

    financial_statement = addaccounts.AccountStatement()

    ledger_params = {
        "invoicenumber": servicerefnumber,
        "invoicedate": date.today(),
        "totalamount": final,
        "customer_or_vendor": f"{firstname} {lastname}",
        "userbranch": request.user.userprofile.branch,
        "amountrecieved": received,
        "previousreceived": prev_recieved,
        "duebalance": due,
        "paymentmode": paymentmode,
    }

    financial_statement.add_ledger("ServiceCheckout", ledger_params)


    general_ledger_params = {
        "invoicenumber": servicerefnumber,
        "voucherid": servicerefnumber,
        "invoicedate": date.today(),
        "totalamount": final,
        "description": f"Service Checkout for {firstname} {lastname}",
        "userbranch": request.user.userprofile.branch,
        "amountrecieved": received,
        "previousreceived": prev_recieved,
        "duebalance": due,
        "paymentmode": paymentmode,
    }

    financial_statement.add_generalledger("ServiceCheckout", general_ledger_params)
  

    ########################## edited on 9-9-2024 #######################
    if received:
        if prev_status == "CNP Completed(Ok)":
            if float(received) != 0:
                if prev_recieved != received and received > prev_recieved:
                    recieved_amount = received - prev_recieved
                    cashbook_params = {
                        "userbranch": request.user.userprofile.branch,
                        "amountrecieved": recieved_amount,
                        "paymentmode": paymentmode,
                        "invoicedate": date.today(),
                        "branch_wid":request.user.userprofile.branch,
                        'subledger' : func_get_sub_ledgers(request,'Service')
                    }

                    financial_statement.add_cashbook("ServiceCheckout", cashbook_params)


    # service_ledger = ledgercli.LedgerBook(request.user.userprofile.branch)

    if received != None:
        service_amount = received - prev_recieved
    else:
        service_amount = 0
    service_amount = round(service_amount, 2)

    if firstname and lastname:
        service_customer = f"{firstname}_{lastname}"
    else:
        service_customer = f"{firstname}"


    ##### 25/10/2024 #####

    if float(request.POST.get('finaldiscount',0)) > 0:
        sparecostafter_discount_excltax=0
        sparetax_afterdiscount=0
        service_cost_afterdiscount = 0
        servicetax_aftrdiscount = 0
        servicediscountobj =ServiceDiscountDetails.objects.filter(servicerefnumber=servicerefnumber).first()
        if servicediscountobj:
            sparecostafter_discount_excltax = servicediscountobj.sparetotal_excltax_afterdiscount 
            sparetax_afterdiscount=servicediscountobj.sparetaxtotal_afterdiscount
            service_cost_afterdiscount = servicediscountobj.servivcecost_excltax_afterdiscount
            servicetax_aftrdiscount = servicediscountobj.servicetaxtotal_afterdiscount
            spare_obj = SpareParts.objects.filter(servicerefnumber=servicerefnumber)
            for item in spare_obj:
                tx= (item.price * (float(item.salegst)/100)) * item.totalquantity
                ttl = item.price * item.totalquantity

        total_excl_tax_afterdic = sparecostafter_discount_excltax + service_cost_afterdiscount
        total_tx_afterdisc = sparetax_afterdiscount + servicetax_aftrdiscount
        totalservicetax = total_tx_afterdisc
    else:
        # if tax != None:
        if float(tax_service) != None:
            servicetax = tax_service
        else:
            servicetax = 0
        spareparts = SpareParts.objects.filter(servicerefnumber=servicerefnumber)
        totalsparetax = 0
        for item in spareparts:
            sparegst = item.salegst
            totalsparetax = totalsparetax + (item.price * item.totalquantity * float(sparegst) / 100)

        totalservicetax = float(totalsparetax) + float(servicetax)


    ###################################################
    # params = {
    #     "invoicedate": date.today(),
    #     "mode": paymentmode,
    #     "taxamount": round(totalservicetax, 2),
    #     "invoiceno": servicerefnumber,
    #     "amountreceived": received,
    #     "amountprevious_received": prev_recieved,
    #     "customer": service_customer,
    #     "duebalance": due,
    # }

    # service_ledger.post_service(**params)
    ##################################################################################
    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": servicerefnumber})
    )


# @never_cache
# @login_required
# def serviceBillingCheckout(request, servicerefnumber):

#     try:
#         total = float(request.POST["finaltotal"])
#     except:
#         total = None
#     try:
#         discount = float(request.POST["finaldiscount"])
#     except:
#         discount = None
#     try:
#         final = float(request.POST["finalfinalamount"])
#     except:
#         final = None
#     try:
#         received = float(request.POST["finalamountreceived"])
#     except:
#         received = None
#     try:
#         due = float(request.POST["finalduebalance"])
#     except:
#         due = None
#     try:
#         paymentmode = request.POST["paymentmode"]
#     except:
#         paymentmode = None
#     try:
#         tax = request.POST["totaltaxcheckout"]
#     except:
#         tax = None
#     try:
#         service_charge = request.POST["servicecost"]
#     except:
#         service_charge = None

#     try:
#         discountmethod = request.POST["finaldiscountmethod"]
#     except:
#         discountmethod = None

    


#     if discountmethod == 'Percentage':
#         ######## 12-9-2024 servicecharge with tax ##################
#         # total_before_disc = float(total) + float(tax)
#         total_before_disc = float(total) 
#         ######## 12-9-2024 servicecharge with tax ##################
#         discountpercentage = discount
#         discount = (total_before_disc *(discountpercentage/100))

#     else:
#         discountpercentage = None


#     if final and received:
#         if float(final) < float(received):
#             messages.error(request, "Amount Received can't be more than Final Amount!")
#             return redirect(
#                 reverse(
#                     "servicecheckout", kwargs={"servicerefnumber": servicerefnumber}
#                 )
#             )

#     service = Service.objects.filter(servicerefnumber=servicerefnumber).first()

#     prev_recieved = float(service.amountrecieved)

#     firstname = request.POST["firstname"]
#     lastname = request.POST["lastname"]
#     prev_status = service.status


#     # Do not save anything if amount recieved is 0 or not larger than previous recieved
#     if prev_status == "CNP Completed(Ok)":
#         if received == prev_recieved or received == 0 or received < prev_recieved:
#             messages.error(request, "Amount received cannot be zero or less than or equal to the previously received amount!")
#             return redirect(
#                 reverse(
#                     "servicecheckout", kwargs={"servicerefnumber": servicerefnumber}
#                 )
#             )

                

#     if received:
#         if prev_status == "CNP Completed(Ok)":
#             if float(received) != 0:
#                 if prev_recieved != received and received > prev_recieved:
#                     recieved_amount = received - prev_recieved
#                     transaction = Transaction()
#                     transaction.transactionid = servicerefnumber
#                     transaction.amount = float(recieved_amount)
#                     transaction.transactiontype = "service"
#                     transaction.paymentmode = paymentmode
#                     transaction.branch = request.user.userprofile.branch
#                     transaction.invoice_number = servicerefnumber
#                     transaction.accounts = f"{firstname} {lastname}"
#                     transaction.remarks = ""
#                     transaction.save()

#     if total != None:
#         service.totalamount = total
#     if discount != None:
#         service.discount = discount
#     if final != None:
#         service.finalamount = final
#     if received != None:
#         service.amountrecieved = received
#     if due != None:
#         service.duebalance = due
#     if paymentmode != None:
#         service.paymentmode = paymentmode
#     if tax != None:
#         service.totaltax = tax
#         if float(tax) == 0.0:
#             service.servicetax = 0
#         else:
#             servicetax = ServiceTax.objects.all().first()
#             service.servicetax = servicetax.tax
#     if service_charge:
#         service.servicecharge = float(service_charge)
#     if discountmethod:
#         service.discountmethod = discountmethod
#     service.discountpercentage = discountpercentage

#     if due == 0:
#         if prev_status == "CNP Completed(Ok)":
#             service.status = "Delivered(Ok)"
#         elif prev_status == "CNP Completed(NotOk)":
#             service.status = "Delivered(NotOk)"
#         service.invoicedate = datetime.now()

#         #######  Changing boooking status ##########
#         # if service.booking != None and service.booking != '':
#         #     booking = service.booking
#         #     booking.status = 'Delivered'
#         #     booking.save()
#         #######  Changing boooking status ##########

#         ############ send whatsapp message 0 amount recieved ####################
#         # try:
#         #     fullname=f"{service.firstname} {service.lastname}"
#         #     device=f"{service.brand} {service.model}"
#         #     sr_number=service.servicerefnumber
#         #     pdf_byte = get_service_pdf_bytes(request,"invoice",sr_number)
#         #     phone=service.phone
#         #     whatsapp(phone,pdf_byte,'service_invoice',fullname,sr_number,device)
#         # except:
#         #     pass
#         #######################################################

#         servicehistory = ServiceHistory()
#         servicehistory.service = service
#         servicehistory.description = f"Item Delivered by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
#         servicehistory.save()

#     service.modifieddate = date.today()
#     service.save()

#     if due == 0:
#         ############ send whatsapp message after full payment ####################
#         try:
#             fullname = f"{service.firstname} {service.lastname}"
#             device = f"{service.brand} {service.model}"
#             sr_number = service.servicerefnumber
#             pdf_byte = get_service_pdf_bytes(request, "invoice", sr_number)
#             phone = service.phone
#             whatsapp(phone, pdf_byte, "service_invoice", fullname, sr_number, device)
#         except:
#             pass
#         #######################################################

#     financial_statement = addaccounts.AccountStatement()

#     ledger_params = {
#         "invoicenumber": servicerefnumber,
#         "invoicedate": date.today(),
#         "totalamount": final,
#         "customer_or_vendor": f"{firstname} {lastname}",
#         "userbranch": request.user.userprofile.branch,
#         "amountrecieved": received,
#         "previousreceived": prev_recieved,
#         "duebalance": due,
#     }

#     financial_statement.add_ledger("ServiceCheckout", ledger_params)
  

#     ########################## edited on 9-9-2024 #######################
#     if received:
#         if prev_status == "CNP Completed(Ok)":
#             if float(received) != 0:
#                 if prev_recieved != received and received > prev_recieved:
#                     recieved_amount = received - prev_recieved
#                     cashbook_params = {
#                         "userbranch": request.user.userprofile.branch,
#                         "amountrecieved": recieved_amount,
#                         "paymentmode": paymentmode,
#                         "invoicedate": date.today(),
#                     }

#                     financial_statement.add_cashbook("ServiceCheckout", cashbook_params)

#     # cashbook_params = {
#     #     "userbranch": request.user.userprofile.branch,
#     #     "amountrecieved": received,
#     #     "paymentmode": paymentmode,
#     #     "invoicedate": date.today(),
#     # }

#     # financial_statement.add_cashbook("ServiceCheckout", cashbook_params)

#     ######################################################################

#     # service_ledger = ledgercli.LedgerBook(request.user.userprofile.branch)

#     # if received:
#     #     if prev_status == "CNP Completed(Ok)":
#     #         if float(received) != 0:
#     #             if prev_recieved != received and received > prev_recieved:
#     #                 if tax != None:
#     #                     servicetax = tax
#     #                 else:
#     #                     servicetax = 0

#     #                 if received != None:
#     #                     service_amount = received - prev_recieved
#     #                 else:
#     #                     service_amount = 0
#     #                 service_amount = round(service_amount, 2)

#     #                 if firstname and lastname:
#     #                     service_customer = f"{firstname}_{lastname}"
#     #                 else:
#     #                     service_customer = f"{firstname}"
                    

#     #                 spareparts = SpareParts.objects.filter(servicerefnumber=servicerefnumber)
#     #                 totalsparetax = 0
#     #                 for item in spareparts:
#     #                     sparegst = item.salegst
#     #                     totalsparetax = totalsparetax + (item.price * item.totalquantity * float(sparegst) / 100)

#     #                 totalservicetax = float(totalsparetax) + float(servicetax)
#     #                 params = {
#     #                     "invoicedate": date.today(),
#     #                     "mode": paymentmode,
#     #                     "taxamount": round(totalservicetax, 2),
#     #                     "invoiceno": servicerefnumber,
#     #                     "amountreceived": service_amount,
#     #                     "customer": service_customer,
#     #                     "duebalance": due,
#     #                 }

#     #                 service_ledger.post_service(**params)


#     service_ledger = ledgercli.LedgerBook(request.user.userprofile.branch)

#     if tax != None:
#         servicetax = tax
#     else:
#         servicetax = 0

#     if received != None:
#         service_amount = received - prev_recieved
#     else:
#         service_amount = 0
#     service_amount = round(service_amount, 2)

#     if firstname and lastname:
#         service_customer = f"{firstname}_{lastname}"
#     else:
#         service_customer = f"{firstname}"
    

#     spareparts = SpareParts.objects.filter(servicerefnumber=servicerefnumber)
#     totalsparetax = 0
#     for item in spareparts:
#         sparegst = item.salegst
#         totalsparetax = totalsparetax + (item.price * item.totalquantity * float(sparegst) / 100)

#     totalservicetax = float(totalsparetax) + float(servicetax)

#     params = {
#         "invoicedate": date.today(),
#         "mode": paymentmode,
#         "taxamount": round(totalservicetax, 2),
#         "invoiceno": servicerefnumber,
#         "amountreceived": received,
#         "amountprevious_received": prev_recieved,
#         "customer": service_customer,
#         "duebalance": due,
#     }

#     service_ledger.post_service(**params)
#     ##################################################################################



#     return redirect(
#         reverse("serviceupdateform", kwargs={"servicerefnumber": servicerefnumber})
#     )




@login_required
def addSpareRequest(request):

    currentuser = request.user

    length_count = list(filter(check_status, request.POST.keys()))

    serviceref = request.POST["servicereff"]

    service_history = ServiceHistory()
    service_history.service = Service.objects.filter(
        servicerefnumber=serviceref
    ).first()
    service_history.description = f"Spare requested by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')} , Requested Spare :"
    service_history.save()

    notification_message = f"Spare requested by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')} , Requested Spare :  "
    empty = True
    for item in range(1, len(length_count) + 1):
        item = str(item)

        if (
            request.POST["reqspare" + item] == ""
            or request.POST["reqspare" + item] == None
            or request.POST["reqqty" + item] == ""
            or request.POST["reqqty" + item] == None
        ):
            continue
        else:
            empty = False

        spare = Products.objects.filter(
            Q(name=request.POST["reqspare" + item])
            & Q(branch=request.user.userprofile.branch)
        ).first()
        reqqty = int(request.POST["reqqty" + item])
        service = Service.objects.filter(servicerefnumber=serviceref).first()
        memodate = request.POST["servicedate"]

        notification_message += request.POST["reqspare" + item]

        if memodate != None and memodate != "":
            # memodate =datetime.strptime(memodate,"%d-%m-%Y").strftime("%Y-%m-%d")
            try:
                memodate = datetime.strptime(memodate, "%b. %d, %Y").strftime(
                    "%Y-%m-%d"
                )
            except:
                memodate = datetime.strptime(memodate, "%Y-%m-%d").strftime("%Y-%m-%d")
        else:
            memodate = None
        estimateddate = request.POST["estimateddate"]
        if estimateddate != None and estimateddate != "":
            try:
                estimateddate = datetime.strptime(estimateddate, "%b. %d, %Y").strftime(
                    "%Y-%m-%d"
                )
            except:
                estimateddate = datetime.strptime(estimateddate, "%Y-%m-%d").strftime(
                    "%Y-%m-%d"
                )
        else:
            estimateddate = None

        sparerequest = SpareRequests()
        sparerequest.spare = spare
        sparerequest.service = service
        sparerequest.service_created_date = memodate
        sparerequest.service_estimated_date = estimateddate
        sparerequest.requested_by = currentuser
        sparerequest.requested_qty = reqqty
        sparerequest.status = "Not Allocated"
        sparerequest.price = spare.sellingprice
        sparerequest.mop = spare.mop
        sparerequest.mrp = spare.mrp
        sparerequest.salegst = spare.salegst
        sparerequest.branch = request.user.userprofile.branch
        sparerequest.save()

        service_history = ServiceHistory()
        service_history.service = service
        service_history.description = f"{spare.name} - {reqqty}"
        service_history.save()

    if empty == False:
        service_history.save()

        service = Service.objects.filter(servicerefnumber=serviceref).first()
        service.status = "Spare Requested"
        service.modifieddate = date.today()
        service.save()

        try:
            notification = BroadcastNotification()
            notification.message = notification_message
            notification.broadcast_on = timezone.now() + timedelta(seconds=5)
            notification.notification_type = "spare_request"
            notification.notification_id = serviceref
            branch = request.user.userprofile.branch
            notification.user = (
                UserProfile.objects.filter(
                    Q(branch=branch)
                    & (Q(role="Branch Admin") | Q(role="Franchise Admin"))
                )
                .first()
                .user
            )
            notification.save()
        except:
            pass

        '''try:
            email = (
                UserProfile.objects.filter(
                    Q(branch=branch)
                    & (Q(role="Branch Admin") | Q(role="Franchise Admin"))
                )
                .first()
                .user.email
            )
            sendEmail(email, "Spare Request", notification_message)
        except:
            pass'''

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
    )


@login_required
def addSpareRequestStandard(request):

    currentuser = request.user

    length_count = list(filter(check_status, request.POST.keys()))

    serviceref = request.POST["servicereff"]

    serv = Service.objects.filter(servicerefnumber=serviceref).first()
    service_history = ServiceHistory()
    service_history.service = serv
    service_history.description = f"Spare Allocated by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')} , Requested Spare :"
    service_history.save()

    grandtotal = serv.totalamount
    totaltax = serv.totaltax

    #### 25-11-2024 ###########
    spare_total = 0
    spare_tax = 0
    ##########################

    notification_message = f"Spare Allocated by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')} , Requested Spare :  "
    empty = True
    for item in range(1, len(length_count) + 1):
        item = str(item)

        spare = Products.objects.filter(
            Q(name=request.POST["reqspare" + item])
            & Q(branch=request.user.userprofile.branch)
        ).first()
        available_qty = (
            BranchStock.objects.filter(
                Q(name=spare) & Q(branch=request.user.userprofile.branch)
            )
            .first()
            .quantity
        )

        if (
            request.POST["reqspare" + item] == ""
            or request.POST["reqspare" + item] == None
            or request.POST["reqqty" + item] == ""
            or request.POST["reqqty" + item] == None
        ):
            continue
        reqqty = int(request.POST["reqqty" + item])
        if reqqty > available_qty:
            messages.error(request, f"{spare} is out of stock")
            continue
        else:
            empty = False

        service = Service.objects.filter(servicerefnumber=serviceref).first()
        memodate = request.POST["servicedate"]
        status = request.POST["status" + item]
        if status != "Available":
            continue
        notification_message += request.POST["reqspare" + item]

        if memodate != None and memodate != "":
            # memodate =datetime.strptime(memodate,"%d-%m-%Y").strftime("%Y-%m-%d")
            try:
                memodate = datetime.strptime(memodate, "%b. %d, %Y").strftime(
                    "%Y-%m-%d"
                )
            except:
                memodate = datetime.strptime(memodate, "%Y-%m-%d").strftime("%Y-%m-%d")
        else:
            memodate = None
        estimateddate = request.POST["estimateddate"]
        if estimateddate != None and estimateddate != "":
            try:
                estimateddate = datetime.strptime(estimateddate, "%b. %d, %Y").strftime(
                    "%Y-%m-%d"
                )
            except:
                estimateddate = datetime.strptime(estimateddate, "%Y-%m-%d").strftime(
                    "%Y-%m-%d"
                )
        else:
            estimateddate = None

        sparerequest = SpareRequests()
        sparerequest.spare = spare
        sparerequest.service = service
        sparerequest.service_created_date = memodate
        sparerequest.service_estimated_date = estimateddate
        sparerequest.requested_by = currentuser
        sparerequest.requested_qty = reqqty
        sparerequest.status = "Allocated"
        sparerequest.price = spare.sellingprice
        sparerequest.mop = spare.mop
        sparerequest.mrp = spare.mrp
        sparerequest.salegst = spare.salegst
        sparerequest.branch = request.user.userprofile.branch
        sparerequest.purchase_price = spare.price
        sparerequest.purchase_tax = spare.purchasegst.percentage
        sparerequest.save()

        ####################### adding spare selling cost to total amount and its tax in total tax ######
        cost = (
            ((float(spare.salegst.percentage) / 100) * spare.sellingprice)
            + spare.sellingprice
        ) * float(reqqty)
        tx = ((float(spare.salegst.percentage) / 100) * spare.sellingprice) * float(
            reqqty
        )
        grandtotal += float(cost)
        totaltax += float(tx)

        #### 25-11-2024 ###########
        cost_wo_tx = (spare.sellingprice * float(reqqty))
        spare_total +=  float(cost_wo_tx)
        spare_tax += float(tx)
        ##########################
        #################################################################################################

        stock_obj = BranchStock.objects.filter(
            Q(branch=request.user.userprofile.branch)
            & Q(
                name=Products.objects.filter(
                    Q(name=spare) & Q(branch=request.user.userprofile.branch)
                ).first()
            )
        ).first()

        if stock_obj:
            qty = stock_obj.quantity
            stock_obj.quantity = int(qty) - int(reqqty)
            stock_obj.save()

        strans_obj = StockTransaction.objects.filter(
            Q(
                product=Products.objects.filter(
                    Q(name=spare) & Q(branch=request.user.userprofile.branch)
                ).first()
            )
            & Q(branch=request.user.userprofile.branch)
        ).first()
        if strans_obj:
            stocktr = StockTransaction()
            stocktr.product = Products.objects.filter(
                Q(name=spare) & Q(branch=request.user.userprofile.branch)
            ).first()
            stocktr.initial_quantity = strans_obj.initial_quantity
            stocktr.quantity = int(reqqty)
            stocktr.transactiontype = "Sub"
            stocktr.branch = request.user.userprofile.branch
            try:
                stocktr.reference_number  = request.POST["servicereff"]
                stocktr.transaction_category  = 'Spare Allocated'
            except:
                stocktr.reference_number  = 'NA'
                stocktr.transaction_category  = 'Spare Allocated'
            stocktr.save()
        else:
            stocktr = StockTransaction()
            stocktr.product = Products.objects.filter(
                Q(name=spare) & Q(branch=request.user.userprofile.branch)
            ).first()
            stocktr.initial_quantity = 0
            stocktr.quantity = int(reqqty)
            stocktr.transactiontype = "Sub"
            stocktr.branch = request.user.userprofile.branch
            try:
                stocktr.reference_number  = request.POST["servicereff"]
                stocktr.transaction_category  = 'Spare Allocated'
            except:
                stocktr.reference_number  = 'NA'
                stocktr.transaction_category  = 'Spare Allocated'
            stocktr.save()

        #######################
        service_history = ServiceHistory()
        service_history.service = service
        service_history.description = f"{spare.name} - {reqqty}"
        service_history.save()

        spare_part = SpareParts()
        spare_part.name = spare
        spare_part.servicerefnumber = serviceref
        spare_part.totalquantity = reqqty
        spare_part.price = spare.sellingprice
        spare_part.salegst = spare.salegst.percentage
        spare_part.mrp = spare.mrp
        spare_part.mop = spare.mop
        spare_part.branch = request.user.userprofile.branch
        spare_part.purchase_price = spare.price
        spare_part.purchase_tax = spare.purchasegst.percentage
        spare_part.save()

    if empty == False:
        service = Service.objects.filter(servicerefnumber=serviceref).first()
        service.status = "Spare Allocated"
        service.modifieddate = date.today()

        discount = service.discount
        recieved = service.amountrecieved
        servicecharge = service.servicecharge

        ######### 28/2/24 ############
        servicetax = ServiceTax.objects.all().first()

        if servicetax:
            servicetax = servicetax.tax
        else:
            servicetax = 0


        ####### 12-9-2024 sevicecharge with tax ############
        # totaltax = (float(servicetax) / 100) * float(servicecharge)
        totaltax = float(servicecharge) - (float(servicecharge) / (1 + (float(servicetax) / 100)))
        # grandtotal_final = float(grandtotal) + totaltax
        grandtotal_final = float(grandtotal)
        ####### 12-9-2024 sevicecharge with tax ############
 
        service.totalamount = float(grandtotal)
        service.totaltax = float(totaltax)
        service.finalamount = float(grandtotal_final) - float(discount)
        service.duebalance = (float(grandtotal_final) - float(discount)) - float(
            recieved
        )
        service.servicecharge = float(servicecharge)
        service.save()

        try:
            notification = BroadcastNotification()
            notification.message = notification_message
            notification.broadcast_on = timezone.now() + timedelta(seconds=5)
            notification.notification_type = "spare_allocated"
            notification.notification_id = serviceref
            branch = request.user.userprofile.branch
            notification.user = (
                UserProfile.objects.filter(
                    Q(branch=branch)
                    & (Q(role="Branch Admin") | Q(role="Franchise Admin"))
                )
                .first()
                .user
            )
            notification.save()
        except:
            pass



        ################ 25-11-2024 #######################

        serv_discount = ServiceDiscountDetails.objects.filter(servicerefnumber=serviceref).first()
        ttl = serv_discount.sparetotal_excltax_afterdiscount
        txx = serv_discount.sparetaxtotal_afterdiscount
       
        serv_discount.sparetotal_excltax_afterdiscount  = round(ttl + spare_total,2)
        serv_discount.sparetaxtotal_afterdiscount = round(txx + spare_tax,2)
        serv_discount.sparetotal_excltax_beforediscount  =  round(ttl + spare_total,2)
        serv_discount.sparetaxtotal_beforediscount = round(txx + spare_tax,2)
        serv_discount.save()

        ###################################################

        '''try:
            email = (
                UserProfile.objects.filter(
                    Q(branch=branch)
                    & (Q(role="Branch Admin") | Q(role="Franchise Admin"))
                )
                .first()
                .user.email
            )
            sendEmail(email, "Spare Allocated", notification_message)
        except:
            pass'''

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
    )


@login_required
def cancelsparerequeststandard(request, id, serviceref):

    spare = SpareRequests.objects.filter(
        Q(id=int(id)) & Q(branch=request.user.userprofile.branch)
    ).first()

    spareobj = SpareParts.objects.filter(
        Q(servicerefnumber=serviceref) & Q(name=spare.spare)
    ).first()

    #######################  ######
    cost = (
        ((float(spare.spare.salegst.percentage) / 100) * spare.spare.sellingprice)
        + spare.spare.sellingprice
    ) * float(spare.requested_qty)
    tx = (
        (float(spare.spare.salegst.percentage) / 100) * spare.spare.sellingprice
    ) * float(spare.requested_qty)



    ################ 25-11-2024 #######################

    # print("spare total add spare",spare_total)
    # print("spare tax add spare",spare_tax)

    cost_wo_tx = (spare.spare.sellingprice) * float(spare.requested_qty)

    serv_discount = ServiceDiscountDetails.objects.filter(servicerefnumber=serviceref).first()
    spare_total = serv_discount.sparetotal_excltax_afterdiscount 
    spare_tax = serv_discount.sparetaxtotal_afterdiscount

    serv_discount.sparetotal_excltax_afterdiscount = round(spare_total - cost_wo_tx,2)
    serv_discount.sparetaxtotal_afterdiscount =  round(spare_tax - tx,2)
    serv_discount.sparetotal_excltax_beforediscount  = round(spare_total - cost_wo_tx,2)
    serv_discount.sparetaxtotal_beforediscount = round(spare_tax - tx,2)
    serv_discount.save()

    ###################################################


   

    stock_obj = BranchStock.objects.filter(
        Q(branch=request.user.userprofile.branch) & Q(name=spare.spare)
    ).first()
    if stock_obj:
        qty = stock_obj.quantity
        stock_obj.quantity = int(qty) + int(spare.requested_qty)
        stock_obj.save()

    strans_obj = StockTransaction.objects.filter(
        Q(product=spare.spare) & Q(branch=request.user.userprofile.branch)
    ).first()
    if strans_obj:
        stocktr = StockTransaction()
        stocktr.product = spare.spare
        stocktr.initial_quantity = strans_obj.initial_quantity
        stocktr.quantity = int(spare.requested_qty)
        stocktr.transactiontype = "Add"
        stocktr.branch = request.user.userprofile.branch
        try:
            stocktr.reference_number  = serviceref
            stocktr.transaction_category  = 'Spare Cancelled'
        except:
            stocktr.reference_number  = 'NA'
            stocktr.transaction_category  = 'Spare Cancelled'
        stocktr.save()
    #

    #######################
    service = Service.objects.filter(servicerefnumber=serviceref).first()
    service_history = ServiceHistory()
    service_history.service = service
    service_history.description = f"Cancelled spare allocation - {spare.spare.name} - {spare.requested_qty} quantity by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
    service_history.save()

    notification_message = f"Cancelled spare allocation - {spare.spare.name} - {spare.requested_qty} quantity by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
    try:
        notification = BroadcastNotification()
        notification.message = notification_message
        notification.broadcast_on = timezone.now() + timedelta(seconds=5)
        notification.notification_type = "spare_cancelled"
        notification.notification_id = serviceref
        branch = request.user.userprofile.branch
        notification.user = (
            UserProfile.objects.filter(
                Q(branch=request.user.userprofile.branch)
                & (Q(role="Branch Admin") | Q(role="Franchise Admin"))
            )
            .first()
            .user
        )
        notification.save()
    except:
        pass

    '''try:
        email = (
            UserProfile.objects.filter(
                Q(branch=request.user.userprofile.branch)
                & (Q(role="Branch Admin") | Q(role="Franchise Admin"))
            )
            .first()
            .user.email
        )
        sendEmail(email, "Spare Cancelled", notification_message)
    except:
        pass'''

    ############################################################################################
    service = Service.objects.filter(servicerefnumber=serviceref).first()
    totalamnt = service.totalamount
    totaltx = service.totaltax
    discount = service.discount
    finalamnt = service.finalamount
    amountrecieved = service.amountrecieved
    duebalance = service.duebalance

    # print("tot",totalamnt,"tot tax",totaltx,'final',finalamnt,'due',duebalance)

    new_total = totalamnt - cost
    new_total_tx = totaltx - tx
    new_final_amount = new_total - float(discount)
    new_due = new_final_amount - float(amountrecieved)

    # print("tot",new_total,"tot tax",new_total_tx,'final',new_final_amount,'due',new_due)

    service.totalamount = new_total
    # service.totaltax = new_total_tx
    service.finalamount = new_final_amount
    service.duebalance = new_due
    service.save()

    spareobj.delete()
    spare.delete()

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
    )


@login_required
def addServiceCharge(request):

    serviceref = request.POST["servicereff"]
    status = request.POST["status"]
    service = Service.objects.filter(servicerefnumber=serviceref).first()

    servicecharge = ServiceChargeRequests()
    servicecharge.service = service
    servicecharge.status = status
    servicecharge.charge = service.servicecharge
    servicecharge.requested_by = request.user
    servicecharge.branch = request.user.userprofile.branch
    servicecharge.save()

    service_history = ServiceHistory()
    service_history.service = service
    service_history.description = f"Service Charge Estimation Requested by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
    service_history.save()

    service = Service.objects.filter(servicerefnumber=serviceref).first()
    service.status = "Spare Requested"
    service.modifieddate = date.today()
    service.save()

    notification_message = f"Service Charge Estimation Requested by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
    try:
        notification = BroadcastNotification()
        notification.message = notification_message
        notification.broadcast_on = timezone.now() + timedelta(seconds=120)
        notification.notification_type = "service_charge_request"
        notification.notification_id = serviceref
        branch = request.user.userprofile.branch
        notification.user = (
            UserProfile.objects.filter(
                Q(branch=branch) & (Q(role="Branch Admin") | Q(role="Franchise Admin"))
            )
            .first()
            .user
        )
        notification.save()
    except:
        pass

    '''try:
        email = (
            UserProfile.objects.filter(
                Q(branch=branch) & (Q(role="Branch Admin") | Q(role="Franchise Admin"))
            )
            .first()
            .user.email
        )
        sendEmail(email, "Service Charge Request", notification_message)
    except:
        pass'''

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
    )


@login_required
def addServiceChargeStandard(request):

    serviceref = request.POST["servicereff"]
    status = request.POST["status"]
    service = Service.objects.filter(servicerefnumber=serviceref).first()
    service.status = "Spare Allocated"
    service.modifieddate = date.today()

    ######### 28/2/24 ############
    servicetax = ServiceTax.objects.all().first()
    discount = service.discount
    recieved = service.amountrecieved
    servicecharge = service.servicecharge
    if not servicecharge:
        servicecharge = 0

    if servicetax:
        servicetax = servicetax.tax
    else:
        servicetax = 0
    service.servicetax = float(servicetax)
    totalamount = service.totalamount
    
    ####### 12-9-2024 sevicecharge with tax ############
    # totaltax=(float(servicetax)/100)*float(totalamount)
    totaltax = float(servicecharge) - (float(servicecharge) / (1 + (float(servicetax) / 100)))
    # totalamount_final = float(totalamount) + totaltax
    totalamount_final = float(totalamount) 
    ####### 12-9-2024 sevicecharge with tax ############

    service.totaltax = round(float(totaltax),2)
    service.finalamount = round((float(totalamount_final) - float(discount)),2)
    service.duebalance = round(((float(totalamount_final) - float(discount)) - float(recieved)),2)
    #############################

    service.save()

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
    )


@login_required
def spareRequests(request):

    currentuser = request.user

    sparerequests = SpareRequests.objects.filter(
        branch=currentuser.userprofile.branch
    ).order_by("-pk")

    seen = OrderedDict()

    for item in sparerequests:
        if item.service not in seen:

            try:
                service_age = item.service_estimated_date - datetime.now(timezone.utc)
                service_age = service_age.days
            except:
                service_age = ""
            # if service_age.days <0:
            #     service_age = item.service_estimated_date
            seen[item.service] = {
                "servicerefnumber": item.service.servicerefnumber,
                "requested_qty": item.requested_qty,
                "spare": [item.spare.name],
                "created_date": item.created_date,
                "requested_by": item.requested_by,
                "service_age": service_age,
                "status": item.status,
            }

        else:
            if (
                seen[item.service]["status"] == "Allocated"
                and item.status == "Not Allocated"
            ):
                seen[item.service]["status"] = "Not allocated"
                seen[item.service]["spare"].append(item.spare.name)
            else:
                seen[item.service]["spare"].append(item.spare.name)

    datafinal = list(seen.values())

    context = {"sparerequests": datafinal}

    return render(request, "sparerequests.html", context)


@login_required
def serviceChargeEstimationList(request):

    currentuser = request.user
    servicecharges = ServiceChargeRequests.objects.filter(
        branch=currentuser.userprofile.branch
    ).order_by("-pk")
    data_final = []
    for item in servicecharges:
        data = {}
        data["servicerefnumber"] = item.service.servicerefnumber
        data["requested_by"] = item.requested_by
        service_age = item.service.createddate - datetime.now(timezone.utc).date()
        data["service_age"] = service_age.days
        data["issue"] = item.service.problem
        data["created_date"] = item.created_date
        data["status"] = item.status

        data_final.append(data)

    context = {
        "servicecharges": data_final,
    }
    return render(request, "servicechargeestimationlist.html", context)


@login_required
def serviceChargeEstimationDetails(request, serviceref):

    service = Service.objects.filter(servicerefnumber=serviceref).first()

    servicecharge = ServiceChargeRequests.objects.filter(service=service).first()

    context = {
        "servicechargedetails": servicecharge,
        "serviceref": serviceref,
        "grandtotal": service.finalamount,
        "service_charge": service.servicecharge,
        "brand": service.brand,
        "status": service.status,
        "expecteddate": service.expecteddate,
        "model": service.model,
        "imei": service.imei,
        "problem": service.problem,
        "finalamount": service.finalamount,
        "amountrecieved": service.amountrecieved,
    }

    return render(request, "servicechargeestimationdetails.html", context)


@login_required
def serviceChargeEstimationUpdate(request):

    serviceref = request.POST["serviceref"]
    servicecharge = request.POST["spareservicecharge"]
    grandtotal = request.POST["grandtotalfinal"]

    remark = request.POST["serviceremark"]

    service = Service.objects.filter(servicerefnumber=serviceref).first()

    servicecharge_obj = ServiceChargeRequests.objects.filter(service=service).first()
    servicecharge_obj.status = "Estimated"
    servicecharge_obj.charge = float(servicecharge)
    servicecharge_obj.save()

    service_history = ServiceHistory()
    service_history.service = service
    service_history.description = f"Service Charge Estimation Estimated by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
    service_history.save()

    notification_message = f"Service Charge Estimated by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
    try:
        notification = BroadcastNotification()
        notification.message = notification_message
        notification.broadcast_on = timezone.now() + timedelta(seconds=120)
        notification.notification_type = "service_charge_estimated"
        notification.notification_id = serviceref
        branch = request.user.userprofile.branch
        notification.user = service.technician
        notification.save()
    except:
        pass

    '''try:
        email = service.technician.email
        sendEmail(email, "Service Charge Estimated", notification_message)
    except:
        pass'''

    if remark != "":
        serviceinfo = ServiceInformations()
        serviceinfo.service = service
        serviceinfo.user = request.user
        serviceinfo.info = remark
        serviceinfo.save()

    discount = service.discount
    received = service.amountrecieved

    if grandtotal != None:
        ######### 28/2/24 ############
        servicetax = ServiceTax.objects.all().first()

        if servicetax:
            servicetax = servicetax.tax
        else:
            servicetax = 0
        # totaltax=(float(servicetax)/100)*float(grandtotal)
        totaltax = (float(servicetax) / 100) * float(servicecharge)
        grandtotal_final = float(grandtotal) + totaltax
        service.servicetax = float(servicetax)
        #############################
        service.totalamount = float(grandtotal)
        service.totaltax = float(totaltax)
        service.finalamount = float(grandtotal_final) - discount
        service.duebalance = (float(grandtotal_final) - discount) - received
        # service.servicecharge = float(grandtotal)
        service.servicecharge = float(servicecharge)
        service.status = "Spare Allocated"
        service.modifieddate = date.today()
    service.save()

    # return redirect(reverse("servicechargeestimationdetails",kwargs={"serviceref":serviceref}))
    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
    )


def check_length(string):
    pattern = re.compile(r"^sellingprice")
    return bool(pattern.match(string))


@login_required
def spareRequestUpdate(request, serviceref):

    currentuser = request.user
    branch = currentuser.userprofile.branch

    length_count = list(filter(check_length, request.POST.keys()))

    for num in range(1, len(length_count) + 1):
        num = str(num)
        status = False

        try:
            if request.POST["allocate" + num]:
                status = True
        except:
            pass

        service_history = ServiceHistory()
        service_history.service = Service.objects.filter(
            servicerefnumber=serviceref
        ).first()
        service_history.description = f"Spare allocated by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')} , Allocated Spare : "
        service_history.save()

        notification_message = f"Spare allocated by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')} , Allocated Spare : "

        if status:
            req_id = request.POST["reqid" + num]
            spare_req_obj = SpareRequests.objects.filter(id=int(req_id)).first()
            spare_req_obj.status = "Allocated"
            spare_req_obj.barcodenumber = request.POST["sparebarcode" + num]
            spare_req_obj.mop = request.POST["sparemop" + num]
            spare_req_obj.mrp = request.POST["sparemrp" + num]
            spare_req_obj.price = request.POST["sellingprice" + num]
            spare_req_obj.save()

            req_qty = request.POST["reqqty" + num]
            spare = request.POST["spare" + num]

            service_history = ServiceHistory()
            service_history.service = Service.objects.filter(
                servicerefnumber=serviceref
            ).first()
            service_history.description = f"{spare} - {req_qty}"
            service_history.save()

            notification_message += f"{spare} - {req_qty},"

            stock_obj = BranchStock.objects.filter(
                Q(branch=branch)
                & Q(
                    name=Products.objects.filter(
                        Q(name=spare) & Q(branch=request.user.userprofile.branch)
                    ).first()
                )
            ).first()

            if stock_obj:
                qty = stock_obj.quantity
                stock_obj.quantity = int(qty) - int(req_qty)
                stock_obj.save()

            strans_obj = StockTransaction.objects.filter(
                Q(
                    product=Products.objects.filter(
                        Q(name=spare) & Q(branch=request.user.userprofile.branch)
                    ).first()
                )
                & Q(branch=request.user.userprofile.branch)
            ).first()
            if strans_obj:
                stocktr = StockTransaction()
                stocktr.product = Products.objects.filter(
                    Q(name=spare) & Q(branch=request.user.userprofile.branch)
                ).first()
                stocktr.initial_quantity = strans_obj.initial_quantity
                stocktr.quantity = int(req_qty)
                stocktr.transactiontype = "Sub"
                stocktr.branch = request.user.userprofile.branch
                try:
                    stocktr.reference_number  = serviceref
                    stocktr.transaction_category  = 'Spare Allocated'
                except:
                    stocktr.reference_number  = 'NA'
                    stocktr.transaction_category  = 'Spare Allocated'
                stocktr.save()
            else:
                stocktr = StockTransaction()
                stocktr.product = Products.objects.filter(
                    Q(name=spare) & Q(branch=request.user.userprofile.branch)
                ).first()
                stocktr.initial_quantity = 0
                stocktr.quantity = int(req_qty)
                stocktr.transactiontype = "Sub"
                stocktr.branch = request.user.userprofile.branch
                try:
                    stocktr.reference_number  = serviceref
                    stocktr.transaction_category  = 'Spare Allocated'
                except:
                    stocktr.reference_number  = 'NA'
                    stocktr.transaction_category  = 'Spare Allocated'
                stocktr.save()

    for j in range(1, len(length_count) + 1):

        status = False

        try:
            if request.POST["allocate" + str(j)]:
                status = True
        except:
            pass

        if status:
            saleproduct = request.POST.get("spare" + str(j))
            if not saleproduct:
                continue
            salebarcode = request.POST["sparebarcode" + str(j)]
            saleprice = request.POST["sellingprice" + str(j)]
            salegst = request.POST["sparesalegst" + str(j)]
            # paymentmode = request.POST.get("paymentmode")
            quantity = request.POST["reqqty" + str(j)]

            if request.POST["sparemrp" + str(j)]:
                mrp = float(request.POST["sparemrp" + str(j)])
            else:
                mrp = None
            if request.POST["sparemop" + str(j)]:
                mop = float(request.POST["sparemop" + str(j)])
            else:
                mop = None

            spare = SpareParts()
            spare.name = Products.objects.filter(
                Q(name=saleproduct) & Q(branch=request.user.userprofile.branch)
            ).first()
            spare.servicerefnumber = serviceref
            # spare.customerid = customerid
            spare.barcodenumber = salebarcode
            spare.totalquantity = quantity
            spare.price = saleprice
            spare.salegst = salegst
            spare.mrp = mrp
            spare.mop = mop
            # spare.paymentmode =paymentmode
            spare.branch = request.user.userprofile.branch
            spare.save()

    grandtotal = request.POST["grandtotalfinal"]
    servicecharge = request.POST["spareservicecharge"]
    # totaltax = request.POST['sparetotaltax']
    service = Service.objects.filter(servicerefnumber=serviceref).first()
    discount = service.discount
    recieved = service.amountrecieved

    ######### 28/2/24 ############
    servicetax = ServiceTax.objects.all().first()
    if servicetax:
        servicetax = servicetax.tax
    else:
        servicetax = 0
    # totaltax=(float(servicetax)/100)*float(grandtotal)
    totaltax = (float(servicetax) / 100) * float(servicecharge)
    grandtotal_final = float(grandtotal) + totaltax
    service.servicetax = float(servicetax)
    #############################

    service.totalamount = float(grandtotal)
    service.totaltax = float(totaltax)
    service.finalamount = float(grandtotal_final) - float(discount)
    service.duebalance = (float(grandtotal_final) - float(discount)) - float(recieved)
    # if servicecharge != None and servicecharge != '':
    service.servicecharge = float(servicecharge)
    service.save()

    remark = request.POST["serviceremark"]
    if remark != "":
        serviceinfo = ServiceInformations()
        serviceinfo.service = service
        serviceinfo.user = currentuser
        serviceinfo.info = remark
        serviceinfo.save()

    service = Service.objects.filter(servicerefnumber=serviceref).first()
    spares = SpareRequests.objects.filter(
        service=Service.objects.filter(servicerefnumber=serviceref).first()
    )
    status = "Allocated"
    for item in spares:

        if item.status == "Not Allocated":
            status = "Not Allocated"
            break
    if status == "Allocated":
        service.status = "Spare Allocated"
        service.modifieddate = date.today()
        service.save()
    else:
        service.status = "Spare Requested"
        service.modifieddate = date.today()
        service.save()

    try:
        notification = BroadcastNotification()
        notification.message = notification_message
        notification.broadcast_on = timezone.now() + timedelta(seconds=5)
        notification.notification_type = "spare_allocated"
        notification.notification_id = serviceref
        branch = request.user.userprofile.branch
        notification.user = service.technician
        notification.save()
    except:
        pass

    '''try:
        email = service.technician.email
        sendEmail(email, "Spare Allocated", notification_message)
    except:
        pass'''

    # return redirect(reverse("sparerequestdetails",kwargs={"serviceref":serviceref}))
    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
    )


@login_required
def spareRequestDetails(request, serviceref):

    currentuser = request.user

    sparerequest = SpareRequests.objects.filter(
        service=Service.objects.filter(servicerefnumber=serviceref).first()
    )

    service = Service.objects.filter(servicerefnumber=serviceref).first()
    grandtotal = service.totalamount
    service_charge = service.servicecharge

    datafinal = []

    for item in sparerequest:

        data = {}
        data["created_date"] = item.created_date
        data["spare"] = item.spare.name
        data["requested_qty"] = item.requested_qty
        try:
            qty = (
                BranchStock.objects.filter(
                    Q(branch=currentuser.userprofile.branch) & Q(name=item.spare)
                )
                .first()
                .quantity
            )
        except:
            qty = 0
        data["available_qty"] = qty
        # data['available_qty'] = BranchStock.objects.filter(Q(branch=currentuser.userprofile.branch)&Q(name=item.spare)).first().quantity
        if data["requested_qty"] > data["available_qty"]:
            data["avail_status"] = "Not Available"
        elif data["available_qty"] == 0:
            data["avail_status"] = "Not Available"
        else:
            data["avail_status"] = "Available"
        data["status"] = item.status
        data["id"] = item.id
        data["mop"] = item.mop
        data["mrp"] = item.mrp
        data["selling_price"] = item.price
        data["sale_gst"] = item.salegst
        data["sparebarcode"] = item.barcodenumber
        datafinal.append(data)

    context = {
        "sparerequest": datafinal,
        "serviceref": serviceref,
        "grandtotal": grandtotal,
        "service_charge": service_charge,
    }
    return render(request, "sparerequestdetails.html", context)


@login_required
def get_all_service(request):

    data = Service.objects.filter(branch=request.user.userprofile.branch).order_by(
        "-pk"
    )
    servicerefno_set = set()
    datafinal = [
        service
        for service in data
        if (
            service.servicerefnumber not in servicerefno_set
            and not servicerefno_set.add(service.servicerefnumber)
        )
    ]

    today = date.today()

    service_final = []
    for i in datafinal:

        service_dict = {
            "servicerefnumber": i.servicerefnumber,
            "customerid": i.customerid,
            "firstname": i.firstname,
            "lastname": i.lastname,
            "address": i.address,
            "phone": i.phone,
            "memodate": i.memodate,
            "expecteddate": i.expecteddate,
            "product": i.product,
            "brand": i.brand,
            "model": i.model,
            "imei": i.imei,
            "servicecharge": i.servicecharge,
            "problem": i.problem,
            "remarks": i.remarks,
            "status": i.status,
            "warrenty": i.warrenty,
            "totalamount": i.totalamount,
            "discount": i.discount,
            "finalamount": i.finalamount,
            "amountrecieved": i.amountrecieved,
            "duebalance": i.duebalance,
            "branch": i.branch,
            "createddate": i.createddate,
            "paymentmode": i.paymentmode,
            "technician": i.technician,
            "rack_no": i.rack_no,
        }
        if i.expecteddate != None and i.expecteddate != "":
            diff = i.expecteddate - today
            service_dict["datedifference"] = f"{diff.days} days left"
            if diff.days < 0:
                service_dict["datedifferencecolor"] = "red"
            elif diff.days == 0:
                service_dict["datedifferencecolor"] = "orange"
                service_dict["datedifference"] = "Today"
            elif diff.days >= 1:
                service_dict["datedifferencecolor"] = "green"
        else:
            service_dict["datedifference"] = ""
            service_dict["datedifferencecolor"] = ""

        service_final.append(service_dict)
    context = {
        "data": service_final,
        "orders": 0,
    }
    return render(request, "allservice.html", context)


@user_passes_test(
    partial(check_permission, page="Servicelist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def service(request):
   
    currentuser = request.user
    orders = 0
    status_filter = None

    # Check if request method is POST and status is in POST data
    if request.method == "POST":
        status_filter = request.POST.get("status")
        startdate = request.POST.get('startdate')
        enddate = request.POST.get('enddate')
        serviceinout = request.POST.get("isServiceIn")

        

    if currentuser.is_superuser:
        data = Service.objects.all().order_by("-pk")
    elif currentuser.userprofile.role == "Technician":
        if currentuser.userprofile.branch.branchcategory == "Advanced":
            data = Service.objects.filter(
                Q(technician=currentuser)
                & (
                    Q(status="Unacknowledged")
                    | Q(status="In Progress")
                    | Q(status="Spare Requested")
                    | Q(status="Spare Allocated")
                    | Q(status="QC Failed")
                )
            ).order_by("-pk")
            orders = len(
                Service.objects.filter(
                    Q(technician=currentuser) & Q(status="Unacknoledged")
                )
            )
        else:
            data = Service.objects.filter(
                Q(technician=currentuser)
                & (
                    Q(status="Unacknowledged")
                    | Q(status="In Progress")
                    | Q(status="Spare Requested")
                    | Q(status="Spare Allocated")
                    | Q(status="CNP Inprogress(NotOk)")
                    | Q(status="CNP Inprogress(Ok)")
                    | Q(status="QC Passed(Ok)")
                    | Q(status="QC Passed(NotOk)")
                    | Q(status="Beyond Repair")
                    | Q(status="QC Failed")
                    | Q(status="Quality Checking(Ok)")
                    | Q(status="Quality Checking(NotOk)")
                    | Q(status="Rejected")
                )
            ).order_by("-pk")
            orders = len(
                Service.objects.filter(
                    Q(technician=currentuser) & Q(status="Unacknoledged")
                )
            )

    elif (
        currentuser.userprofile.role == "Branch Admin"
        or currentuser.userprofile.role == "Franchise Admin"
        or currentuser.userprofile.role == "TRC Front Desk"
    ):

        data = Service.objects.filter(branch=currentuser.userprofile.branch).order_by(
            "-pk"
        )
    elif currentuser.userprofile.role == "TRC QC":
        data = Service.objects.filter(
            Q(branch=currentuser.userprofile.branch) & Q(status="Completed")
            | Q(status="Beyond Repair")
        ).order_by("-pk")
    elif currentuser.userprofile.role == "TRC Cleaning and Packing":
        data = Service.objects.filter(
            Q(branch=currentuser.userprofile.branch) & Q(status="QC Passed(Ok)")
            | Q(status="QC Passed(NotOk)")
        ).order_by("-pk")
    elif currentuser.userprofile.role == "Field Engineer":
        data = Service.objects.filter(booking__assigned_to=currentuser).order_by("-pk")



    search_query ={
        "type":"GET",
        "serviceinout":'',
        "status":'',
        "startdate":'',
        "enddate":''    }
    # Apply additional status filter if provided
    if request.method == 'POST':
        search_query['type']='POST'
        if status_filter and startdate and enddate and serviceinout:
            search_query['serviceinout']="in"
            search_query['startdate']=startdate
            search_query['enddate']=enddate
            search_query['status']=status_filter

            startdate = datetime.strptime(startdate, "%d-%m-%Y").date()
            enddate = datetime.strptime(enddate, "%d-%m-%Y").date()
            data = data.filter(Q(status=status_filter)&Q(memodate__gte=startdate)&Q(memodate__lte=enddate))
        elif startdate and enddate and not status_filter and not serviceinout:
            search_query['serviceinout']="out"
            search_query['startdate']=startdate
            search_query['enddate']=enddate
            

            startdate = datetime.strptime(startdate, "%d-%m-%Y").date()
            enddate = datetime.strptime(enddate, "%d-%m-%Y").date()
            data = data.filter(Q(status="Delivered(Ok)")&Q(modifieddate__gte=startdate)&Q(modifieddate__lte=enddate))
        elif startdate and enddate and not status_filter and serviceinout:
            search_query['serviceinout']="in"
            search_query['startdate']=startdate
            search_query['enddate']=enddate

            startdate = datetime.strptime(startdate, "%d-%m-%Y").date()
            enddate = datetime.strptime(enddate, "%d-%m-%Y").date()
            data = data.filter(Q(memodate__gte=startdate)&Q(memodate__lte=enddate))
        elif not startdate and not enddate and status_filter:
            search_query['serviceinout']="in"
            search_query['status']=status_filter
        
            data = data.filter(Q(status=status_filter))
   

    servicerefno_set = set()
    datafinal = [
        service
        for service in data
        if (
            service.servicerefnumber not in servicerefno_set
            and not servicerefno_set.add(service.servicerefnumber)
        )
    ]

    today = date.today()

    service_final = []
    for i in datafinal:

        service_dict = {
            "servicerefnumber": i.servicerefnumber,
            "customerid": i.customerid,
            "firstname": i.firstname,
            "lastname": i.lastname,
            "address": i.address,
            "phone": i.phone,
            "memodate": i.memodate,
            "expecteddate": i.expecteddate,
            "product": i.product,
            "brand": i.brand,
            "model": i.model,
            "imei": i.imei,
            "servicecharge": i.servicecharge,
            "problem": i.problem,
            "remarks": i.remarks,
            "status": i.status,
            "warrenty": i.warrenty,
            "totalamount": i.totalamount,
            "discount": i.discount,
            "finalamount": i.finalamount,
            "amountrecieved": i.amountrecieved,
            "duebalance": i.duebalance,
            "branch": i.branch,
            "createddate": i.createddate,
            "paymentmode": i.paymentmode,
            "technician": i.technician,
            "rack_no": i.rack_no,
            "booking": i.booking,
        }
        if i.expecteddate != None and i.expecteddate != "":
            diff = i.expecteddate - today
            service_dict["datedifference"] = f"{diff.days} days left"
            if diff.days < 0:
                service_dict["datedifferencecolor"] = "red"
            elif diff.days == 0:
                service_dict["datedifferencecolor"] = "orange"
                service_dict["datedifference"] = "Today"
            elif diff.days >= 1:
                service_dict["datedifferencecolor"] = "green"
        else:
            service_dict["datedifference"] = ""
            service_dict["datedifferencecolor"] = ""

        service_final.append(service_dict)


    status_list = [
        "Unassigned",
        "Unacknowledged",
        "CNP Completed(Ok)",
        "CNP Completed(NotOk)",
        "Delivered(Ok)",
        "Delivered(NotOk)",
        "Rejected",
        "Beyond Repair",
        "In Progress",
        "Spare Allocated",
        "Completed",
        "Quality Checking(Ok)",
        "Quality Checking(NotOk)",
        "QC Failed",
        "CNP Inprogress(Ok)",
        "CNP Inprogress(NotOk)",
        "CNP Pending(Ok)",
        "CNP Pending(NotOk)"
    ]

    context = {
        "data": service_final,
        "orders": orders,
        "status_list":status_list,
        "search_query":search_query
    }
    return render(request, "service.html", context)






@user_passes_test(
    partial(check_permission, page="Servicelist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def service_receivable(request):
   
    currentuser = request.user
    orders = 0
    status_filter = None

    # Check if request method is POST and status is in POST data
    if request.method == "POST":
        status_filter = request.POST.get("status")
        startdate = request.POST.get('startdate')
        enddate = request.POST.get('enddate')
        serviceinout = request.POST.get("isServiceIn")

        

    if currentuser.is_superuser:
        data = Service.objects.filter(Q(amountrecieved__lt=F("finalamount"))).order_by("-pk")
    elif currentuser.userprofile.role == "Technician":
        if currentuser.userprofile.branch.branchcategory == "Advanced":
            data = Service.objects.filter(
                Q(technician=currentuser)
                & Q(amountrecieved__lt=F("finalamount"))
                & (
                    Q(status="Unacknowledged")
                    | Q(status="In Progress")
                    | Q(status="Spare Requested")
                    | Q(status="Spare Allocated")
                    | Q(status="QC Failed")
                )
            ).order_by("-pk")
            orders = len(
                Service.objects.filter(
                    Q(technician=currentuser) & Q(status="Unacknoledged")& Q(amountrecieved__lt=F("finalamount"))
                )
            )
        else:
            data = Service.objects.filter(
                Q(technician=currentuser)
                & Q(amountrecieved__lt=F("finalamount"))
                & (
                    Q(status="Unacknowledged")
                    | Q(status="In Progress")
                    | Q(status="Spare Requested")
                    | Q(status="Spare Allocated")
                    | Q(status="CNP Inprogress(NotOk)")
                    | Q(status="CNP Inprogress(Ok)")
                    | Q(status="QC Passed(Ok)")
                    | Q(status="QC Passed(NotOk)")
                    | Q(status="Beyond Repair")
                    | Q(status="QC Failed")
                    | Q(status="Quality Checking(Ok)")
                    | Q(status="Quality Checking(NotOk)")
                    | Q(status="Rejected")
                )
            ).order_by("-pk")
            orders = len(
                Service.objects.filter(
                    Q(technician=currentuser) & Q(status="Unacknoledged") & Q(amountrecieved__lt=F("finalamount"))
                )
            )

    elif (
        currentuser.userprofile.role == "Branch Admin"
        or currentuser.userprofile.role == "Franchise Admin"
        or currentuser.userprofile.role == "TRC Front Desk"
    ):

        data = Service.objects.filter(Q(branch=currentuser.userprofile.branch) & Q(amountrecieved__lt=F("finalamount"))).order_by(
            "-pk"
        )
    elif currentuser.userprofile.role == "TRC QC":
        data = Service.objects.filter(
            Q(branch=currentuser.userprofile.branch) & Q(amountrecieved__lt=F("finalamount")) & Q(status="Completed")
            | Q(status="Beyond Repair")
        ).order_by("-pk")
    elif currentuser.userprofile.role == "TRC Cleaning and Packing":
        data = Service.objects.filter(
            Q(branch=currentuser.userprofile.branch) & Q(amountrecieved__lt=F("finalamount")) & Q(status="QC Passed(Ok)")
            | Q(status="QC Passed(NotOk)")
        ).order_by("-pk")
    elif currentuser.userprofile.role == "Field Engineer":
        data = Service.objects.filter(Q(booking__assigned_to=currentuser) & Q(amountrecieved__lt=F("finalamount"))).order_by("-pk")



    search_query ={
        "type":"GET",
        "serviceinout":'',
        "status":'',
        "startdate":'',
        "enddate":''    }
    # Apply additional status filter if provided
    if request.method == 'POST':
        search_query['type']='POST'
        if status_filter and startdate and enddate and serviceinout:
            search_query['serviceinout']="in"
            search_query['startdate']=startdate
            search_query['enddate']=enddate
            search_query['status']=status_filter

            startdate = datetime.strptime(startdate, "%d-%m-%Y").date()
            enddate = datetime.strptime(enddate, "%d-%m-%Y").date()
            data = data.filter(Q(status=status_filter)&Q(memodate__gte=startdate)&Q(memodate__lte=enddate))
        elif startdate and enddate and not status_filter and not serviceinout:
            search_query['serviceinout']="out"
            search_query['startdate']=startdate
            search_query['enddate']=enddate
            

            startdate = datetime.strptime(startdate, "%d-%m-%Y").date()
            enddate = datetime.strptime(enddate, "%d-%m-%Y").date()
            data = data.filter(Q(status="Delivered(Ok)")&Q(modifieddate__gte=startdate)&Q(modifieddate__lte=enddate))
        elif startdate and enddate and not status_filter and serviceinout:
            search_query['serviceinout']="in"
            search_query['startdate']=startdate
            search_query['enddate']=enddate

            startdate = datetime.strptime(startdate, "%d-%m-%Y").date()
            enddate = datetime.strptime(enddate, "%d-%m-%Y").date()
            data = data.filter(Q(memodate__gte=startdate)&Q(memodate__lte=enddate))
        elif not startdate and not enddate and status_filter:
            search_query['serviceinout']="in"
            search_query['status']=status_filter
        
            data = data.filter(Q(status=status_filter))
   

    servicerefno_set = set()
    datafinal = [
        service
        for service in data
        if (
            service.servicerefnumber not in servicerefno_set
            and not servicerefno_set.add(service.servicerefnumber)
        )
    ]

    today = date.today()

    service_final = []
    for i in datafinal:

        service_dict = {
            "servicerefnumber": i.servicerefnumber,
            "customerid": i.customerid,
            "firstname": i.firstname,
            "lastname": i.lastname,
            "address": i.address,
            "phone": i.phone,
            "memodate": i.memodate,
            "expecteddate": i.expecteddate,
            "product": i.product,
            "brand": i.brand,
            "model": i.model,
            "imei": i.imei,
            "servicecharge": i.servicecharge,
            "problem": i.problem,
            "remarks": i.remarks,
            "status": i.status,
            "warrenty": i.warrenty,
            "totalamount": i.totalamount,
            "discount": i.discount,
            "finalamount": i.finalamount,
            "amountrecieved": i.amountrecieved,
            "duebalance": i.duebalance,
            "branch": i.branch,
            "createddate": i.createddate,
            "paymentmode": i.paymentmode,
            "technician": i.technician,
            "rack_no": i.rack_no,
            "booking": i.booking,
        }
        if i.expecteddate != None and i.expecteddate != "":
            diff = i.expecteddate - today
            service_dict["datedifference"] = f"{diff.days} days left"
            if diff.days < 0:
                service_dict["datedifferencecolor"] = "red"
            elif diff.days == 0:
                service_dict["datedifferencecolor"] = "orange"
                service_dict["datedifference"] = "Today"
            elif diff.days >= 1:
                service_dict["datedifferencecolor"] = "green"
        else:
            service_dict["datedifference"] = ""
            service_dict["datedifferencecolor"] = ""

        service_final.append(service_dict)


    status_list = [
        "Unassigned",
        "Unacknowledged",
        "CNP Completed(Ok)",
        "CNP Completed(NotOk)",
        "Delivered(Ok)",
        "Delivered(NotOk)",
        "Rejected",
        "Beyond Repair",
        "In Progress",
        "Spare Allocated",
        "Completed",
        "Quality Checking(Ok)",
        "Quality Checking(NotOk)",
        "QC Failed",
        "CNP Inprogress(Ok)",
        "CNP Inprogress(NotOk)",
        "CNP Pending(Ok)",
        "CNP Pending(NotOk)"
    ]

    context = {
        "data": service_final,
        "orders": orders,
        "status_list":status_list,
        "search_query":search_query
    }
    return render(request, "service.html", context)



@login_required
def serviceBooking(request):

    current_user = request.user

    booking_obj = CustomerBookingRepair.objects.all().order_by("-pk")
    if current_user.userprofile.role == "Field Engineer":
        booking_obj = CustomerBookingRepair.objects.filter(
            assigned_to=current_user
        ).order_by("-pk")

    field_engg = User.objects.filter(
        Q(userprofile__branch=current_user.userprofile.branch)
        & Q(userprofile__role="Field Engineer")
    )

    context = {"bookings": booking_obj, "field_engineers": field_engg}

    return render(request, "servicebooking.html", context)


def getServiceBookingCount(request):

    current_user = request.user

    try:
        count = CustomerBookingRepair.objects.filter(status="NotVerified").count()
    except:
        count = ""

    return JsonResponse({"Response": count})


@login_required
def verifyRejectServiceBooking(request):

    bookingid = request.POST["id"]
    status = request.POST["status"]

    # try:
    if bookingid:
        bookingobj = CustomerBookingRepair.objects.filter(id=int(bookingid)).first()
        bookingobj.status = status
        bookingobj.save()
    # except:
    #     pass

    return redirect("servicebooking")


@login_required
def deliveredServiceBooking(request):

    bookingid = request.POST["id"]
    status = request.POST["status"]

    # try:
    if bookingid:
        bookingobj = CustomerBookingRepair.objects.filter(id=int(bookingid)).first()
        bookingobj.status = status
        bookingobj.save()
    # except:
    #     pass

    return redirect("servicebooking")


@login_required
def assignServiceBooking(request):

    bookingid = request.POST["id"]
    field = User.objects.filter(id=int(request.POST["fe"])).first()

    # try:
    if bookingid:
        bookingobj = CustomerBookingRepair.objects.filter(id=int(bookingid)).first()

        # try:
        if bookingobj.assigned_to:

            try:
                notification_message = f"Your Service Booking BK{bookingid} reassigned to {field} by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}."
                notification = BroadcastNotification()
                notification.message = notification_message
                notification.broadcast_on = timezone.now() + timedelta(seconds=5)
                notification.notification_type = "service_booking"
                notification.notification_id = bookingid
                notification.user = bookingobj.assigned_to
                notification.save()

                notification_message = f"Your Service Booking BK{bookingid} reassigned to {field} by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}."
                notification = BroadcastNotification()
                notification.message = notification_message
                notification.broadcast_on = timezone.now() + timedelta(seconds=5)
                notification.notification_type = "service_booking"
                notification.notification_id = bookingid
                notification.user = bookingobj.assigned_to
                notification.save()
            except:
                pass
        bookingobj.assigned_to = field
        bookingobj.branch = request.user.userprofile.branch
        bookingobj.save()

        try:
            # software notification
            notification_message = f"Service Booking BK{bookingid} assigned to you by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}."
            notification = BroadcastNotification()
            notification.message = notification_message
            notification.broadcast_on = timezone.now() + timedelta(seconds=5)
            notification.notification_type = "service_booking"
            notification.notification_id = bookingid
            notification.user = field
            notification.save()

            # mobile app notification
            notification_message = f"Service Booking BK{bookingid} assigned to you by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}."
            notification = BroadcastNotificationMobileApp()
            notification.message = notification_message
            notification.broadcast_on = timezone.now() + timedelta(seconds=5)
            notification.notification_type = "service_booking"
            notification.notification_id = bookingid
            notification.user = field
            notification.save()
        except:
            pass
        # except:
        #     pass
    # except:
    #     pass

    return redirect("servicebooking")


@login_required
def serviceDetailsSearch(request):
    received_data = QueryDict(request.body)
    barcode_number = received_data["serviceref"]
    if barcode_number:

        if Service.objects.filter(barcode_number=barcode_number).first():
            serviceref = (
                Service.objects.filter(barcode_number=barcode_number)
                .first()
                .servicerefnumber
            )
            return JsonResponse({"Response": serviceref})
        else:
            return JsonResponse({"Response": "Service Not Found!"})
    return JsonResponse({"Response": "Service Not Found!"})


def rotate_image(image_bytes, angle):
    with Image.open(BytesIO(image_bytes)) as img:
        rotated_img = img.rotate(angle, expand=True)
        byte_io = BytesIO()
        rotated_img.save(byte_io, format="PNG")
        return byte_io.getvalue()


def create_composite_image_service(
    barcode_image_bytes, company_name, date, mobile, customer, problem, sr_no
):
    # Load the barcode image
    barcode_image = Image.open(BytesIO(barcode_image_bytes))

    # Create a new image for the composite. The size might need adjustments.
    # This assumes the barcode image's width and a fixed height addition for text.
    composite_image = Image.new(
        "RGB", (barcode_image.width, barcode_image.height + 130), "white"
    )
    composite_image.paste(barcode_image, (0, 50))  # Offset by 100 pixels from the top

    # Prepare to draw text
    draw = ImageDraw.Draw(composite_image)

    font_path = os.path.join(
        BASE_DIR, "core", "static", "fonts", "Roboto", "Roboto-Regular.ttf"
    )
    font_size = 40
    font = ImageFont.truetype(font_path, font_size)
    font2 = ImageFont.truetype(font_path, 30)
    ###### 7/8/2024 ########
    try:
        date = date + " " + sr_no
    except:
        pass
    ########################
    # Draw text on the composite image
    draw.text((120, 10), company_name, fill="black", font=font)
    draw.text((60, 240), date, fill="black", font=font2)
    draw.text((60, 280), f"{mobile}: {customer}", fill="black", font=font2)
    draw.text((60, 320), problem, fill="black", font=font2)

    # Save or return the image
    byte_io = BytesIO()
    composite_image.save(byte_io, "PNG")
    return byte_io.getvalue()




def printBarcodeHelper(
    barcode_type,
    barcode_number,
    barcode_qty,
    company_name=None,
    date_now=None,
    customer=None,
    mobile=None,
    problem=None,
    bc_type=None,
    sr_no=None,
):

    # barcode_base64_list = []
    # template = get_template("barcode.html")
    barcode_format = barcode.get_barcode_class("code128")

    if bc_type == "Service":
        writer_options = {
            "module_width": 0.3,
            "module_height": 6.0,
             "font_size": 6,
            "text_distance": 2.5,
            "center_text": True,
        }
    elif bc_type == "Purchase":
        writer_options = {
            "module_width": 0.3,
            "module_height": 6.0,
            "font_size": 6,
            "text_distance": 2.5,
            "center_text": True,
        }
    for item in range(int(barcode_qty)):
        barcode_bytes_io = BytesIO()
        my_barcode = barcode_format(barcode_number, writer=ImageWriter()).write(
            barcode_bytes_io, options=writer_options
        )
        barcode_bytes_io.seek(0)
        barcode_image_bytes = barcode_bytes_io.getvalue()
        ################################################
        if bc_type == "Service":
            pdf = create_barcode_pdf(
                    barcodetype="service",
                    barcode_number=barcode_number,
                    company_name=company_name,
                   date=date_now,
                    mobile=mobile,
                    customer=customer,
                    problem=problem,
                    sr_no=sr_no,
                   barcode_image_bytes= barcode_image_bytes 
                    )
        else:

            try:
                purchaseobj = Purchase.objects.filter(
                    barcodenumber=barcode_number
                ).first()
                if not purchaseobj:
                    purchaseobj = BranchPurchase.objects.filter(
                        barcodenumber=barcode_number
                    ).first()
                mrp = purchaseobj.name.mrp
                s_price = purchaseobj.name.sellingprice
                s_gst = purchaseobj.name.salegst.percentage
                p_price = purchaseobj.name.price
                p_gst = purchaseobj.name.purchasegst.percentage
                sellingprice = s_price + (s_price * (float(s_gst) / 100))
                purchaseprice = p_price + (p_price * (float(p_gst) / 100))
                product_name = purchaseobj.name.name
            except:
                sellingprice = ""
                mrp = ""
                purchaseprice = ""
                product_name = ""


            pdf = create_barcode_pdf(
                    barcodetype="purchase",
                    barcode_number=barcode_number,
                    company_name=company_name,
                    product_name=product_name,
                    sellingprice=sellingprice,
                    mrp=mrp,
                    purchaseprice=purchaseprice,
                    barcode_image_bytes=barcode_image_bytes  
                    )


    response = HttpResponse(content_type="application/pdf")
    if bc_type == "Service":
        response["Content-Disposition"] = (
            f'inline; filename="Service_barcode_{date.today()}.pdf"'
        )
    else:
        response["Content-Disposition"] = (
            f'inline; filename="Purchase_barcode_{date.today()}.pdf"'
        )
    response.write(pdf)
    return response




@login_required
def printBarcode(request):

    

    user = request.user
    barcode_qty = request.POST["quantity"]
    barcode_number = request.POST["barcode"]
    barcode_type = request.POST["type"]
    if barcode_number and barcode_qty and barcode_type:

        if barcode_type == "Purchase":
            product_obj = None
            if user.is_superuser:
                product_obj = Purchase.objects.filter(
                    barcodenumber=barcode_number
                ).first()
            else:
                product_obj = BranchPurchase.objects.filter(
                    Q(barcodenumber=barcode_number)
                    & Q(branch=request.user.userprofile.branch)
                ).first()
            if product_obj:
                return printBarcodeHelper(
                    barcode_type,
                    barcode_number,
                    barcode_qty,
                    company_name="MAGNUS CARE",
                    bc_type="Purchase",
                )
            else:
                return redirect("index")
        elif barcode_type == "Service":
            if request.user.is_superuser:
                service = Service.objects.filter(barcode_number=barcode_number).first()
            else:
                service = Service.objects.filter(
                    Q(barcode_number=barcode_number)
                    & Q(branch=request.user.userprofile.branch)
                ).first()
            if service:
                date_now = datetime.now().strftime("%d/%m/%Y %I:%M %p")
                customer = f"{service.firstname} {service.lastname}"
                phone = service.phone
                problem = service.problem
                sr_no = service.servicerefnumber
                return printBarcodeHelper(
                    barcode_type,
                    barcode_number,
                    barcode_qty,
                    company_name="MAGNUS CARE",
                    date_now=date_now,
                    customer=customer,
                    mobile=phone,
                    problem=problem,
                    bc_type=barcode_type,
                    sr_no=sr_no,
                )
            else:
                return redirect("index")

        else:
            return redirect("index")
    return redirect("index")


@login_required
def printServiceBarcode(request, serviceref):

    if request.user.is_superuser:
        service = Service.objects.filter(servicerefnumber=serviceref).first()
    else:
        service = Service.objects.filter(
            Q(servicerefnumber=serviceref) & Q(branch=request.user.userprofile.branch)
        ).first()
    if service:
        date_now = datetime.now().strftime("%d/%m/%Y %I:%M %p")
        customer = f"{service.firstname} {service.lastname}"
        phone = service.phone
        problem = service.problem
        barcode_number = service.barcode_number
        barcode_type = "Service"
        barcode_qty = 1
        servicerefnumber = service.servicerefnumber

        return printBarcodeHelper(
            barcode_type,
            barcode_number,
            barcode_qty,
            company_name="MAGNUS CARE",
            date_now=date_now,
            customer=customer,
            mobile=phone,
            problem=problem,
            bc_type=barcode_type,
            sr_no=servicerefnumber,
        )
    else:
        return redirect(
            reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
        )

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
    )


@user_passes_test(
    partial(check_permission, page="Servicelist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def serviceAssigned(request):

    currentuser = request.user
    orders = 0
    if currentuser.is_superuser:
        data = Service.objects.filter(status="Assigned").order_by("-pk")
    elif currentuser.userprofile.role == "Technician":
        data = Service.objects.filter(
            Q(technician=currentuser) & Q(status="Assigned")
        ).order_by("-pk")

    elif (
        currentuser.userprofile.role == "Branch Admin"
        or currentuser.userprofile.role == "Franchise Admin"
    ):
        data = Service.objects.filter(
            Q(branch=currentuser.userprofile.branch) & Q(status="Assigned")
        ).order_by("-pk")

    servicerefno_set = set()
    datafinal = [
        service
        for service in data
        if (
            service.servicerefnumber not in servicerefno_set
            and not servicerefno_set.add(service.servicerefnumber)
        )
    ]

    today = date.today()

    service_final = []
    for i in datafinal:

        service_dict = {
            "servicerefnumber": i.servicerefnumber,
            "customerid": i.customerid,
            "firstname": i.firstname,
            "lastname": i.lastname,
            "address": i.address,
            "phone": i.phone,
            "memodate": i.memodate,
            "expecteddate": i.expecteddate,
            "product": i.product,
            "brand": i.brand,
            "model": i.model,
            "imei": i.imei,
            "servicecharge": i.servicecharge,
            "problem": i.problem,
            "remarks": i.remarks,
            "status": i.status,
            "warrenty": i.warrenty,
            "totalamount": i.totalamount,
            "discount": i.discount,
            "finalamount": i.finalamount,
            "amountrecieved": i.amountrecieved,
            "duebalance": i.duebalance,
            "branch": i.branch,
            "createddate": i.createddate,
            "paymentmode": i.paymentmode,
            "technician": i.technician,
        }
        if i.expecteddate != None and i.expecteddate != "":
            diff = i.expecteddate - today
            service_dict["datedifference"] = f"{diff.days} days left"
            if diff.days < 0:
                service_dict["datedifferencecolor"] = "red"
            elif diff.days == 0:
                service_dict["datedifferencecolor"] = "orange"
                service_dict["datedifference"] = "Today"
            elif diff.days >= 1:
                service_dict["datedifferencecolor"] = "green"
        else:
            service_dict["datedifference"] = ""
            service_dict["datedifferencecolor"] = ""

        service_final.append(service_dict)

    context = {
        "data": service_final,
    }
    return render(request, "serviceassigned.html", context)


@user_passes_test(
    partial(check_permission, page="Servicelist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def serviceRejected(request):

    currentuser = request.user
    orders = 0
    if currentuser.is_superuser:
        data = Service.objects.filter(status="Rejected").order_by("-pk")
    elif currentuser.userprofile.role == "Technician":
        data = Service.objects.filter(
            Q(technician=currentuser) & Q(status="Rejected")
        ).order_by("-pk")

    elif (
        currentuser.userprofile.role == "Branch Admin"
        or currentuser.userprofile.role == "Franchise Admin"
    ):
        data = Service.objects.filter(
            Q(branch=currentuser.userprofile.branch) & Q(status="Rejected")
        ).order_by("-pk")

    servicerefno_set = set()
    datafinal = [
        service
        for service in data
        if (
            service.servicerefnumber not in servicerefno_set
            and not servicerefno_set.add(service.servicerefnumber)
        )
    ]

    today = date.today()

    service_final = []
    for i in datafinal:

        service_dict = {
            "servicerefnumber": i.servicerefnumber,
            "customerid": i.customerid,
            "firstname": i.firstname,
            "lastname": i.lastname,
            "address": i.address,
            "phone": i.phone,
            "memodate": i.memodate,
            "expecteddate": i.expecteddate,
            "product": i.product,
            "brand": i.brand,
            "model": i.model,
            "imei": i.imei,
            "servicecharge": i.servicecharge,
            "problem": i.problem,
            "remarks": i.remarks,
            "status": i.status,
            "warrenty": i.warrenty,
            "totalamount": i.totalamount,
            "discount": i.discount,
            "finalamount": i.finalamount,
            "amountrecieved": i.amountrecieved,
            "duebalance": i.duebalance,
            "branch": i.branch,
            "createddate": i.createddate,
            "paymentmode": i.paymentmode,
            "technician": i.technician,
        }
        if i.expecteddate != None and i.expecteddate != "":
            diff = i.expecteddate - today
            service_dict["datedifference"] = f"{diff.days} days left"
            if diff.days < 0:
                service_dict["datedifferencecolor"] = "red"
            elif diff.days == 0:
                service_dict["datedifferencecolor"] = "orange"
                service_dict["datedifference"] = "Today"
            elif diff.days >= 1:
                service_dict["datedifferencecolor"] = "green"
        else:
            service_dict["datedifference"] = ""
            service_dict["datedifferencecolor"] = ""

        service_final.append(service_dict)

    context = {
        "data": service_final,
    }
    return render(request, "servicerejected.html", context)


@user_passes_test(
    partial(check_permission, page="Servicelist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def serviceInProgress(request):

    currentuser = request.user
    orders = 0
    if currentuser.is_superuser:
        data = Service.objects.filter(status="In Progress").order_by("-pk")
    elif currentuser.userprofile.role == "Technician":
        data = Service.objects.filter(
            Q(technician=currentuser) & Q(status="In Progress")
        ).order_by("-pk")

    elif (
        currentuser.userprofile.role == "Branch Admin"
        or currentuser.userprofile.role == "Franchise Admin"
    ):
        data = Service.objects.filter(
            Q(branch=currentuser.userprofile.branch) & Q(status="In Progress")
        ).order_by("-pk")

    servicerefno_set = set()
    datafinal = [
        service
        for service in data
        if (
            service.servicerefnumber not in servicerefno_set
            and not servicerefno_set.add(service.servicerefnumber)
        )
    ]

    today = date.today()

    service_final = []
    for i in datafinal:

        service_dict = {
            "servicerefnumber": i.servicerefnumber,
            "customerid": i.customerid,
            "firstname": i.firstname,
            "lastname": i.lastname,
            "address": i.address,
            "phone": i.phone,
            "memodate": i.memodate,
            "expecteddate": i.expecteddate,
            "product": i.product,
            "brand": i.brand,
            "model": i.model,
            "imei": i.imei,
            "servicecharge": i.servicecharge,
            "problem": i.problem,
            "remarks": i.remarks,
            "status": i.status,
            "warrenty": i.warrenty,
            "totalamount": i.totalamount,
            "discount": i.discount,
            "finalamount": i.finalamount,
            "amountrecieved": i.amountrecieved,
            "duebalance": i.duebalance,
            "branch": i.branch,
            "createddate": i.createddate,
            "paymentmode": i.paymentmode,
            "technician": i.technician,
            "rack_no": i.rack_no,
            "shedule_call": i.shedule_call,
        }
        if i.expecteddate != None and i.expecteddate != "":
            diff = i.expecteddate - today
            service_dict["datedifference"] = f"{diff.days} days left"
            if diff.days < 0:
                service_dict["datedifferencecolor"] = "red"
            elif diff.days == 0:
                service_dict["datedifferencecolor"] = "orange"
                service_dict["datedifference"] = "Today"
            elif diff.days >= 1:
                service_dict["datedifferencecolor"] = "green"
        else:
            service_dict["datedifference"] = ""
            service_dict["datedifferencecolor"] = ""

        service_final.append(service_dict)

    context = {
        "data": service_final,
    }
    return render(request, "serviceinprogress.html", context)


@user_passes_test(
    partial(check_permission, page="Servicelist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def servicePending(request):

    currentuser = request.user
    orders = 0
    if currentuser.is_superuser:
        data = Service.objects.filter(status="Pending").order_by("-pk")
    elif currentuser.userprofile.role == "Technician":
        data = Service.objects.filter(
            Q(technician=currentuser) & Q(status="Pending")
        ).order_by("-pk")

    elif (
        currentuser.userprofile.role == "Branch Admin"
        or currentuser.userprofile.role == "Franchise Admin"
    ):
        data = Service.objects.filter(
            Q(branch=currentuser.userprofile.branch) & Q(status="Pending")
        ).order_by("-pk")

    servicerefno_set = set()
    datafinal = [
        service
        for service in data
        if (
            service.servicerefnumber not in servicerefno_set
            and not servicerefno_set.add(service.servicerefnumber)
        )
    ]

    today = date.today()

    service_final = []
    for i in datafinal:

        service_dict = {
            "servicerefnumber": i.servicerefnumber,
            "customerid": i.customerid,
            "firstname": i.firstname,
            "lastname": i.lastname,
            "address": i.address,
            "phone": i.phone,
            "memodate": i.memodate,
            "expecteddate": i.expecteddate,
            "product": i.product,
            "brand": i.brand,
            "model": i.model,
            "imei": i.imei,
            "servicecharge": i.servicecharge,
            "problem": i.problem,
            "remarks": i.remarks,
            "status": i.status,
            "warrenty": i.warrenty,
            "totalamount": i.totalamount,
            "discount": i.discount,
            "finalamount": i.finalamount,
            "amountrecieved": i.amountrecieved,
            "duebalance": i.duebalance,
            "branch": i.branch,
            "createddate": i.createddate,
            "paymentmode": i.paymentmode,
            "technician": i.technician,
            "rack_no": i.rack_no,
            "shedule_call": i.shedule_call,
        }
        if i.expecteddate != None and i.expecteddate != "":
            diff = i.expecteddate - today
            service_dict["datedifference"] = f"{diff.days} days left"
            if diff.days < 0:
                service_dict["datedifferencecolor"] = "red"
            elif diff.days == 0:
                service_dict["datedifferencecolor"] = "orange"
                service_dict["datedifference"] = "Today"
            elif diff.days >= 1:
                service_dict["datedifferencecolor"] = "green"
        else:
            service_dict["datedifference"] = ""
            service_dict["datedifferencecolor"] = ""

        service_final.append(service_dict)

    context = {
        "data": service_final,
    }
    return render(request, "servicepending.html", context)


@user_passes_test(
    partial(check_permission, page="Servicelist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def serviceCompleted(request):

    currentuser = request.user
    orders = 0
    if currentuser.is_superuser:
        data = Service.objects.filter(status="Completed").order_by("-pk")
    elif currentuser.userprofile.role == "Technician":
        data = Service.objects.filter(
            Q(technician=currentuser) & Q(status="Completed")
        ).order_by("-pk")

    elif (
        currentuser.userprofile.role == "Branch Admin"
        or currentuser.userprofile.role == "Franchise Admin"
    ):
        data = Service.objects.filter(
            Q(branch=currentuser.userprofile.branch) & Q(status="Completed")
        ).order_by("-pk")

    servicerefno_set = set()
    datafinal = [
        service
        for service in data
        if (
            service.servicerefnumber not in servicerefno_set
            and not servicerefno_set.add(service.servicerefnumber)
        )
    ]

    today = date.today()

    service_final = []
    for i in datafinal:

        service_dict = {
            "servicerefnumber": i.servicerefnumber,
            "customerid": i.customerid,
            "firstname": i.firstname,
            "lastname": i.lastname,
            "address": i.address,
            "phone": i.phone,
            "memodate": i.memodate,
            "expecteddate": i.expecteddate,
            "product": i.product,
            "brand": i.brand,
            "model": i.model,
            "imei": i.imei,
            "servicecharge": i.servicecharge,
            "problem": i.problem,
            "remarks": i.remarks,
            "status": i.status,
            "warrenty": i.warrenty,
            "totalamount": i.totalamount,
            "discount": i.discount,
            "finalamount": i.finalamount,
            "amountrecieved": i.amountrecieved,
            "duebalance": i.duebalance,
            "branch": i.branch,
            "createddate": i.createddate,
            "paymentmode": i.paymentmode,
            "technician": i.technician,
            "rack_no": i.rack_no,
            "shedule_call": i.shedule_call,
        }
        if i.expecteddate != None and i.expecteddate != "":
            diff = i.expecteddate - today
            service_dict["datedifference"] = f"{diff.days} days left"
            if diff.days < 0:
                service_dict["datedifferencecolor"] = "red"
            elif diff.days == 0:
                service_dict["datedifferencecolor"] = "orange"
                service_dict["datedifference"] = "Today"
            elif diff.days >= 1:
                service_dict["datedifferencecolor"] = "green"
        else:
            service_dict["datedifference"] = ""
            service_dict["datedifferencecolor"] = ""

        service_final.append(service_dict)

    context = {
        "data": service_final,
    }
    return render(request, "servicecompleted.html", context)


@user_passes_test(
    partial(check_permission, page="Servicelist"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def serviceDelivered(request):

    currentuser = request.user
    orders = 0
    if currentuser.is_superuser:
        data = Service.objects.filter(status="Delivered").order_by("-pk")
    elif currentuser.userprofile.role == "Technician":
        data = Service.objects.filter(
            Q(technician=currentuser) & Q(status="Delivered")
        ).order_by("-pk")

    elif (
        currentuser.userprofile.role == "Branch Admin"
        or currentuser.userprofile.role == "Franchise Admin"
    ):
        data = Service.objects.filter(
            Q(branch=currentuser.userprofile.branch) & Q(status="Delivered")
        ).order_by("-pk")

    servicerefno_set = set()
    datafinal = [
        service
        for service in data
        if (
            service.servicerefnumber not in servicerefno_set
            and not servicerefno_set.add(service.servicerefnumber)
        )
    ]

    today = date.today()

    service_final = []
    for i in datafinal:

        service_dict = {
            "servicerefnumber": i.servicerefnumber,
            "customerid": i.customerid,
            "firstname": i.firstname,
            "lastname": i.lastname,
            "address": i.address,
            "phone": i.phone,
            "memodate": i.memodate,
            "expecteddate": i.expecteddate,
            "product": i.product,
            "brand": i.brand,
            "model": i.model,
            "imei": i.imei,
            "servicecharge": i.servicecharge,
            "problem": i.problem,
            "remarks": i.remarks,
            "status": i.status,
            "warrenty": i.warrenty,
            "totalamount": i.totalamount,
            "discount": i.discount,
            "finalamount": i.finalamount,
            "amountrecieved": i.amountrecieved,
            "duebalance": i.duebalance,
            "branch": i.branch,
            "createddate": i.createddate,
            "paymentmode": i.paymentmode,
            "technician": i.technician,
        }

        service_final.append(service_dict)

    context = {
        "data": service_final,
    }
    return render(request, "servicedelivered.html", context)


def get_service_details(service_obj):

    service_status = {
        "Unacknowledged": 0,
        "InProgress": 0,
        "Completed": 0,
        "Rejected": 0,
        "SpareRequested": 0,
        "SpareAllocated": 0,
    }

    for i in service_obj:
        if i["status"] == "Spare Allocated":
            service_status["SpareAllocated"] = i["status__count"]
        if i["status"] == "In Progress":
            service_status["InProgress"] = i["status__count"]
        if i["status"] == "Completed":
            service_status["Completed"] = i["status__count"]
        if i["status"] == "Spare Requested":
            service_status["SpareRequested"] = i["status__count"]
        if i["status"] == "Rejected":
            service_status["Rejected"] = i["status__count"]
        if i["status"] == "Unacknowledged":
            service_status["Unacknowledged"] = i["status__count"]

    return service_status


@user_passes_test(
    partial(check_permission, page="Serviceupdate"),
    login_url="/accessdenied/",
    redirect_field_name=None,
)
@login_required
def serviceUpdateForm(request, servicerefnumber):

    service = Service.objects.filter(servicerefnumber=servicerefnumber)
    spareparts = SpareParts.objects.filter(servicerefnumber=servicerefnumber)

    current_service_status = None

    for item in service:
        servicerefnumber = item.servicerefnumber
        customerid = item.customerid
        firstname = item.firstname
        lastname = item.lastname
        address = item.address
        phone = item.phone
        memodate = item.memodate
        expecteddate = item.expecteddate
        problems = item.problem
        remarks = item.remarks
        status = item.status
        warrenty = item.warrenty
        totalamount = item.totalamount
        discount = item.discount
        finalamount = item.finalamount
        amountrecieved = item.amountrecieved
        duebalance = item.duebalance
        accessories = item.get_accessories()
        paymentmode = item.paymentmode
        technician = item.technician

        if item.image1:
            image1 = GLOBAL_VARIABLES["current_host"] + item.image1.url
        else:
            image1 = ""
        if item.image2:
            image2 = GLOBAL_VARIABLES["current_host"] + item.image2.url
        else:
            image2 = ""
        if item.image3:
            image3 = GLOBAL_VARIABLES["current_host"] + item.image3.url
        else:
            image3 = ""
        if item.image4:
            image4 = GLOBAL_VARIABLES["current_host"] + item.image4.url
        else:
            image4 = ""
        if item.image5:
            image5 = GLOBAL_VARIABLES["current_host"] + item.image5.url
        else:
            image5 = ""
        if item.image6:
            image6 = GLOBAL_VARIABLES["current_host"] + item.image6.url
        else:
            image6 = ""
        totaltax = item.totaltax
        technician_remark = item.technician_remark
        reject_code = item.reject_code
        pattern = item.pattern

        try:
            qcoklist = item.get_qcok()
        except:
            qcoklist = []
        try:
            qcnotok_list = item.get_qcnotok()
        except:
            qcnotok_list = []
        qc = item.qc
        qcremark = item.qcremark
        current_service_status = item.status
        rack_number = item.rack_no

        break

    if totaltax == None:
        totaltax = 0

    numspareparts = len(spareparts)

    user = request.user
    branch = request.user.userprofile.branch

    if user.is_superuser:
        product_names = (
            Stock.objects.filter(quantity__gt=0)
            .values_list("name__id", flat=True)
            .distinct()
        )
        product_names = [
            Stock.objects.filter(name__id=pr).first().name for pr in product_names
        ]
        technician_list = UserProfile.objects.filter(role="Technician")

    else:
        product_names = (
            BranchStock.objects.filter(Q(quantity__gt=0) & Q(branch=branch))
            .values_list("name__id", flat=True)
            .distinct()
        )
        product_names = [
            BranchStock.objects.filter(name__id=pr).first().name for pr in product_names
        ]
        technician_list = UserProfile.objects.filter(
            Q(role="Technician") & Q(branch=branch)
        )

    salegst = Tax.objects.filter(branch=request.user.userprofile.branch)
    racks = Rack.objects.all()

    service_status = {}
    user = request.user

    if user.is_superuser:
        for serv in Service.objects.all():
            if serv.technician:
                if serv.technician.username in technician_list.values_list(
                    "user__username", flat=True
                ):
                    if serv.technician.username not in service_status.keys():
                        service_status[serv.technician.username] = {
                            "Unacknowledged": 0,
                            "InProgress": 0,
                            # "Completed":0,
                            "Rejected": 0,
                            "SpareRequested": 0,
                            "SpareAllocated": 0,
                        }

                    if serv.status == "In Progress":
                        service_status[serv.technician.username]["InProgress"] += 1
                    if serv.status == "Spare Requested":
                        service_status[serv.technician.username]["SpareRequested"] += 1
                    if serv.status == "Spare Allocated":
                        service_status[serv.technician.username]["SpareAllocated"] += 1
                    # if serv.status == "Completed":
                    #     service_status[serv.technician.username]['Completed'] +=1
                    if serv.status == "Unacknowledged":
                        service_status[serv.technician.username]["Unacknowledged"] += 1
                    if serv.status == "Rejected":
                        service_status[serv.technician.username]["Rejected"] += 1
        service_technicians = [
            tec[0] for tec in Service.objects.all().values_list("technician__username")
        ]
        for j in technician_list.values_list("user__username", flat=True):
            if j not in service_technicians:
                service_status[j] = {
                    "Unacknowledged": 0,
                    "InProgress": 0,
                    # "Completed":0,
                    "Rejected": 0,
                    "SpareRequested": 0,
                    "SpareAllocated": 0,
                }

    else:
        for serv in Service.objects.filter(branch=user.userprofile.branch):
            if serv.technician:
                if serv.technician.username in technician_list.values_list(
                    "user__username", flat=True
                ):
                    if serv.technician.username not in service_status.keys():
                        service_status[serv.technician.username] = {
                            "Unacknowledged": 0,
                            "InProgress": 0,
                            # "Completed":0,
                            "Rejected": 0,
                            "SpareRequested": 0,
                            "SpareAllocated": 0,
                        }
                    if serv.status == "In Progress":
                        service_status[serv.technician.username]["InProgress"] += 1
                    # if serv.status == "Completed":
                    #     service_status[serv.technician.username]['Completed'] +=1
                    if serv.status == "Unacknowledged":
                        service_status[serv.technician.username]["Unacknowledged"] += 1
                    if serv.status == "Rejected":
                        service_status[serv.technician.username]["Rejected"] += 1
                    if serv.status == "Spare Requested":
                        service_status[serv.technician.username]["SpareRequested"] += 1
                    if serv.status == "Spare Allocated":
                        service_status[serv.technician.username]["SpareAllocated"] += 1

        service_technicians = [
            tec[0]
            for tec in Service.objects.filter(
                branch=user.userprofile.branch
            ).values_list("technician__username")
        ]
        for j in technician_list.values_list("user__username", flat=True):
            if j not in service_technicians:
                service_status[j] = {
                    "Unacknowledged": 0,
                    "InProgress": 0,
                    # "Completed":0,
                    "Rejected": 0,
                    "SpareRequested": 0,
                    "SpareAllocated": 0,
                }

    if user.is_superuser:
        stocks = Stock.objects.filter(quantity__gt=0)
    else:
        stocks = BranchStock.objects.filter(
            Q(quantity__gt=0) & Q(branch=user.userprofile.branch)
        )
    stock_dict = {}
    for i in stocks:
        stock_dict[i.name] = i.quantity

    all_product_names = (
        BranchStock.objects.filter(Q(branch=branch)&Q(quantity__gt=0))
        .values_list("name__id", flat=True)
        .distinct()
    )
    all_product_names = [
        BranchStock.objects.filter(name__id=pr).first().name for pr in all_product_names
    ]

    # service info
    service_info = ServiceInformations.objects.filter(service=service.first())

    # service history
    service_history = ServiceHistory.objects.filter(service=service.first())

    # requested spares
    requested_spares_obj = SpareRequests.objects.filter(
        service=Service.objects.filter(servicerefnumber=servicerefnumber).first()
    )
    requested_spares_number = SpareRequests.objects.filter(
        service=Service.objects.filter(servicerefnumber=servicerefnumber).first()
    ).count()

    # service charge estimation
    servicechargeestimation = ServiceChargeRequests.objects.filter(
        service=service.first()
    ).first()

    # rack
    rack = Rack.objects.filter(branch=request.user.userprofile.branch)


    technician_list_new = []
    for key, value in service_status.items():
        data = {}
        data["username"] = key
        filtered_values = {k: v for k, v in value.items() if k != "Rejected"}
        data["pending"] = sum(filtered_values.values())
        technician_list_new.append(data)

    

    context = {
        "technician_status": service_status,
        "today": date.today(),
        "products": product_names,
        "tax": salegst,
        "servicerefnumber": servicerefnumber,
        "customerid": customerid,
        "firstname": firstname,
        "lastname": lastname,
        "address": address,
        "phone": phone,
        "memodate": memodate,
        "expecteddate": expecteddate,
        "problems": problems,
        "remarks": remarks,
        "status": status,
        "warrenty": warrenty,
        "totalamount": totalamount,
        "discount": discount,
        "finalamount": finalamount,
        "amountrecieved": amountrecieved,
        "duebalance": duebalance,
        "accessories": accessories,
        "item": service.first(),
        "spareparts": spareparts,
        "numspareparts": numspareparts,
        "paymentmode": paymentmode,
        "technician_list": technician_list,
        "technician_list_new": technician_list_new,
        "technician": technician,
        "image1": image1,
        "image2": image2,
        "image3": image3,
        "image4": image4,
        "image5": image5,
        "image6": image6,
        "rack_nos": racks,
        "totaltax": totaltax,
        "stock_list": stock_dict,
        "requested_spares_number": requested_spares_number,
        "user": request.user,
        "service_info": service_info,
        "technician_remark": technician_remark,
        "reject_code": reject_code,
        "qcremark": qcremark,
        "qcoklist": qcoklist,
        "qcnotoklist": qcnotok_list,
        "qc": qc,
        "all_spares": all_product_names,
        "requsted_spares": requested_spares_obj,
        "service_history": service_history,
        "service_charge_estimation": servicechargeestimation,
        "rack": rack,
        "rack_number": rack_number,
        "pattern": pattern,
    }

    if (
        current_service_status == "QC Passed(Ok)"
        or current_service_status == "QC Passed(NotOk)"
        or current_service_status == "CNP Inprogress(Ok)"
        or current_service_status == "CNP Inprogress(NotOk)"
        or current_service_status == "CNP Pending(Ok)"
        or current_service_status == "CNP Pending(NotOk)"
    ):
        if request.user.userprofile.branch.branchcategory == "Advanced":
            if (
                request.user.userprofile.role == "TRC Cleaning and Packing"
                or request.user.userprofile.role == "Branch Admin"
                or request.user.userprofile.role == "Franchise Admin"
                or request.user.userprofile.role == "TRC Front Desk"
            ):
                return render(request, "serviceupdatecnp.html", context)
            else:
                return render(request, "serviceupdateform.html", context)
        elif request.user.userprofile.branch.branchcategory == "Standard":
            if request.user.is_superuser:
                return render(request, "serviceupdateformstandard.html", context)
            elif (
                request.user.userprofile.role == "Technician"
                or request.user.userprofile.role == "Branch Admin"
                or request.user.userprofile.role == "Franchise Admin"
            ):
                return render(request, "serviceupdatecnpstandard.html", context)
            elif request.user.userprofile.role == "TRC Front Desk":
                return render(request, "serviceupdateformstandard.html", context)
            else:
                return render(request, "accessdenied.html")
        else:
            return render(request, "serviceupdateform.html", context)
    else:
        if request.user.is_superuser:
            return render(request, "serviceupdateformstandard.html", context)
        elif request.user.userprofile.branch.branchcategory == "Standard":
            if (
                request.user.userprofile.role == "Technician"
                or request.user.userprofile.role == "TRC Front Desk"
                or request.user.userprofile.role == "Branch Admin"
                or request.user.userprofile.role == "Franchise Admin"
                or request.user.userprofile.role == "Field Engineer"
            ):
                return render(request, "serviceupdateformstandard.html", context)
            else:
                return render(request, "accessdenied.html")
        else:
            return render(request, "serviceupdateform.html", context)


@login_required
def deleteSpareRequest(request, id, serviceref, page):

    spare = SpareRequests.objects.get(id=id)

    servicehistory = ServiceHistory()
    servicehistory.service = Service.objects.filter(servicerefnumber=serviceref).first()
    servicehistory.description = f"Spare request cancelled by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')} cancelled spare : {spare.spare.name} - {spare.requested_qty}"
    servicehistory.save()

    spare.delete()

    if page == "update":
        return redirect(
            reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
        )
    elif page == "details":
        return redirect(
            reverse("sparerequestdetails", kwargs={"serviceref": serviceref})
        )


@login_required
def serviceUpdate_old(request):

    ledger = Ledger()
    cashbook = CashBook()
    if request.method == "POST":

        service_product_list = Service.objects.filter(
            servicerefnumber=request.POST.get("refnumber")
        ).values_list("product", flat=True)

        spareparts_product_list = Products.objects.filter(
            spareparts__servicerefnumber=request.POST.get("refnumber")
        ).values_list("name", flat=True)

        due = request.POST.get("duebalance")
        servicerefnumber = request.POST.get("refnumber")
        recieved = float(request.POST.get("amountrecievedupdate"))
        paymentmode = request.POST.get("paymentmode")
        serv = Service.objects.filter(servicerefnumber=servicerefnumber).first()
        firstname = request.POST.get("firstnameservice")
        lastname = request.POST.get("lastnameservice")
        status = request.POST.get("status")

        prev_recieved = float(serv.amountrecieved)

        if prev_recieved != recieved and recieved > prev_recieved:
            recieved_amount = recieved - prev_recieved
            transaction = Transaction()
            transaction.transactionid = servicerefnumber
            transaction.amount = float(recieved_amount)
            transaction.transactiontype = "service"
            transaction.paymentmode = paymentmode
            transaction.branch = request.user.userprofile.branch
            transaction.invoice_number = servicerefnumber
            transaction.accounts = f"{firstname} {lastname}"
            transaction.remarks = ""
            transaction.subledger = func_get_sub_ledgers(request,'Service')
            transaction.save()

        for i in range(1, 11):

            product = request.POST.get("product" + str(i))
            if not product:
                continue
            brand = request.POST["brand" + str(i)]
            model = request.POST["model" + str(i)]
            imei = request.POST["imei" + str(i)]
            servicecharge = request.POST["serviceprice" + str(i)]
            firstname = request.POST["firstnameservice"]
            lastname = request.POST.get("lastnameservice")
            address = request.POST.get("addressservice")
            phone = request.POST.get("mobilenumber")
            servicerefnumber = request.POST.get("refnumber")
            customerid = request.POST.get("customeridservice")
            memodate = request.POST.get("serviceentrydate")
            paymentmode = request.POST.get("paymentmode")
            technician = request.POST.get("technician")

            if memodate == None or memodate == "":
                memodate = None

            estimateddate = request.POST.get("expecteddate")
            if estimateddate == None or estimateddate == "":
                estimateddate = None

            problemdetected = request.POST.get("problem")
            warrentystatus = request.POST.get("warrentystatus")
            remarks = request.POST.get("remarks")
            accessory_battery = request.POST.get("accessory[battery]")
            accessory_charger = request.POST.get("accessory[charger]")
            accessory_sim = request.POST.get("accessory[SIM]")
            accessory_memory = request.POST.get("accessory[memory]")
            accessories = list(
                filter(
                    lambda item: item is not None and item != "",
                    [
                        accessory_battery,
                        accessory_charger,
                        accessory_sim,
                        accessory_memory,
                    ],
                )
            )
            status = request.POST.get("status")
            # removing service item from rack and viceverca
            if status == "Delivered":
                try:
                    service_rack = Service.objects.filter(
                        servicerefnumber=servicerefnumber
                    ).first()
                    if service_rack:
                        service_rack.rack_no = None
                        service_rack.save()
                except:
                    pass
            # removing service item from rack and viceverca
            total = request.POST.get("totalamount")
            discount = request.POST.get("discountserviceupdate")
            if discount == "" or discount == None:
                discount = 0
            final = request.POST.get("finalamount")
            recieved = request.POST.get("amountrecievedupdate")

            totaltax = request.POST.get("totaltax")
            due = request.POST.get("duebalance")

            if product in service_product_list:
                service = Service.objects.filter(
                    Q(product=product) & Q(servicerefnumber=servicerefnumber)
                ).first()
            else:
                service = Service()
            service.servicerefnumber = servicerefnumber
            service.technician = User.objects.get(username=technician)
            service.customerid = customerid
            service.firstname = firstname
            service.lastname = lastname
            service.address = address
            service.phone = phone
            service.memodate = memodate
            service.expecteddate = estimateddate
            service.problem = problemdetected
            service.remarks = remarks
            service.warrenty = warrentystatus
            service.status = status
            service.totalamount = total
            service.discount = discount
            service.finalamount = final
            service.totaltax = totaltax
            service.amountrecieved = recieved
            service.duebalance = due
            service.branch = request.user.userprofile.branch
            service.set_accessories(accessories)
            service.product = product
            service.brand = brand
            service.model = model
            service.imei = imei
            service.servicecharge = servicecharge
            service.paymentmode = paymentmode
            service.save()

        for j in range(1, 11):
            saleproduct = request.POST.get("salename" + str(j))
            if not saleproduct:
                continue
            salebarcode = request.POST["salebarcode" + str(j)]
            saleprice = request.POST["saleprice" + str(j)]
            salegst = request.POST["salegstsale" + str(j)]

            if request.POST["salemrp" + str(j)]:
                mrp = float(request.POST["salemrp" + str(j)])
            else:
                mrp = None
            if request.POST["salemop" + str(j)]:
                mop = float(request.POST["salemop" + str(j)])
            else:
                mop = None

            quantity = request.POST["salequantity" + str(j)]

            if saleproduct in spareparts_product_list:

                spare = SpareParts.objects.filter(
                    Q(name__name=saleproduct) & Q(servicerefnumber=servicerefnumber)
                ).first()

                prev_quantity = spare.totalquantity

                if int(quantity) > int(prev_quantity):
                    final_quantity = int(quantity) - int(prev_quantity)

                    branch = request.user.userprofile.branch
                    product = Products.objects.get(name=saleproduct)
                    if branch.name == "WAREHOUSE":
                        stock_obj = Stock.objects.filter(name=product).first()
                    else:
                        stock_obj = BranchStock.objects.filter(
                            Q(branch=branch) & Q(name=product)
                        ).first()

                    if stock_obj:
                        # stock_obj.update(quantity=F('quantity')- final_quantity)
                        qty = stock_obj.quantity
                        stock_obj.quantity = int(qty) - int(final_quantity)
                        stock_obj.save()

                elif int(quantity) < int(prev_quantity):
                    final_quantity = int(prev_quantity) - int(quantity)

                    branch = request.user.userprofile.branch
                    product = Products.objects.get(name=saleproduct)
                    if branch.name == "WAREHOUSE":
                        stock_obj = Stock.objects.filter(name=product).first()
                    else:
                        stock_obj = BranchStock.objects.filter(
                            Q(branch=branch) & Q(name=product)
                        ).first()

                    if stock_obj:
                        # stock_obj.update(quantity=F('quantity')- final_quantity)

                        qty = stock_obj.quantity
                        stock_obj.quantity = int(qty) - int(final_quantity)
                        stock_obj.save()

            else:
                spare = SpareParts()
                branch = request.user.userprofile.branch
                product = Products.objects.get(name=saleproduct)

                if branch.name == "WAREHOUSE":
                    stock_obj = Stock.objects.filter(name=product).first()
                else:
                    stock_obj = BranchStock.objects.filter(
                        Q(branch=branch) & Q(name=product)
                    ).first()

                if stock_obj:
                    # stock_obj.update(quantity=F('quantity')- quantity)

                    qty = stock_obj.quantity
                    stock_obj.quantity = int(qty) - int(quantity)
                    stock_obj.save()

            spare.name = Products.objects.get(name=saleproduct)
            spare.servicerefnumber = servicerefnumber
            spare.customerid = customerid
            spare.barcodenumber = salebarcode
            spare.totalquantity = quantity
            spare.price = saleprice
            spare.salegst = salegst
            spare.mrp = mrp
            spare.mop = mop
            spare.branch = request.user.userprofile.branch
            spare.paymentmode = paymentmode
            spare.save()

        if (
            status == "Deliverd"
            and prev_recieved != recieved
            and recieved > prev_recieved
        ):

            branch = request.user.userprofile.branch
            amount = recieved - prev_recieved
            serviceduebalance = service.duebalance
            ledger.refernceno = servicerefnumber
            ledger.date = memodate
            ledger.narration = "Service Transaction"
            ledger.account_type = coa.INCOME["account_type"]
            ledger.debit_amount = 0
            ledger.credit_amount = amount
            ledger.account_head = coa.INCOME["name"]
            ledger.account_subhead = "Service"
            ledger.customer_or_vendor = service.firstname
            ledger.branch = branch
            ledger.pk = None
            ledger.save()

            ledger.refernceno = servicerefnumber
            ledger.date = memodate
            ledger.narration = "Service Transaction"
            ledger.account_type = coa.ASSET["account_type"]
            ledger.debit_amount = recieved
            ledger.credit_amount = 0
            ledger.account_head = coa.ASSET["name"]
            ledger.account_subhead = "Cash"  # for now hardcoding this and it should match with the subhead saved.
            ledger.customer_or_vendor = service.firstname
            ledger.branch = branch
            ledger.pk = None
            ledger.save()

            if service.duebalance != 0:
                ledger.refernceno = servicerefnumber
                ledger.date = memodate
                ledger.narration = "Service Transaction"
                ledger.account_type = coa.ASSET["account_type"]
                ledger.debit_amount = serviceduebalance
                ledger.credit_amount = 0
                ledger.account_head = coa.ASSET["name"]
                ledger.account_subhead = "Customer"  # for now hardcoding this and it should match with the subhead saved.
                ledger.customer_or_vendor = service.firstname
                ledger.branch = branch
                ledger.pk = None
                ledger.save()

            cashbook.branch = branch
            cashbook.payment = 0
            cashbook.receipt = amount
            cashbook.mode = paymentmode
            cashbook.date = memodate
            cashbook.description = "Service"
            cashbook.save()

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": servicerefnumber})
    )


# @no_fieldengineer
@login_required
def serviceUpdate(request):

    ledger = Ledger()
    cashbook = CashBook()
    if request.method == "POST":
        servicerefnumber = request.POST.get("refnumber")
        serv = Service.objects.filter(servicerefnumber=servicerefnumber).first()
        changedattribute = request.POST.get("changedattribute")

        changedattribute_length = len(changedattribute.split(","))
        if changedattribute_length == 1 and changedattribute[0] == "":
            pass
        else:
            servicehistory = ServiceHistory()
            servicehistory.service = serv
            servicehistory.description = f"{changedattribute} edited by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
            servicehistory.save()

        service_product_list = Service.objects.filter(
            servicerefnumber=request.POST.get("refnumber")
        ).values_list("product", flat=True)

        spareparts_product_list = Products.objects.filter(
            Q(spareparts__servicerefnumber=request.POST.get("refnumber"))
            & Q(branch=request.user.userprofile.branch)
        ).values_list("name", flat=True)

        try:
            due = request.POST.get("duebalance")
        except:
            due = None


        try:
            recieved = float(request.POST.get("amountrecievedupdate"))
        except:
            recieved = None

        try:
            paymentmode = request.POST.get("paymentmode")
        except:
            paymentmode = None

        previousstatus = serv.status
        try:
            firstname = request.POST.get("firstnameservice")
        except:
            firstname = None

        try:
            lastname = request.POST.get("lastnameservice")
        except:
            lastname = None

        try:
            status = request.POST.get("status")
        except:
            status = None

        prev_recieved = float(serv.amountrecieved)

        if recieved:
            if prev_recieved != recieved and recieved > prev_recieved:
                recieved_amount = recieved - prev_recieved
                transaction = Transaction()
                transaction.transactionid = servicerefnumber
                transaction.amount = float(recieved_amount)
                transaction.transactiontype = "service"
                transaction.paymentmode = paymentmode
                transaction.branch = request.user.userprofile.branch
                transaction.invoice_number = servicerefnumber
                transaction.accounts = f"{firstname} {lastname}"
                transaction.remarks = ""
                transaction.subledger = func_get_sub_ledgers(request,'Service')
                transaction.save()

        for i in range(1, 101):
            try:
                product = request.POST.get("product" + str(i))
            except:
                product = None
            if not product:
                continue
            try:
                brand = request.POST["brand" + str(i)]
            except:
                brand = None
            try:
                model = request.POST["model" + str(i)]
            except:
                model = None
            try:
                imei = request.POST["imei" + str(i)]
            except:
                imei = None
            try:
                servicecharge = request.POST["serviceprice" + str(i)]
            except:
                servicecharge = None
            try:
                firstname = request.POST["firstnameservice"]
            except:
                firstname = None
            try:
                lastname = request.POST.get("lastnameservice")
            except:
                lastname = None
            try:
                address = request.POST.get("addressservice")
            except:
                address = None
            try:
                phone = request.POST.get("mobilenumber")
            except:
                phone = None
            try:
                servicerefnumber = request.POST.get("refnumber")
            except:
                servicerefnumber = None
            try:
                customerid = request.POST.get("customeridservice")
            except:
                customerid = None
            try:
                memodate = request.POST.get("serviceentrydate")
            except:
                memodate = None
            try:
                paymentmode = request.POST.get("paymentmode")
            except:
                paymentmode = None
            try:
                technician = request.POST.get("technician")
            except:
                technician = None

            if memodate == "":
                memodate = None
            try:
                estimateddate = request.POST.get("expecteddate")
            except:
                estimateddate = None

            if estimateddate == "":
                estimateddate = None

            try:
                problemdetected = request.POST.get("problem")
            except:
                problemdetected = None

            try:
                warrentystatus = request.POST.get("warrentystatus")
            except:
                warrentystatus = None
            try:
                remarks = request.POST.get("remarks")
            except:
                remarks = None
            try:
                accessory_battery = request.POST.get("accessory[battery]")
            except:
                accessory_battery = None
            try:
                accessory_charger = request.POST.get("accessory[charger]")
            except:
                accessory_charger = None
            try:
                accessory_sim = request.POST.get("accessory[SIM]")
            except:
                accessory_sim = None
            try:
                accessory_memory = request.POST.get("accessory[memory]")
            except:
                accessory_memory = None
            if (
                not accessory_battery
                and not accessory_charger
                and not accessory_memory
                and not accessory_sim
            ):
                accessories = None
            else:
                accessories = list(
                    filter(
                        lambda item: item is not None and item != "",
                        [
                            accessory_battery,
                            accessory_charger,
                            accessory_sim,
                            accessory_memory,
                        ],
                    )
                )
            try:
                status = request.POST.get("status")
            except:
                status = None
            # removing service item from rack and viceverca
            if status == "Delivered":
                try:
                    service_rack = Service.objects.filter(
                        servicerefnumber=servicerefnumber
                    ).first()
                    if service_rack:
                        service_rack.rack_no = None
                        service_rack.save()
                except:
                    pass
            # removing service item from rack and viceverca
            try:
                total = request.POST.get("totalamount")
            except:
                total = None
            try:
                discount = request.POST.get("discountserviceupdate")
            except:
                discount = "null"

            if discount == "" or discount == None:
                discount = 0
            try:
                final = request.POST.get("finalamount")
            except:
                final = None
            try:
                recieved = request.POST.get("amountrecievedupdate")
            except:
                recieved = None
            try:
                totaltax = request.POST.get("totaltax")
            except:
                totaltax = None
            try:
                due = request.POST.get("duebalance")
            except:
                due = None

            if product in service_product_list:
                service = Service.objects.filter(
                    Q(product=product) & Q(servicerefnumber=servicerefnumber)
                ).first()
            else:
                service = Service()

            if servicerefnumber:
                service.servicerefnumber = servicerefnumber
            if technician:
                service.technician = User.objects.get(username=technician)
            if customerid:
                service.customerid = customerid
            if firstname:
                service.firstname = firstname
            if lastname:
                service.lastname = lastname
            if address:
                service.address = address
            if phone:
                service.phone = phone
            if memodate:
                service.memodate = memodate
            if estimateddate:
                service.expecteddate = estimateddate
            if problemdetected:
                service.problem = problemdetected
            if remarks:
                service.remarks = remarks
            if warrentystatus:
                service.warrenty = warrentystatus
            if status:
                service.status = status
            if total:
                service.totalamount = total
            if discount != "null":
                service.discount = discount
            if final:
                service.finalamount = final
            if totaltax:
                service.totaltax = totaltax
            if recieved:
                service.amountrecieved = recieved
            if due:
                service.duebalance = due
            service.branch = request.user.userprofile.branch
            if accessories:
                service.set_accessories(accessories)
            if product:
                service.product = product
            if brand:
                service.brand = brand
            if model:
                service.model = model
            if imei:
                service.imei = imei
            if servicecharge:
                service.servicecharge = servicecharge
            if paymentmode:
                service.paymentmode = paymentmode

            service.modifieddate = date.today()

            service.save()

        if (
            status == "Deliverd"
            and prev_recieved != recieved
            and recieved > prev_recieved
        ):

            branch = request.user.userprofile.branch
            amount = recieved - prev_recieved
            serviceduebalance = service.duebalance
            ledger.refernceno = servicerefnumber
            ledger.date = memodate
            ledger.narration = "Service Transaction"
            ledger.account_type = coa.INCOME["account_type"]
            ledger.debit_amount = 0
            ledger.credit_amount = amount
            ledger.account_head = coa.INCOME["name"]
            ledger.account_subhead = "Service"
            ledger.customer_or_vendor = service.firstname
            ledger.branch = branch
            ledger.pk = None
            ledger.save()

            ledger.refernceno = servicerefnumber
            ledger.date = memodate
            ledger.narration = "Service Transaction"
            ledger.account_type = coa.ASSET["account_type"]
            ledger.debit_amount = recieved
            ledger.credit_amount = 0
            ledger.account_head = coa.ASSET["name"]
            ledger.account_subhead = "Cash"  # for now hardcoding this and it should match with the subhead saved.
            ledger.customer_or_vendor = service.firstname
            ledger.branch = branch
            ledger.pk = None
            ledger.save()

            if service.duebalance != 0:
                ledger.refernceno = servicerefnumber
                ledger.date = memodate
                ledger.narration = "Service Transaction"
                ledger.account_type = coa.ASSET["account_type"]
                ledger.debit_amount = serviceduebalance
                ledger.credit_amount = 0
                ledger.account_head = coa.ASSET["name"]
                ledger.account_subhead = "Customer"  # for now hardcoding this and it should match with the subhead saved.
                ledger.customer_or_vendor = service.firstname
                ledger.branch = branch
                ledger.pk = None
                ledger.save()

            cashbook.branch = branch
            cashbook.payment = 0
            cashbook.receipt = amount
            cashbook.mode = paymentmode
            cashbook.date = memodate
            cashbook.description = "Service"
            cashbook.save()

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": servicerefnumber})
    )


@login_required
def serviceAcknoledgeCnp(request):
    if request.method == "POST":
        serviceref = request.POST["refnumber"]
        status = request.POST["status"]
        service = Service.objects.filter(servicerefnumber=serviceref).first()
        service.cnp = request.user
        service.status = status
        service.modifieddate = date.today()
        service.save()

        servicehistory = ServiceHistory()
        servicehistory.service = service
        servicehistory.description = f"Service acknoledged by {request.user.username} for dispatch on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
        servicehistory.save()

    return redirect(
        reverse("serviceupdateform", kwargs={"servicerefnumber": serviceref})
    )


@login_required
def serviceCompleteRack(request):

    accessory_battery = request.POST.get("2accessory[battery]")
    accessory_charger = request.POST.get("2accessory[charger]")
    accessory_sim = request.POST.get("2accessory[SIM]")
    accessory_memory = request.POST.get("2accessory[memory]")
    accessories = list(
        filter(
            lambda item: item is not None and item != "",
            [accessory_battery, accessory_charger, accessory_sim, accessory_memory],
        )
    )
    service_ref = request.POST.get("refnumber")
    service = Service.objects.filter(servicerefnumber=service_ref).first()
    prevstatus = service.status
    saved_accessories = service.get_accessories()
    rack_no = request.POST.get("rackno")
    if saved_accessories != accessories:
        messages.error(request, "Accessories do not match!")
        return redirect(
            reverse("serviceupdateform", kwargs={"servicerefnumber": service_ref})
        )

    else:
        service.rack_no = rack_no
        if prevstatus == "CNP Inprogress(Ok)":
            service.status = "CNP Completed(Ok)"
            service.modifieddate = date.today()
        elif prevstatus == "CNP Inprogress(NotOk)":
            service.status = "CNP Completed(NotOk)"
            service.modifieddate = date.today()
        service.save()

        servicehistory = ServiceHistory()
        servicehistory.service = service
        servicehistory.description = f"Service completed by {request.user.username} for dispatch on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}"
        servicehistory.save()

        #######  Changing boooking status | 17-07-2024 ##########
        if service.booking != None and service.booking != "":
            booking = service.booking
            booking.status = "Completed"
            booking.save()
            #######  Changing boooking status #######################
            #######  send notification to field engineer | 17-07-2024 ##########
            try:
                notification_message = f"Service ready for checkout ({service.booking.bookingid}) packing completed by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}."
                notification = BroadcastNotification()
                notification.message = notification_message
                notification.broadcast_on = timezone.now() + timedelta(seconds=5)
                notification.notification_type = "service_booking"
                notification.notification_id = service_ref
                branch = request.user.userprofile.branch
                notification.user = service.booking.assigned_to
                notification.save()
            except:
                pass
        #######  send notification to field engineer | 17-07-2024 ##########

        try:
            notification_message = f"Service ready for checkout packing completed by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}."
            front_desk = (
                Service.objects.filter(servicerefnumber=service_ref).first().frontdesk
            )
            notification = BroadcastNotification()
            notification.message = notification_message
            notification.broadcast_on = timezone.now() + timedelta(seconds=5)
            notification.notification_type = "service_checkout"
            notification.notification_id = service_ref
            branch = request.user.userprofile.branch
            notification.user = front_desk
            notification.save()
        except:
            pass

        #######  send notification to field engineer mobile app | 17-07-2024 ##########

        try:
            notification_message = f"Service ready for checkout packing completed by {request.user.username} on {datetime.now().strftime('%b %d, %Y, %I:%M %p')}."
            front_desk = (
                Service.objects.filter(servicerefnumber=service_ref).first().frontdesk
            )
            notification = BroadcastNotificationMobileApp()
            notification.message = notification_message
            notification.broadcast_on = datetime.now() + timedelta(seconds=5)
            notification.notification_type = "service_checkout"
            notification.notification_id = service_ref
            branch = request.user.userprofile.branch
            notification.user = front_desk
            notification.save()
        except:
            pass

        # try:
        #     email=service.technician.email
        #     sendEmail(email , "Spare Allocated" , notification_message)
        # except:
        #     pass

        return redirect("service")


@login_required
def rackList(request):

    rack = Rack.objects.all().order_by("-pk")

    context = {
        "rack_list": rack,
    }

    return render(request, "Racklist.html", context)


@login_required
def serviceCallLogs(request, serviceref):

    service = Service.objects.filter(servicerefnumber=serviceref).first()

    call_logs = ServiceCallLogs.objects.filter(service=service)

    chat_messages = ServiceChat.objects.filter(service=service)

    ##### building customer whatsapp chat link #####
    country_obj = Country.objects.filter(default=True).first()
    calling_code = country_obj.calling_code
    if "+" in calling_code:
        calling_code = calling_code.replace("+","")

    digit = country_obj.phone_number_digit
    number= str(service.phone)

    if len(str(number)) >= digit:
        number = str(number)[-digit:]
        number = str(calling_code) + number

    whatsapp_chat_link = f"https://wa.me/{number}"

   
    context = {
        "customer": service,
        "messages": chat_messages,
        "call_logs": call_logs,
        "wpp_chat_link":whatsapp_chat_link
    }

    return render(request, "servicecalllogs.html", context)


@login_required
def scheduleCall(request):

    datetime_str = request.POST.get("datetime")
    serviceref = request.POST.get("serviceref")
    datetime_format = "%d.%m.%Y %H:%M"
    datetime_obj = datetime.strptime(datetime_str, datetime_format)

    service = Service.objects.filter(servicerefnumber=serviceref).first()

    service.shedule_call = datetime_obj
    service.save()

    current_user = request.user

    notification = ScheduleCallNotifications()
    notification.message = f"Call {service.firstname} {service.lastname} on {service.phone} at {datetime_obj.strftime('%b %d, %Y, %I:%M %p')}"
    notification.notification_type = "servicecall"
    notification.user = current_user
    notification.service = service
    notification.serviceref = serviceref
    notification.status = "Initial"
    notification.shedule_call = datetime_obj
    notification.save()

    return redirect(reverse("servicecalllogs", kwargs={"serviceref": serviceref}))


@login_required
def get_call_schedule_notifications(request):

    notifications = ScheduleCallNotifications.objects.filter(
        Q(user=request.user) & Q(shedule_call__date__lte=datetime.today().date())
    )

    if len(notifications) > 0:
        for obj in notifications:
            if obj.status == "Initial":
                obj.status = "Active"
                obj.save()

    active_notification_count = ScheduleCallNotifications.objects.filter(
        Q(user=request.user)
        & Q(shedule_call__date__lte=datetime.today().date())
        & Q(status="Active")
    ).count()

    response_data = {"active_count": active_notification_count}

    return JsonResponse(response_data)


@login_required
def saveCallLogs(request, serviceref, remark, notificationid):
    call_log_obj = ServiceCallLogs()
    service = Service.objects.filter(servicerefnumber=serviceref).first()
    call_log_obj.service = service
    call_log_obj.remark = remark
    call_log_obj.save()

    service.shedule_call = None
    service.save()

    notification = ScheduleCallNotifications.objects.filter(id=notificationid).first()
    notification.status = "InActive"
    notification.save()
    return redirect(reverse("servicecalllogs", kwargs={"serviceref": serviceref}))


def get_service_status_daily(request):

    received_data = QueryDict(request.body)

    date_selected = received_data.get("date")
    branch_selected = received_data.get("branch")
    technician_selected = received_data.get("technician")
    currentuser = request.user
    if date_selected:
        date_format = "%d-%m-%Y"
        date_selected = datetime.strptime(date_selected, date_format)
    if date_selected and branch_selected and technician_selected:
        if branch_selected == "allbranches" and technician_selected == "alltechnician":
            service_obj = (
                Service.objects.filter(modifieddate=date_selected)
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
        elif branch_selected == "allbranches":
            technician = User.objects.filter(username=technician_selected).first()
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate=date_selected) & Q(technician=technician)
                )
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
        elif technician_selected == "alltechnician":
            branch = Branch.objects.filter(name=branch_selected).first()
            service_obj = (
                Service.objects.filter(Q(modifieddate=date_selected) & Q(branch=branch))
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
        else:
            technician = User.objects.filter(username=technician_selected).first()
            branch = Branch.objects.filter(name=branch_selected).first()
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate=date_selected)
                    & Q(branch=branch)
                    & Q(technician=technician)
                )
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
    elif date_selected and technician_selected:
        if technician_selected == "alltechnician":
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate=date_selected)
                    & Q(branch=currentuser.userprofile.branch)
                )
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
        else:
            technician = User.objects.filter(username=technician_selected).first()
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate=date_selected)
                    & Q(technician=technician)
                    & Q(branch=currentuser.userprofile.branch)
                )
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
    elif date_selected:
        technician = User.objects.filter(username=request.user.username).first()
        service_obj = (
            Service.objects.filter(
                Q(modifieddate=date_selected) & Q(technician=technician)
            )
            .values("status")
            .annotate(Count("status"))
        )
        service_status = get_service_details(service_obj)

    return JsonResponse(service_status)


def get_service_status_monthly(request):

    received_data = QueryDict(request.body)
    date_selected = received_data.get("date")
    branch_selected = received_data.get("branch")
    technician_selected = received_data.get("technician")
    currentuser = request.user
    if date_selected and branch_selected and technician_selected:
        if branch_selected == "allbranches" and technician_selected == "alltechnician":
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate__month=date_selected)
                    & Q(modifieddate__year=date.today().year)
                )
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
        elif branch_selected == "allbranches":
            technician = User.objects.filter(username=technician_selected).first()
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate__month=date_selected)
                    & Q(modifieddate__year=date.today().year)
                    & Q(technician=technician)
                )
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
        elif technician_selected == "alltechnician":
            branch = Branch.objects.filter(name=branch_selected).first()
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate__month=date_selected)
                    & Q(modifieddate__year=date.today().year)
                    & Q(branch=branch)
                )
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
        else:
            technician = User.objects.filter(username=technician_selected).first()
            branch = Branch.objects.filter(name=branch_selected).first()
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate__month=date_selected)
                    & Q(modifieddate__year=date.today().year)
                    & Q(branch=branch)
                    & Q(technician=technician)
                )
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
    elif date_selected and technician_selected:
        if technician_selected == "alltechnician":
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate__month=date_selected)
                    & Q(modifieddate__year=date.today().year)
                    & Q(branch=currentuser.userprofile.branch)
                )
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
        else:
            technician = User.objects.filter(username=technician_selected).first()
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate__month=date_selected)
                    & Q(modifieddate__year=date.today().year)
                    & Q(technician=technician)
                    & Q(branch=currentuser.userprofile.branch)
                )
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
    elif date_selected:
        technician = User.objects.filter(username=request.user.username).first()
        tech_branch = technician.userprofile.branch
        service_obj = (
            Service.objects.filter(
                Q(modifieddate__month=date_selected)
                & Q(modifieddate__year=date.today().year)
                & Q(technician=technician)
                & Q(branch=tech_branch)
            )
            .values("status")
            .annotate(Count("status"))
        )
        service_status = get_service_details(service_obj)

    return JsonResponse(service_status)


def get_service_status_yearly(request):

    received_data = QueryDict(request.body)
    date_selected = received_data.get("date")
    branch_selected = received_data.get("branch")
    technician_selected = received_data.get("technician")
    currentuser = request.user
    if date_selected and branch_selected and technician_selected:
        if branch_selected == "allbranches" and technician_selected == "alltechnician":
            service_obj = (
                Service.objects.filter(modifieddate__year=int(date_selected))
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
        elif branch_selected == "allbranches":
            technician = User.objects.filter(username=technician_selected).first()
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate__year=int(date_selected)) & Q(technician=technician)
                )
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
        elif technician_selected == "alltechnician":
            branch = Branch.objects.filter(name=branch_selected).first()
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate__year=int(date_selected)) & Q(branch=branch)
                )
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
        else:
            technician = User.objects.filter(username=technician_selected).first()
            branch = Branch.objects.filter(name=branch_selected).first()
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate__year=int(date_selected))
                    & Q(branch=branch)
                    & Q(technician=technician)
                )
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
    elif date_selected and technician_selected:
        if technician_selected == "alltechnician":
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate__year=int(date_selected))
                    & Q(branch=currentuser.userprofile.branch)
                )
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
        else:
            technician = User.objects.filter(username=technician_selected).first()
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate__year=int(date_selected))
                    & Q(technician=technician)
                    & Q(branch=currentuser.userprofile.branch)
                )
                .values("status")
                .annotate(Count("status"))
            )
            service_status = get_service_details(service_obj)
    elif date_selected:
        technician = User.objects.filter(username=request.user.username).first()
        service_obj = (
            Service.objects.filter(
                Q(modifieddate__year=int(date_selected)) & Q(technician=technician)
            )
            .values("status")
            .annotate(Count("status"))
        )
        service_status = get_service_details(service_obj)
    return JsonResponse(service_status)


# Service functions end here


# Dashboard functions start here


def get_customers_monthly(request):
    user = request.user
    current_year = date.today().year
    if user.is_superuser:
        monthly_customers = (
            Customers.objects.filter(createddate__year=current_year)
            .values("createddate__month")
            .annotate(count=Count("id"))
        )
    elif user.userprofile.role == "Field Engineer":
        monthly_customers = (
            Customers.objects.filter(
                Q(createddate__year=current_year) & Q(addedby=user)
            )
            .values("createddate__month")
            .annotate(count=Count("id"))
        )
    else:
        monthly_customers = (
            Customers.objects.filter(
                Q(createddate__year=current_year) & Q(branch=user.userprofile.branch)
            )
            .values("createddate__month")
            .annotate(count=Count("id"))
        )

    monthly_customer_counts = [0] * 12
    for entry in monthly_customers:
        month = entry["createddate__month"]
        count = entry["count"]
        monthly_customer_counts[month - 1] = count
    return JsonResponse({"response": monthly_customer_counts})


def get_purchase_monthly(request):
    current_year = date.today().year
    user = request.user
    if user.is_superuser:
        purchaseobj = Purchase.objects.filter(invoicedate__year=current_year).values(
            "invoicedate__month", "purchaseid", "totalbillingamount"
        )
        purchaseid_set = set()
        purchaseobj = [
            purchase
            for purchase in purchaseobj
            if (
                purchase["purchaseid"] not in purchaseid_set
                and not purchaseid_set.add(purchase["purchaseid"])
            )
        ]

    else:
        purchaseobj = BranchPurchase.objects.filter(
            Q(invoicedate__year=current_year) & Q(branch=user.userprofile.branch)
        ).values("invoicedate__month", "purchaseid", "totalbillingamount")
        purchaseid_set = set()
        purchaseobj = [
            purchase
            for purchase in purchaseobj
            if (
                purchase["purchaseid"] not in purchaseid_set
                and not purchaseid_set.add(purchase["purchaseid"])
            )
        ]

    monthly_purchase_total = [0] * 12
    nettotal = 0
    for net in purchaseobj:
        monthly_purchase_total[net["invoicedate__month"] - 1] += net[
            "totalbillingamount"
        ]
        nettotal += net["totalbillingamount"]
    monthly_purchase_total = [round(i, 2) for i in monthly_purchase_total]
    return JsonResponse({"response": monthly_purchase_total, "nettotal": nettotal})


def get_sales_monthly(request):
    current_year = date.today().year
    user = request.user
    if user.is_superuser:
        salesobj = Sale.objects.filter(invoicedate__year=current_year).values(
            "invoicedate__month", "saleid", "totalbillingamount"
        )
        saleid_set = set()
        salesobj = [
            sale
            for sale in salesobj
            if (sale["saleid"] not in saleid_set and not saleid_set.add(sale["saleid"]))
        ]
    else:
        salesobj = Sale.objects.filter(
            Q(invoicedate__year=current_year) & Q(branch=user.userprofile.branch)
        ).values("invoicedate__month", "saleid", "totalbillingamount")
        saleid_set = set()
        salesobj = [
            sale
            for sale in salesobj
            if (sale["saleid"] not in saleid_set and not saleid_set.add(sale["saleid"]))
        ]

    monthly_sales_total = [0] * 12
    nettotal = 0
    for net in salesobj:
        monthly_sales_total[net["invoicedate__month"] - 1] += net["totalbillingamount"]
        nettotal += net["totalbillingamount"]

    monthly_sales_total = [round(i, 2) for i in monthly_sales_total]
    return JsonResponse({"response": monthly_sales_total, "nettotal": nettotal})


@login_required
def get_technician_by_branch(request):
    if request.method == "POST":
        received_data = QueryDict(request.body)
        branch = received_data.get("branch")

        branch = Branch.objects.filter(name=branch).first()

        user = [
            i.user.username
            for i in UserProfile.objects.filter(Q(branch=branch) & Q(role="Technician"))
        ]
        response_data = {
            "message": "Technician details fetched successfully.",
            "technicians": user,
        }
        return JsonResponse(response_data)


def calculate_unique_income(saleidlist, saleincomelist):
    final_output = []
    for sale in saleidlist:
        name = sale["name"]
        # Create a mapping of saleid to sale_income
        saleid_income_map = {}
        # Find the corresponding sale_income list by name
        income_list = next(
            (item["sale_income"] for item in saleincomelist if item["name"] == name), []
        )

        for i, saleid in enumerate(sale["saleid"]):
            if saleid not in saleid_income_map:
                # Map the first occurrence of saleid to its income
                saleid_income_map[saleid] = income_list[i]

        # Sum the unique incomes
        total_income = sum(saleid_income_map.values())
        final_output.append({"name": name, "sale_income": total_income})

    return final_output


def calculate_purchase_cost(barcode_lists):

    final_results = []

    for item in barcode_lists:
        branch_name = item["name"]
        barcodes = list(set(item["barcode"]))
        total_purchase_cost = 0

        for barcode in barcodes:
            sale_instance = Sale.objects.filter(
                Q(invoicenumber=barcode) & Q(branch__name=branch_name)
            )

            if sale_instance:
                for sale in sale_instance:
                    quantity = sale.totalquantity
                    product_instance = sale.name
                    if product_instance:
                        # gst_rate = float(product_instance.purchasegst.percentage)
                        gst_rate = float(sale.purchase_tax)

                        # purchase_cost = product_instance.price + (
                        #     (gst_rate / 100) * product_instance.price
                        # )
                        purchase_cost = sale.purchase_price + (
                            (gst_rate / 100) * sale.purchase_price
                        )
                        total_purchase_cost += purchase_cost * quantity

        final_results.append(
            {"name": branch_name, "purchase_cost": total_purchase_cost}
        )

    return final_results


def func_dashboard_table(user):
    #########################################################################
    today = datetime.today().date()

    branches_with_service_count = (
        Branch.objects.filter(Q(branchtype="Own") | Q(branchtype="Franchise"))
        .annotate(
            service_count=Count("services", filter=Q(services__createddate=today)),
            service_completed=Count(
                "services",
                filter=Q(services__modifieddate=today)
                & Q(services__status="Delivered(Ok)"),
            ),
            service_not_completed=Count(
                "services",
                filter=Q(services__modifieddate=today)
                & Q(services__status="Delivered(NotOk)"),
            ),
            completed_waiting_dispatch=Count(
                "services",
                filter=Q(services__modifieddate=today)
                & Q(services__status="CNP Completed(Ok)"),
            ),
            pending_under_repair=Count(
                "services",
                filter=Q(services__modifieddate=today)
                & (
                    Q(services__status="Unacknowledged")
                    | Q(services__status="In Progress")
                    | Q(services__status="Spare Requested")
                    | Q(services__status="Spare Allocated")
                ),
            ),
            service_income=Sum(
                "services__amountrecieved",
                filter=Q(services__modifieddate=today)
                & Q(services__status="Delivered(Ok)"),
            ),
            # sale_income=Sum('branch_sales__amountrecieved',filter=Q(branch_sales__invoicedate=today)),
        )
        .values(
            "name",
            "service_count",
            "service_completed",
            "service_not_completed",
            "service_income",
            "completed_waiting_dispatch",
            "pending_under_repair",
        )
    )

    data_list = [
        {
            "branch": branch["name"],
            "input": branch["service_count"],
            "output_ok": branch["service_completed"],
            "output_notok": branch["service_not_completed"],
            "completed_waiting_dispatch": branch["completed_waiting_dispatch"],
            "pending_under_repair": branch["pending_under_repair"],
            "service_income": branch["service_income"],
            # 'sale_income':branch['sale_income'],
        }
        for branch in branches_with_service_count
    ]

    #########################################################################

    branches_with_service = Branch.objects.filter(
        (Q(branchtype="Own") | Q(branchtype="Franchise"))
        & Q(services__modifieddate=today)
    ).values("name", "services__servicerefnumber")

    grouped_data = defaultdict(list)
    for item in branches_with_service:
        grouped_data[item["name"]].append(item["services__servicerefnumber"])

    result_list = [
        {"name": key, "servicerefnumber": value} for key, value in grouped_data.items()
    ]

    result_list_final = []

    for branch_data in result_list:
        branch_name = branch_data["name"]
        service_numbers = []

        for i in branch_data["servicerefnumber"]:
            if (
                Service.objects.filter(servicerefnumber=i).first().status
                == "Delivered(Ok)"
            ):
                service_numbers.append(i)

        spare_cost = func_calculate_spare_cost(service_numbers, branch_name)

        result_list_final.append(
            {
                "name": branch_name,
                "servicerefnumber": service_numbers,
                "spare_cost": spare_cost,
            }
        )

    final_result = []
    spare_cost_dict = {
        entry["name"]: entry["spare_cost"] for entry in result_list_final
    }

    for entry in data_list:
        branch_name = entry["branch"]

        spare_cost = spare_cost_dict.get(branch_name, 0)
        entry["spare_cost"] = spare_cost
        final_result.append(entry)

    for entry in final_result:
        service_income = entry.get("service_income", 0)
        if not service_income:
            entry["service_income"] = 0
            service_income = 0
        spare_cost = entry.get("spare_cost", 0)
        net_service_income = service_income - spare_cost
        entry["net_service_income"] = net_service_income

    #########################################################################

    # -------------------------------------------------------------------
    branches_with_saleincome = Branch.objects.filter(
        (Q(branchtype="Own") | Q(branchtype="Franchise"))
        & Q(branch_sales__invoicedate=today)
    ).values("name", "branch_sales__amountrecieved")

    grouped_data_sales = defaultdict(list)
    for item in branches_with_saleincome:
        grouped_data_sales[item["name"]].append(item["branch_sales__amountrecieved"])

    result_list_saleincome = [
        {"name": key, "sale_income": value} for key, value in grouped_data_sales.items()
    ]
    # -------------------------------------------------------------------
    branches_with_saleid = Branch.objects.filter(
        (Q(branchtype="Own") | Q(branchtype="Franchise"))
        & Q(branch_sales__invoicedate=today)
    ).values("name", "branch_sales__saleid")

    grouped_data_sales = defaultdict(list)

    for item in branches_with_saleid:
        grouped_data_sales[item["name"]].append(item["branch_sales__saleid"])

    result_list_saleid = [
        {"name": key, "saleid": value} for key, value in grouped_data_sales.items()
    ]
    # -------------------------------------------------------------------

    out = calculate_unique_income(result_list_saleid, result_list_saleincome)

    for item in data_list:
        for inc in out:
            if "sale_income" not in inc.keys():
                inc["sale_income"]: 0
            if inc["name"] == item["branch"]:
                item["sale_income"] = inc["sale_income"]

    # ------------------------------------------------
    branches_with_salebarcode = Branch.objects.filter(
        (Q(branchtype="Own") | Q(branchtype="Franchise"))
        & Q(branch_sales__invoicedate=today)
    ).values("name", "branch_sales__invoicenumber")

    grouped_data_sales = defaultdict(list)

    for item in branches_with_salebarcode:
        grouped_data_sales[item["name"]].append(item["branch_sales__invoicenumber"])

    result_list_salebarcode = [
        {"name": key, "barcode": value} for key, value in grouped_data_sales.items()
    ]

    purchase_costs = calculate_purchase_cost(result_list_salebarcode)
    for item in data_list:
        for inc in purchase_costs:
            if "purchase_cost" not in inc.keys():
                inc["purchase_cost"]: 0
            if inc["name"] == item["branch"]:
                item["purchase_cost"] = inc["purchase_cost"]
                item["net_sales_income"] = item["sale_income"] - item["purchase_cost"]
    # ------------------------------------------------

    #########################################################################

    total = {
        "branch": "Total",
        "input": sum(item.get("input", 0) for item in data_list),
        "output_ok": sum(item.get("output_ok", 0) for item in data_list),
        "output_notok": sum(item.get("output_notok", 0) for item in data_list),
        "completed_waiting_dispatch": sum(
            item.get("completed_waiting_disalatch", 0) for item in data_list
        ),
        "pending_under_repair": sum(
            item.get("pending_under_repair", 0) for item in data_list
        ),
        "service_income": sum(
            (
                item.get("service_income", 0)
                if item.get("service_income") is not None
                else 0
            )
            for item in data_list
        ),
        "spare_cost": sum(
            item.get("spare_cost", 0) if item.get("spare_cost") is not None else 0
            for item in data_list
        ),
        "net_service_income": sum(
            (
                item.get("net_service_income", 0)
                if item.get("net_service_income") is not None
                else 0
            )
            for item in data_list
        ),
        "sale_income": sum(
            item.get("sale_income", 0) if item.get("sale_income") is not None else 0
            for item in data_list
        ),
        "purchase_cost": sum(
            item.get("purchase_cost", 0) if item.get("purchase_cost") is not None else 0
            for item in data_list
        ),
        "net_sales_income": sum(
            (
                item.get("net_sales_income", 0)
                if item.get("net_sales_income") is not None
                else 0
            )
            for item in data_list
        ),
    }
    data_list.append(total)

    if user.is_superuser:
        data_list_final = data_list
    else:
        data_list_final = [
            data for data in data_list if user.userprofile.branch.name == data["branch"]
        ]

    return data_list_final


@login_required
def index(request):

    # this is just for temporary
    if request.user.is_authenticated and not request.user.is_superuser:
        if request.user.userprofile.role == "Field Engineer":
            return HttpResponseRedirect("/customers")
        elif (
            request.user.userprofile.role == "TRC Front Desk"
            or request.user.userprofile.role == "TRC QC"
        ):
            return redirect("service")
        elif request.user.userprofile.role == "TRC Cleaning and Packing":
            return redirect("service")
        elif request.user.userprofile.role == "Sales Representative":
            logout(request)
            return redirect("index")

    username = request.user
    branch = username.userprofile.branch

    current_year = date.today().year
    current_month = date.today().month

    ############ PURCHASE #############

    if username.is_superuser:
        todays_purchase = (
            Purchase.objects.filter(invoicedate=date.today())
            .values("invoicedate")
            .annotate(totalbillingamount=Sum("totalbillingamount"))
        )

        month_purchase = (
            Purchase.objects.filter(
                Q(invoicedate__month=current_month) & Q(invoicedate__year=current_year)
            )
            .values("invoicedate__month")
            .annotate(totalbillingamount=Sum("totalbillingamount"))
        )

        year_purchase = (
            Purchase.objects.filter(invoicedate__year=current_year)
            .values("invoicedate__year")
            .annotate(totalbillingamount=Sum("totalbillingamount"))
        )
    else:
        todays_purchase = (
            BranchPurchase.objects.filter(
                Q(invoicedate=date.today()) & Q(branch=branch)
            )
            .values("invoicedate")
            .annotate(totalbillingamount=Sum("totalbillingamount"))
        )

        month_purchase = (
            BranchPurchase.objects.filter(
                Q(invoicedate__month=current_month)
                & Q(invoicedate__year=current_year)
                & Q(branch=branch)
            )
            .values("invoicedate__month")
            .annotate(totalbillingamount=Sum("totalbillingamount"))
        )

        year_purchase = (
            BranchPurchase.objects.filter(
                Q(invoicedate__year=current_year) & Q(branch=branch)
            )
            .values("invoicedate__year")
            .annotate(totalbillingamount=Sum("totalbillingamount"))
        )

    # today
    todays_total_purchase_amount = 0
    for i in todays_purchase:
        todays_total_purchase_amount += i["totalbillingamount"]

    # month
    month_total_purchase_amount = 0
    for i in month_purchase:

        month_total_purchase_amount += i["totalbillingamount"]

    # year
    year_total_purchase_amount = 0
    for i in year_purchase:
        year_total_purchase_amount += i["totalbillingamount"]

    ############ SALES #############

    if username.is_superuser:
        todays_sales = (
            Sale.objects.filter(invoicedate=date.today())
            .values("invoicedate")
            .annotate(totalbillingamount=Sum("totalbillingamount"))
        )
        month_sales = (
            Sale.objects.filter(
                Q(invoicedate__month=current_month) & Q(invoicedate__year=current_year)
            )
            .values("invoicedate__month")
            .annotate(totalbillingamount=Sum("totalbillingamount"))
        )

        year_sales = (
            Sale.objects.filter(invoicedate__year=current_year)
            .values("invoicedate__year")
            .annotate(totalbillingamount=Sum("totalbillingamount"))
        )
    else:
        todays_sales = (
            Sale.objects.filter(Q(invoicedate=date.today()) & Q(branch=branch))
            .values("invoicedate")
            .annotate(totalbillingamount=Sum("totalbillingamount"))
        )
        month_sales = (
            Sale.objects.filter(
                Q(invoicedate__month=current_month)
                & Q(invoicedate__year=current_year)
                & Q(branch=branch)
            )
            .values("invoicedate__month")
            .annotate(totalbillingamount=Sum("totalbillingamount"))
        )

        year_sales = (
            Sale.objects.filter(Q(invoicedate__year=current_year) & Q(branch=branch))
            .values("invoicedate__year")
            .annotate(totalbillingamount=Sum("totalbillingamount"))
        )

    # today
    todays_total_sales_amount = 0
    for i in todays_sales:
        todays_total_sales_amount += i["totalbillingamount"]

    # month
    month_total_sales_amount = 0
    for i in month_sales:

        month_total_sales_amount += i["totalbillingamount"]

    # year
    year_total_sales_amount = 0
    for i in year_sales:
        year_total_sales_amount += i["totalbillingamount"]

    ################## TODAY SERVICE #####################################

    service_status = {
        "Unacknowledged": 0,
        "InProgress": 0,
        "Completed": 0,
        "Rejected": 0,
        "SpareRequested": 0,
        "SpareAllocated": 0,
    }

    if username.is_superuser:
        service_obj = (
            Service.objects.filter(modifieddate=date.today())
            .values("status")
            .annotate(Count("status"))
        )
    elif (
        username.userprofile.role == "Branch Admin"
        or username.userprofile.role == "Franchise Admin"
    ):
        branch = username.userprofile.branch
        service_obj = (
            Service.objects.filter(Q(modifieddate=date.today()) & Q(branch=branch))
            .values("status")
            .annotate(Count("status"))
        )
    elif username.userprofile.role == "Technician":
        service_obj = (
            Service.objects.filter(
                Q(modifieddate=date.today()) & Q(technician=username)
            )
            .values("status")
            .annotate(Count("status"))
        )
    service_status = get_service_details(service_obj)

    all_branches = Branch.objects.filter(
        (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
    )
    all_technician = UserProfile.objects.filter(role="Technician")

    if (
        username.userprofile.role == "Branch Admin"
        or username.userprofile.role == "Franchise Admin"
    ):
        admin_branch = username.userprofile.branch
        all_technician = UserProfile.objects.filter(
            Q(role="Technician") & Q(branch=admin_branch)
        )

    ##################  dashboard table#####################################

    data_list = func_dashboard_table(request.user)
    #########################################################################
    ##################  dashboard table#####################################

    ####################### product price list ###################
    current_user = request.user
    if current_user.is_superuser:
        prod_list_obj = ProductPriceList.objects.all()
    else:
        prod_list_obj = ProductPriceList.objects.filter(
            branch=current_user.userprofile.branch
        )
    ####################### product price list ###################

    context = {
        "branch_data": data_list,
        "username": username,
        "branch": branch,
        "today_purchase": round(todays_total_purchase_amount, 2),
        "month_purchase": round(month_total_purchase_amount, 2),
        "year_purchase": round(year_total_purchase_amount, 2),
        "today_sales": round(todays_total_sales_amount, 2),
        "month_sales": round(month_total_sales_amount, 2),
        "year_sales": round(year_total_sales_amount, 2),
        "prod_list_obj": prod_list_obj,
        "user": request.user,
        "service_status": service_status,
        "all_branches": all_branches,
        "all_technician": all_technician,
    }

    return render(request, "index.html", context)


def dashboard_yearly_purchase(request):
    current_year = date.today().year
    current_month = date.today().month
    user = request.user

    if user.is_superuser:

        yearly_purchase_obj = Purchase.objects.filter(
            invoicedate__year=current_year
        ).order_by("-pk")

        purchaseid_set = set()
        yearly_purchase_obj = [
            purchase
            for purchase in yearly_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        year_total_purchase_amount = 0
        year_total_purchase_amount_paid = 0
        year_total_purchase_amount_due = 0
        for i in yearly_purchase_obj:
            year_total_purchase_amount += i.totalbillingamount
            year_total_purchase_amount_paid += i.amountrecieved
            year_total_purchase_amount_due += i.duebalance

        all_years = list(Purchase.objects.values("invoicedate__year").distinct())
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    else:
        branch = user.userprofile.branch
        yearly_purchase_obj = BranchPurchase.objects.filter(
            Q(invoicedate__year=current_year) & Q(branch=branch)
        ).order_by("-pk")

        purchaseid_set = set()
        yearly_purchase_obj = [
            purchase
            for purchase in yearly_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        year_total_purchase_amount = 0
        year_total_purchase_amount_paid = 0
        year_total_purchase_amount_due = 0
        for i in yearly_purchase_obj:
            year_total_purchase_amount += i.totalbillingamount
            year_total_purchase_amount_paid += i.amountrecieved
            year_total_purchase_amount_due += i.duebalance

        all_years = list(
            BranchPurchase.objects.filter(
                Q(invoicedate__year=current_year) & Q(branch=branch)
            )
            .values("invoicedate__year")
            .distinct()
        )
        # all_branches = Branch.objects.all()
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    context = {
        "year_purchase": yearly_purchase_obj,
        "year_purchase_total": year_total_purchase_amount,
        "year_purchase_paid": year_total_purchase_amount_paid,
        "year_purchase_duebalance": year_total_purchase_amount_due,
        "current_year": {"year": date.today().year},
        "all_years": all_years,
        "all_branches": all_branches,
        "selected_branch": user.userprofile.branch,
    }
    return render(request, "dashboardyearlypurchase.html", context)


def search_yearly_purchase(request, page):

    try:
        year = request.POST["year"]
    except:
        year = None
    try:
        branch = request.POST["branch"]
    except:
        branch = None

    current_year = date.today().year

    user = request.user

    if year and branch:
        branch = Branch.objects.filter(id=int(branch)).first()
        if branch.name == "WAREHOUSE":
            year = int(year)

            yearly_purchase_obj = Purchase.objects.filter(
                invoicedate__year=year
            ).order_by("-pk")

            purchaseid_set = set()
            yearly_purchase_obj = [
                purchase
                for purchase in yearly_purchase_obj
                if (
                    purchase.purchaseid not in purchaseid_set
                    and not purchaseid_set.add(purchase.purchaseid)
                )
            ]

            year_total_purchase_amount = 0
            year_total_purchase_amount_paid = 0
            year_total_purchase_amount_due = 0

            for i in yearly_purchase_obj:
                year_total_purchase_amount_paid += i.amountrecieved
                year_total_purchase_amount += i.totalbillingamount
                year_total_purchase_amount_due += i.duebalance

            all_years = list(Purchase.objects.values("invoicedate__year").distinct())
            # all_branches = Branch.objects.all()
            all_branches = Branch.objects.filter(
                (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
            )
        elif branch.name != "WAREHOUSE":

            # elif year and branch and branch.name!="WAREHOUSE":
            year = int(year)

            yearly_purchase_obj = BranchPurchase.objects.filter(
                Q(invoicedate__year=year) & Q(branch=branch)
            ).order_by("-pk")

            purchaseid_set = set()
            yearly_purchase_obj = [
                purchase
                for purchase in yearly_purchase_obj
                if (
                    purchase.purchaseid not in purchaseid_set
                    and not purchaseid_set.add(purchase.purchaseid)
                )
            ]

            year_total_purchase_amount = 0
            year_total_purchase_amount_paid = 0
            year_total_purchase_amount_due = 0

            for i in yearly_purchase_obj:
                year_total_purchase_amount_paid += i.amountrecieved
                year_total_purchase_amount += i.totalbillingamount
                year_total_purchase_amount_due += i.duebalance

            all_years = list(
                BranchPurchase.objects.filter(branch=branch)
                .values("invoicedate__year")
                .distinct()
            )
            # all_branches = Branch.objects.all()
            all_branches = Branch.objects.filter(
                (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
            )
    elif year:

        year = int(year)
        branch = user.userprofile.branch
        yearly_purchase_obj = BranchPurchase.objects.filter(
            Q(invoicedate__year=year) & Q(branch=branch)
        ).order_by("-pk")

        purchaseid_set = set()
        yearly_purchase_obj = [
            purchase
            for purchase in yearly_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        year_total_purchase_amount = 0
        year_total_purchase_amount_paid = 0
        year_total_purchase_amount_due = 0

        for i in yearly_purchase_obj:
            year_total_purchase_amount_paid += i.amountrecieved
            year_total_purchase_amount += i.totalbillingamount
            year_total_purchase_amount_due += i.duebalance

        all_years = list(
            BranchPurchase.objects.filter(branch=branch)
            .values("invoicedate__year")
            .distinct()
        )
        # all_branches = Branch.objects.all()
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    elif branch:
        year = current_year

        yearly_purchase_obj = BranchPurchase.objects.filter(
            Q(invoicedate__year=year) & Q(branch=branch)
        ).order_by("-pk")

        purchaseid_set = set()
        yearly_purchase_obj = [
            purchase
            for purchase in yearly_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        year_total_purchase_amount = 0
        year_total_purchase_amount_paid = 0
        year_total_purchase_amount_due = 0

        for i in yearly_purchase_obj:
            year_total_purchase_amount_paid += i.amountrecieved
            year_total_purchase_amount += i.totalbillingamount
            year_total_purchase_amount_due += i.duebalance

        all_years = list(
            BranchPurchase.objects.filter(branch=branch)
            .values("invoicedate__year")
            .distinct()
        )
        # all_branches = Branch.objects.all()
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    context = {
        "year_purchase": yearly_purchase_obj,
        "year_purchase_total": year_total_purchase_amount,
        "year_purchase_paid": year_total_purchase_amount_paid,
        "year_purchase_duebalance": year_total_purchase_amount_due,
        "current_year": {"year": year},
        "all_years": all_years,
        "all_branches": all_branches,
        "selected_branch": branch,
    }

    if page == "dashboard":
        template_file = "dashboardyearlypurchase.html"
    elif page == "reports":
        template_file = "reportsyearlypurchase.html"

    return render(request, template_file, context)


def dashboard_monthly_purchase(request):
    current_year = date.today().year
    current_month = date.today().month
    user = request.user

    if user.is_superuser:

        monthly_purchase_obj = Purchase.objects.filter(
            Q(invoicedate__year=current_year) & Q(invoicedate__month=current_month)
        ).order_by("-pk")

        purchaseid_set = set()
        monthly_purchase_obj = [
            purchase
            for purchase in monthly_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        month_total_purchase_amount = 0
        month_total_purchase_amount_paid = 0
        month_total_purchase_amount_due = 0
        for i in monthly_purchase_obj:
            month_total_purchase_amount += i.totalbillingamount
            month_total_purchase_amount_paid += i.amountrecieved
            month_total_purchase_amount_due += i.duebalance

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    else:
        branch = user.userprofile.branch
        monthly_purchase_obj = BranchPurchase.objects.filter(
            Q(invoicedate__year=current_year)
            & Q(invoicedate__month=current_month)
            & Q(branch=branch)
        ).order_by("-pk")

        purchaseid_set = set()
        monthly_purchase_obj = [
            purchase
            for purchase in monthly_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        month_total_purchase_amount = 0
        month_total_purchase_amount_paid = 0
        month_total_purchase_amount_due = 0
        for i in monthly_purchase_obj:
            month_total_purchase_amount += i.totalbillingamount
            month_total_purchase_amount_paid += i.amountrecieved
            month_total_purchase_amount_due += i.duebalance

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    month_dict = {
        "1": "January",
        "2": "February",
        "3": "March",
        "4": "April",
        "5": "May",
        "6": "June",
        "7": "July",
        "8": "August",
        "9": "September",
        "10": "October",
        "11": "November",
        "12": "December",
    }

    context = {
        "monthly_purchase": monthly_purchase_obj,
        "month_purchase_total": month_total_purchase_amount,
        "month_purchase_paid": month_total_purchase_amount_paid,
        "month_purchase_duebalance": month_total_purchase_amount_due,
        "selected_month": {
            "month": date.today().month,
            "month_str": month_dict[str(date.today().month)],
        },
        "all_branches": all_branches,
        "selected_branch": user.userprofile.branch,
    }
    return render(request, "dashboardmonthlypurchase.html", context)


def search_monthly_purchase(request, page):

    try:
        month = int(request.POST["month"])
    except:
        month = None
    try:
        branch = request.POST["branch"]
        branch = Branch.objects.filter(id=int(branch)).first()
    except:
        branch = None

    current_month = date.today().month
    current_year = date.today().year

    user = request.user

    if month and branch and branch.name == "WAREHOUSE":

        monthly_purchase_obj = Purchase.objects.filter(
            Q(invoicedate__year=current_year) & Q(invoicedate__month=month)
        ).order_by("-pk")

        purchaseid_set = set()
        monthly_purchase_obj = [
            purchase
            for purchase in monthly_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        month_total_purchase_amount = 0
        month_total_purchase_amount_paid = 0
        month_total_purchase_amount_due = 0
        for i in monthly_purchase_obj:
            month_total_purchase_amount += i.totalbillingamount
            month_total_purchase_amount_paid += i.amountrecieved
            month_total_purchase_amount_due += i.duebalance
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    elif month and branch and branch.name != "WAREHOUSE":

        monthly_purchase_obj = BranchPurchase.objects.filter(
            Q(invoicedate__year=current_year)
            & Q(invoicedate__month=month)
            & Q(branch=branch)
        ).order_by("-pk")

        purchaseid_set = set()
        monthly_purchase_obj = [
            purchase
            for purchase in monthly_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        month_total_purchase_amount = 0
        month_total_purchase_amount_paid = 0
        month_total_purchase_amount_due = 0
        for i in monthly_purchase_obj:
            month_total_purchase_amount += i.totalbillingamount
            month_total_purchase_amount_paid += i.amountrecieved
            month_total_purchase_amount_due += i.duebalance

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    elif month:

        # year=int(year)
        branch = user.userprofile.branch
        monthly_purchase_obj = BranchPurchase.objects.filter(
            Q(invoicedate__year=current_year)
            & Q(invoicedate__month=month)
            & Q(branch=branch)
        ).order_by("-pk")

        purchaseid_set = set()
        monthly_purchase_obj = [
            purchase
            for purchase in monthly_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        month_total_purchase_amount = 0
        month_total_purchase_amount_paid = 0
        month_total_purchase_amount_due = 0
        for i in monthly_purchase_obj:
            month_total_purchase_amount += i.totalbillingamount
            month_total_purchase_amount_paid += i.amountrecieved
            month_total_purchase_amount_due += i.duebalance
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    month_dict = {
        "1": "January",
        "2": "February",
        "3": "March",
        "4": "April",
        "5": "May",
        "6": "June",
        "7": "July",
        "8": "August",
        "9": "September",
        "10": "October",
        "11": "November",
        "12": "December",
    }

    # purchaseid_set = set()
    # monthly_purchase_obj = [purchase for purchase in monthly_purchase_obj if (purchase.purchaseid not in purchaseid_set and not purchaseid_set.add(purchase.purchaseid))]

    context = {
        "monthly_purchase": monthly_purchase_obj,
        "month_purchase_total": month_total_purchase_amount,
        "month_purchase_paid": month_total_purchase_amount_paid,
        "month_purchase_duebalance": month_total_purchase_amount_due,
        "selected_month": {"month": month, "month_str": month_dict[str(month)]},
        "all_branches": all_branches,
        "selected_branch": branch,
    }

    if page == "dashboard":
        template_file = "dashboardmonthlypurchase.html"
    elif page == "reports":
        template_file = "reportsmonthlypurchase.html"

    return render(request, template_file, context)


def dashboard_daily_purchase(request):
    current_year = date.today().year
    current_date = date.today()
    user = request.user

    if user.is_superuser:

        daily_purchase_obj = Purchase.objects.filter(invoicedate=current_date).order_by(
            "-pk"
        )

        purchaseid_set = set()
        daily_purchase_obj = [
            purchase
            for purchase in daily_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        day_total_purchase_amount = 0
        day_total_purchase_amount_paid = 0
        day_total_purchase_amount_due = 0
        for i in daily_purchase_obj:
            day_total_purchase_amount += i.totalbillingamount
            day_total_purchase_amount_due += i.duebalance
            day_total_purchase_amount_paid += i.amountrecieved

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    else:
        branch = user.userprofile.branch
        daily_purchase_obj = BranchPurchase.objects.filter(
            Q(invoicedate=current_date) & Q(branch=branch)
        ).order_by("-pk")

        purchaseid_set = set()
        daily_purchase_obj = [
            purchase
            for purchase in daily_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        day_total_purchase_amount = 0
        day_total_purchase_amount_paid = 0
        day_total_purchase_amount_due = 0
        for i in daily_purchase_obj:
            day_total_purchase_amount += i.totalbillingamount
            day_total_purchase_amount_due += i.duebalance
            day_total_purchase_amount_paid += i.amountrecieved

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    context = {
        "daily_purchase": daily_purchase_obj,
        "day_purchase_total": day_total_purchase_amount,
        "day_purchase_paid": day_total_purchase_amount_paid,
        "day_purchase_duebalance": day_total_purchase_amount_due,
        "selected_date": {"date": date.today()},
        "all_branches": all_branches,
        "selected_branch": user.userprofile.branch,
    }
    return render(request, "dashboarddailypurchase.html", context)


def search_daily_purchase(request, page):

    try:
        date = request.POST["date"]
    except:
        date = None
    try:
        branch = request.POST["branch"]
        branch = Branch.objects.filter(id=int(branch)).first()
    except:
        branch = None

    if date:
        date_format = "%d-%m-%Y"
        date = datetime.strptime(date, date_format)

    user = request.user

    if date and branch and branch.name == "WAREHOUSE":

        daily_purchase_obj = Purchase.objects.filter(invoicedate=date).order_by("-pk")

        purchaseid_set = set()
        daily_purchase_obj = [
            purchase
            for purchase in daily_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        day_total_purchase_amount = 0
        day_total_purchase_amount_paid = 0
        day_total_purchase_amount_due = 0
        for i in daily_purchase_obj:
            day_total_purchase_amount += i.totalbillingamount
            day_total_purchase_amount_paid += i.amountrecieved
            day_total_purchase_amount_due += i.duebalance

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    elif date and branch and branch.name != "WAREHOUSE":
        daily_purchase_obj = BranchPurchase.objects.filter(
            Q(invoicedate=date) & Q(branch=branch)
        ).order_by("-pk")
        purchaseid_set = set()
        daily_purchase_obj = [
            purchase
            for purchase in daily_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        day_total_purchase_amount = 0
        day_total_purchase_amount_paid = 0
        day_total_purchase_amount_due = 0
        for i in daily_purchase_obj:
            day_total_purchase_amount += i.totalbillingamount
            day_total_purchase_amount_paid += i.amountrecieved
            day_total_purchase_amount_due += i.duebalance
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    elif date:

        # year=int(year)
        branch = user.userprofile.branch
        daily_purchase_obj = BranchPurchase.objects.filter(
            Q(invoicedate=date) & Q(branch=branch)
        ).order_by("-pk")

        purchaseid_set = set()
        daily_purchase_obj = [
            purchase
            for purchase in daily_purchase_obj
            if (
                purchase.purchaseid not in purchaseid_set
                and not purchaseid_set.add(purchase.purchaseid)
            )
        ]

        day_total_purchase_amount = 0
        day_total_purchase_amount_paid = 0
        day_total_purchase_amount_due = 0
        for i in daily_purchase_obj:
            day_total_purchase_amount += i.totalbillingamount
            day_total_purchase_amount_paid += i.amountrecieved
            day_total_purchase_amount_due += i.duebalance
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    context = {
        "daily_purchase": daily_purchase_obj,
        "day_purchase_total": day_total_purchase_amount,
        "day_purchase_paid": day_total_purchase_amount_paid,
        "day_purchase_duebalance": day_total_purchase_amount_due,
        "selected_date": {"date": date},
        "all_branches": all_branches,
        "selected_branch": branch,
    }

    if page == "dashboard":
        template_file = "dashboarddailypurchase.html"
    elif page == "reports":
        template_file = "reportsdailypurchase.html"

    return render(request, template_file, context)


# sales


def dashboard_yearly_sales(request):
    current_year = date.today().year
    current_month = date.today().month
    user = request.user

    if user.is_superuser:
        current_branch = user.userprofile.branch
        yearly_sales_obj = Sale.objects.filter(
            Q(invoicedate__year=current_year) & Q(branch=current_branch)
        ).order_by("-pk")

        saleid_set = set()
        yearly_sales_obj = [
            sale
            for sale in yearly_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        year_total_sales_amount = 0
        year_total_sales_amount_recieved = 0
        year_total_sales_amount_due = 0
        for i in yearly_sales_obj:
            year_total_sales_amount += i.totalbillingamount
            year_total_sales_amount_recieved += i.amountrecieved
            year_total_sales_amount_due += i.duebalance

        all_years = list(Sale.objects.values("invoicedate__year").distinct())
        # all_branches = Branch.objects.all()
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    else:
        branch = user.userprofile.branch
        yearly_sales_obj = Sale.objects.filter(
            Q(invoicedate__year=current_year) & Q(branch=branch)
        ).order_by("-pk")

        saleid_set = set()
        yearly_sales_obj = [
            sale
            for sale in yearly_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        year_total_sales_amount = 0
        year_total_sales_amount_recieved = 0
        year_total_sales_amount_due = 0
        for i in yearly_sales_obj:
            year_total_sales_amount += i.totalbillingamount
            year_total_sales_amount_recieved += i.amountrecieved
            year_total_sales_amount_due += i.duebalance

        all_years = list(
            Sale.objects.filter(Q(invoicedate__year=current_year) & Q(branch=branch))
            .values("invoicedate__year")
            .distinct()
        )
        # all_branches = Branch.objects.all()
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    context = {
        "year_sales": yearly_sales_obj,
        "year_sales_total": year_total_sales_amount,
        "year_sales_recieved": year_total_sales_amount_recieved,
        "year_sales_duebalance": year_total_sales_amount_due,
        "current_year": {"year": date.today().year},
        "all_years": all_years,
        "all_branches": all_branches,
        "selected_branch": user.userprofile.branch,
    }
    return render(request, "dashboardyearlysales.html", context)


def search_yearly_sales(request, page):

    try:
        year = request.POST["year"]
    except:
        year = None
    try:
        branch = request.POST["branch"]
        branch = Branch.objects.filter(id=int(branch)).first()
    except:
        branch = None

    current_year = date.today().year

    user = request.user

    if year and branch and branch.name == "WAREHOUSE":
        year = int(year)
        current_branch = user.userprofile.branch
        yearly_sales_obj = Sale.objects.filter(
            Q(invoicedate__year=current_year) & Q(branch=current_branch)
        ).order_by("-pk")

        saleid_set = set()
        yearly_sales_obj = [
            sale
            for sale in yearly_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        year_total_sales_amount = 0
        year_total_sales_amount_recieved = 0
        year_total_sales_amount_due = 0
        for i in yearly_sales_obj:
            year_total_sales_amount += i.totalbillingamount
            year_total_sales_amount_recieved += i.amountrecieved
            year_total_sales_amount_due += i.duebalance

        all_years = list(Sale.objects.values("invoicedate__year").distinct())
        # all_branches = Branch.objects.all()
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    elif year and branch and branch.name != "WAREHOUSE":
        year = int(year)

        yearly_sales_obj = Sale.objects.filter(
            Q(invoicedate__year=year) & Q(branch=branch)
        ).order_by("-pk")

        saleid_set = set()
        yearly_sales_obj = [
            sale
            for sale in yearly_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        year_total_sales_amount = 0
        year_total_sales_amount_recieved = 0
        year_total_sales_amount_due = 0
        for i in yearly_sales_obj:
            year_total_sales_amount += i.totalbillingamount
            year_total_sales_amount_recieved += i.amountrecieved
            year_total_sales_amount_due += i.duebalance

        all_years = list(
            Sale.objects.filter(branch=branch).values("invoicedate__year").distinct()
        )
        # all_branches = Branch.objects.all()
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    elif year:

        year = int(year)
        branch = user.userprofile.branch
        yearly_sales_obj = Sale.objects.filter(
            Q(invoicedate__year=year) & Q(branch=branch)
        ).order_by("-pk")

        saleid_set = set()
        yearly_sales_obj = [
            sale
            for sale in yearly_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        year_total_sales_amount = 0
        year_total_sales_amount_recieved = 0
        year_total_sales_amount_due = 0
        for i in yearly_sales_obj:
            year_total_sales_amount += i.totalbillingamount
            year_total_sales_amount_recieved += i.amountrecieved
            year_total_sales_amount_due += i.duebalance

        all_years = list(
            Sale.objects.filter(branch=branch).values("invoicedate__year").distinct()
        )
        # all_branches = Branch.objects.all()
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    elif branch:
        year = current_year

        yearly_sales_obj = Sale.objects.filter(
            Q(invoicedate__year=year) & Q(branch=branch)
        ).order_by("-pk")

        saleid_set = set()
        yearly_sales_obj = [
            sale
            for sale in yearly_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        year_total_sales_amount = 0
        year_total_sales_amount_recieved = 0
        year_total_sales_amount_due = 0
        for i in yearly_sales_obj:
            year_total_sales_amount += i.totalbillingamount
            year_total_sales_amount_recieved += i.amountrecieved
            year_total_sales_amount_due += i.duebalance

        all_years = list(
            Sale.objects.filter(branch=branch).values("invoicedate__year").distinct()
        )
        # all_branches = Branch.objects.all()
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    context = {
        "year_sales": yearly_sales_obj,
        "year_sales_total": year_total_sales_amount,
        "year_sales_recieved": year_total_sales_amount_recieved,
        "year_sales_duebalance": year_total_sales_amount_due,
        "current_year": {"year": year},
        "all_years": all_years,
        "all_branches": all_branches,
        "selected_branch": user.userprofile.branch,
    }

    if page == "dashboard":
        template_file = "dashboardyearlysales.html"
    elif page == "reports":
        template_file = "reportsyearlysales.html"

    return render(request, template_file, context)


def dashboard_monthly_sales(request):
    current_year = date.today().year
    current_month = date.today().month
    user = request.user

    if user.is_superuser:
        current_branch = user.userprofile.branch
        monthly_sales_obj = Sale.objects.filter(
            Q(invoicedate__year=current_year)
            & Q(invoicedate__month=current_month)
            & Q(branch=current_branch)
        ).order_by("-pk")

        saleid_set = set()
        monthly_sales_obj = [
            sale
            for sale in monthly_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        month_total_sales_amount = 0
        month_total_sales_amount_recieved = 0
        month_total_sales_amount_due = 0
        for i in monthly_sales_obj:
            month_total_sales_amount += i.totalbillingamount
            month_total_sales_amount_recieved += i.amountrecieved
            month_total_sales_amount_due += i.duebalance

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    else:
        branch = user.userprofile.branch
        monthly_sales_obj = Sale.objects.filter(
            Q(invoicedate__year=current_year)
            & Q(invoicedate__month=current_month)
            & Q(branch=branch)
        ).order_by("-pk")

        saleid_set = set()
        monthly_sales_obj = [
            sale
            for sale in monthly_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        month_total_sales_amount = 0
        month_total_sales_amount_recieved = 0
        month_total_sales_amount_due = 0
        for i in monthly_sales_obj:
            month_total_sales_amount += i.totalbillingamount
            month_total_sales_amount_recieved += i.amountrecieved
            month_total_sales_amount_due += i.duebalance
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    month_dict = {
        "1": "January",
        "2": "February",
        "3": "March",
        "4": "April",
        "5": "May",
        "6": "June",
        "7": "July",
        "8": "August",
        "9": "September",
        "10": "October",
        "11": "November",
        "12": "December",
    }

    context = {
        "monthly_sales": monthly_sales_obj,
        "month_sales_total": month_total_sales_amount,
        "month_sales_recieved": month_total_sales_amount_recieved,
        "month_sales_duebalance": month_total_sales_amount_due,
        "selected_month": {
            "month": date.today().month,
            "month_str": month_dict[str(date.today().month)],
        },
        "all_branches": all_branches,
        "selected_branch": user.userprofile.branch,
    }
    return render(request, "dashboardmonthlysales.html", context)


def search_monthly_sales(request, page):

    try:
        month = int(request.POST["month"])
    except:
        month = None
    try:
        branch = request.POST["branch"]
        branch = Branch.objects.filter(id=int(branch)).first()
    except:
        branch = None

    current_month = date.today().month
    current_year = date.today().year

    user = request.user

    if month and branch and branch.name == "WAREHOUSE":

        current_branch = user.userprofile.branch
        monthly_sales_obj = Sale.objects.filter(
            Q(invoicedate__year=current_year)
            & Q(invoicedate__month=month)
            & Q(branch=current_branch)
        ).order_by("-pk")

        saleid_set = set()
        monthly_sales_obj = [
            sale
            for sale in monthly_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        month_total_sales_amount = 0
        month_total_sales_amount_recieved = 0
        month_total_sales_amount_due = 0
        for i in monthly_sales_obj:
            month_total_sales_amount += i.totalbillingamount
            month_total_sales_amount_recieved += i.amountrecieved
            month_total_sales_amount_due += i.duebalance
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    elif month and branch and branch.name != "WAREHOUSE":

        monthly_sales_obj = Sale.objects.filter(
            Q(invoicedate__year=current_year)
            & Q(invoicedate__month=month)
            & Q(branch=branch)
        ).order_by("-pk")

        saleid_set = set()
        monthly_sales_obj = [
            sale
            for sale in monthly_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        month_total_sales_amount = 0
        month_total_sales_amount_recieved = 0
        month_total_sales_amount_due = 0
        for i in monthly_sales_obj:
            month_total_sales_amount += i.totalbillingamount
            month_total_sales_amount_recieved += i.amountrecieved
            month_total_sales_amount_due += i.duebalance
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    elif month:

        # year=int(year)
        branch = user.userprofile.branch
        monthly_sales_obj = Sale.objects.filter(
            Q(invoicedate__year=current_year)
            & Q(invoicedate__month=month)
            & Q(branch=branch)
        ).order_by("-pk")

        saleid_set = set()
        monthly_sales_obj = [
            sale
            for sale in monthly_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        month_total_sales_amount = 0
        month_total_sales_amount_recieved = 0
        month_total_sales_amount_due = 0
        for i in monthly_sales_obj:
            month_total_sales_amount += i.totalbillingamount
            month_total_sales_amount_recieved += i.amountrecieved
            month_total_sales_amount_due += i.duebalance
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    month_dict = {
        "1": "January",
        "2": "February",
        "3": "March",
        "4": "April",
        "5": "May",
        "6": "June",
        "7": "July",
        "8": "August",
        "9": "September",
        "10": "October",
        "11": "November",
        "12": "December",
    }

    context = {
        "monthly_sales": monthly_sales_obj,
        "month_sales_total": month_total_sales_amount,
        "month_sales_recieved": month_total_sales_amount_recieved,
        "month_sales_duebalance": month_total_sales_amount_due,
        "selected_month": {"month": month, "month_str": month_dict[str(month)]},
        "all_branches": all_branches,
        "selected_branch": branch,
    }

    if page == "dashboard":
        template_file = "dashboardmonthlysales.html"
    elif page == "reports":
        template_file = "reportsmonthlysales.html"

    return render(request, template_file, context)


def dashboard_daily_sales(request):
    current_year = date.today().year
    current_date = date.today()
    user = request.user

    if user.is_superuser:

        daily_sales_obj = Sale.objects.filter(invoicedate=current_date).order_by("-pk")

        saleid_set = set()
        daily_sales_obj = [
            sale
            for sale in daily_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        day_total_sales_amount = 0
        day_total_sales_amount_recieved = 0
        day_total_sales_amount_due = 0
        for i in daily_sales_obj:
            day_total_sales_amount += i.totalbillingamount
            day_total_sales_amount_due += i.duebalance
            day_total_sales_amount_recieved += i.amountrecieved

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    else:
        branch = user.userprofile.branch
        daily_sales_obj = Sale.objects.filter(
            Q(invoicedate=current_date) & Q(branch=branch)
        ).order_by("-pk")

        saleid_set = set()
        daily_sales_obj = [
            sale
            for sale in daily_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        day_total_sales_amount = 0
        day_total_sales_amount_recieved = 0
        day_total_sales_amount_due = 0
        for i in daily_sales_obj:
            day_total_sales_amount += i.totalbillingamount
            day_total_sales_amount_due += i.duebalance
            day_total_sales_amount_recieved += i.amountrecieved
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    context = {
        "daily_sales": daily_sales_obj,
        "day_sales_total": day_total_sales_amount,
        "day_sales_recieved": day_total_sales_amount_recieved,
        "day_sales_duebalance": day_total_sales_amount_due,
        "selected_date": {"date": date.today()},
        "all_branches": all_branches,
        "selected_branch": user.userprofile.branch,
    }
    return render(request, "dashboarddailysales.html", context)


def search_daily_sales(request, page):

    try:
        date = request.POST["date"]
    except:
        date = None
    try:
        branch = request.POST["branch"]
        branch = Branch.objects.filter(id=int(branch)).first()
    except:
        branch = None

    if date:
        date_format = "%d-%m-%Y"
        date = datetime.strptime(date, date_format)

    user = request.user

    if date and branch and branch.name == "WAREHOUSE":

        daily_sales_obj = Sale.objects.filter(invoicedate=date).order_by("-pk")

        saleid_set = set()
        daily_sales_obj = [
            sale
            for sale in daily_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        day_total_sales_amount = 0
        day_total_sales_amount_recieved = 0
        day_total_sales_amount_due = 0
        for i in daily_sales_obj:
            day_total_sales_amount += i.totalbillingamount
            day_total_sales_amount_recieved += i.amountrecieved
            day_total_sales_amount_due += i.duebalance
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    elif date and branch and branch.name != "WAREHOUSE":

        daily_sales_obj = Sale.objects.filter(
            Q(invoicedate=date) & Q(branch=branch)
        ).order_by("-pk")

        saleid_set = set()
        daily_sales_obj = [
            sale
            for sale in daily_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        day_total_sales_amount = 0
        day_total_sales_amount_recieved = 0
        day_total_sales_amount_due = 0
        for i in daily_sales_obj:
            day_total_sales_amount += i.totalbillingamount
            day_total_sales_amount_recieved += i.amountrecieved
            day_total_sales_amount_due += i.duebalance
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )
    elif date:

        # year=int(year)
        branch = user.userprofile.branch
        daily_sales_obj = Sale.objects.filter(
            Q(invoicedate=date) & Q(branch=branch)
        ).order_by("-pk")

        saleid_set = set()
        daily_sales_obj = [
            sale
            for sale in daily_sales_obj
            if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
        ]

        day_total_sales_amount = 0
        day_total_sales_amount_recieved = 0
        day_total_sales_amount_due = 0
        for i in daily_sales_obj:
            day_total_sales_amount += i.totalbillingamount
            day_total_sales_amount_recieved += i.amountrecieved
            day_total_sales_amount_due += i.duebalance
        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
        )

    context = {
        "daily_sales": daily_sales_obj,
        "day_sales_total": day_total_sales_amount,
        "day_sales_recieved": day_total_sales_amount_recieved,
        "day_sales_duebalance": day_total_sales_amount_due,
        "selected_date": {"date": date},
        "all_branches": all_branches,
        "selected_branch": branch,
    }

    if page == "dashboard":
        template_file = "dashboarddailysales.html"
    elif page == "reports":
        template_file = "reportsdailysales.html"

    return render(request, template_file, context)


#  service in dashboard


def get_service_status(request):

    received_data = QueryDict(request.body)
    date_selected = received_data.get("date")
    branch_selected = received_data.get("branch")
    technician_selected = received_data.get("technician")
    currentuser = request.user
    if date_selected and branch_selected and technician_selected:
        if branch_selected == "allbranches" and technician_selected == "alltechnician":
            if date_selected == "today":
                service_obj = (
                    Service.objects.filter(modifieddate=date.today())
                    .values("status")
                    .annotate(Count("status"))
                )
            elif date_selected == "month":
                service_obj = (
                    Service.objects.filter(
                        Q(modifieddate__month=date.today().month)
                        & Q(modifieddate__year=date.today().year)
                    )
                    .values("status")
                    .annotate(Count("status"))
                )
            elif date_selected == "year":
                service_obj = (
                    Service.objects.filter(modifieddate__year=date.today().year)
                    .values("status")
                    .annotate(Count("status"))
                )
            service_status = get_service_details(service_obj)
        elif branch_selected == "allbranches":
            technician = User.objects.filter(username=technician_selected).first()
            if date_selected == "today":
                service_obj = (
                    Service.objects.filter(
                        Q(modifieddate=date.today()) & Q(technician=technician)
                    )
                    .values("status")
                    .annotate(Count("status"))
                )
            elif date_selected == "month":
                service_obj = (
                    Service.objects.filter(
                        Q(modifieddate__month=date.today().month)
                        & Q(modifieddate__year=date.today().year)
                        & Q(technician=technician)
                    )
                    .values("status")
                    .annotate(Count("status"))
                )
            elif date_selected == "year":
                service_obj = (
                    Service.objects.filter(
                        Q(modifieddate__year=date.today().year)
                        & Q(technician=technician)
                    )
                    .values("status")
                    .annotate(Count("status"))
                )
            service_status = get_service_details(service_obj)
        elif technician_selected == "alltechnician":
            branch = Branch.objects.filter(name=branch_selected).first()
            if date_selected == "today":
                service_obj = (
                    Service.objects.filter(
                        Q(modifieddate=date.today()) & Q(branch=branch)
                    )
                    .values("status")
                    .annotate(Count("status"))
                )
            elif date_selected == "month":
                service_obj = (
                    Service.objects.filter(
                        Q(modifieddate__month=date.today().month)
                        & Q(modifieddate__year=date.today().year)
                        & Q(branch=branch)
                    )
                    .values("status")
                    .annotate(Count("status"))
                )
            elif date_selected == "year":
                service_obj = (
                    Service.objects.filter(
                        Q(modifieddate__year=date.today().year) & Q(branch=branch)
                    )
                    .values("status")
                    .annotate(Count("status"))
                )
            service_status = get_service_details(service_obj)
        else:
            technician = User.objects.filter(username=technician_selected).first()
            branch = Branch.objects.filter(name=branch_selected).first()
            if date_selected == "today":
                service_obj = (
                    Service.objects.filter(
                        Q(modifieddate=date.today())
                        & Q(branch=branch)
                        & Q(technician=technician)
                    )
                    .values("status")
                    .annotate(Count("status"))
                )
            elif date_selected == "month":
                service_obj = (
                    Service.objects.filter(
                        Q(modifieddate__month=date.today().month)
                        & Q(modifieddate__year=date.today().year)
                        & Q(branch=branch)
                        & Q(technician=technician)
                    )
                    .values("status")
                    .annotate(Count("status"))
                )
            elif date_selected == "year":
                service_obj = (
                    Service.objects.filter(
                        Q(modifieddate__year=date.today().year)
                        & Q(branch=branch)
                        & Q(technician=technician)
                    )
                    .values("status")
                    .annotate(Count("status"))
                )
            service_status = get_service_details(service_obj)
    elif date_selected and technician_selected:
        if technician_selected == "alltechnician":
            if date_selected == "today":
                service_obj = (
                    Service.objects.filter(
                        Q(modifieddate=date.today())
                        & Q(branch=currentuser.userprofile.branch)
                    )
                    .values("status")
                    .annotate(Count("status"))
                )
            elif date_selected == "month":
                service_obj = (
                    Service.objects.filter(
                        Q(modifieddate__month=date.today().month)
                        & Q(modifieddate__year=date.today().year)
                        & Q(branch=currentuser.userprofile.branch)
                    )
                    .values("status")
                    .annotate(Count("status"))
                )
            elif date_selected == "year":
                service_obj = (
                    Service.objects.filter(
                        Q(modifieddate__year=date.today().year)
                        & Q(branch=currentuser.userprofile.branch)
                    )
                    .values("status")
                    .annotate(Count("status"))
                )
            service_status = get_service_details(service_obj)
        else:
            technician = User.objects.filter(username=technician_selected).first()
            if date_selected == "today":
                service_obj = (
                    Service.objects.filter(
                        Q(modifieddate=date.today())
                        & Q(technician=technician)
                        & Q(branch=currentuser.userprofile.branch)
                    )
                    .values("status")
                    .annotate(Count("status"))
                )
            elif date_selected == "month":
                service_obj = (
                    Service.objects.filter(
                        Q(modifieddate__month=date.today().month)
                        & Q(modifieddate__year=date.today().year)
                        & Q(technician=technician)
                        & Q(branch=currentuser.userprofile.branch)
                    )
                    .values("status")
                    .annotate(Count("status"))
                )
            elif date_selected == "year":
                service_obj = (
                    Service.objects.filter(
                        Q(modifieddate__year=date.today().year)
                        & Q(technician=technician)
                        & Q(branch=currentuser.userprofile.branch)
                    )
                    .values("status")
                    .annotate(Count("status"))
                )
            service_status = get_service_details(service_obj)
    elif date_selected:
        technician = User.objects.filter(username=request.user.username).first()
        if date_selected == "today":
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate=date.today()) & Q(technician=technician)
                )
                .values("status")
                .annotate(Count("status"))
            )
        elif date_selected == "month":
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate__month=date.today().month)
                    & Q(modifieddate__year=date.today().year)
                    & Q(technician=technician)
                )
                .values("status")
                .annotate(Count("status"))
            )
        elif date_selected == "year":
            service_obj = (
                Service.objects.filter(
                    Q(modifieddate__year=date.today().year) & Q(technician=technician)
                )
                .values("status")
                .annotate(Count("status"))
            )
        service_status = get_service_details(service_obj)

    return JsonResponse(service_status)


# Dashboard functions ends here


# Notification functions starts here
@login_required
def notificationsList(request):

    notification_obj = ScheduleCallNotifications.objects.filter(
        user=request.user
    ).order_by("-pk")
    notification_list = []

    for notif in notification_obj:
        if notif.notification_type == "servicecall":
            serv = Service.objects.filter(servicerefnumber=notif.serviceref).first()

            dic = {
                "notification_type": notif.notification_type,
                "status": notif.status,
                "schedule_call": notif.shedule_call,
                "service": serv,
                "serviceref": notif.serviceref,
                "notification_id": notif.id,
            }
            notification_list.append(dic)

    context = {
        "notifications": notification_list,
    }
    return render(request, "notifications.html", context)


@login_required
def deleteNotification(request, notificationid):

    notification = ScheduleCallNotifications.objects.filter(id=notificationid).first()
    notification.delete()

    return redirect("notifications")


# Notification functions ends here


@login_required
def change_sidebar_status(request):
    if request.method == "POST":
        received_data = QueryDict(request.body)
        status = received_data.get("status")
        if status == "clicked":
            status = request.user.userprofile.sidebar_status
            userprofile = UserProfile.objects.filter(user=request.user).first()
            if status == "":
                userprofile.sidebar_status = "sidebar-icon-only"
                userprofile.save()
                status = "sidebar-icon-only"
            else:
                userprofile.sidebar_status = ""
                userprofile.save()
                status = ""
            return JsonResponse({"status": status})


# service entry by customer


def customerServiceEntry(request):

    serviceissues = ServiceIssues.objects.all().order_by("-pk")
    brands = PhoneBrand.objects.all().order_by("-pk")
    products = ServiceProduct.objects.all().order_by("-pk")
    url = LiveStreamUrl.objects.all().first()

    calling_code = "+91"
    if str(timezone.get_current_timezone()) == "Asia/Kolkata":
        calling_code = "+91"

    if calling_code == "+91":
        cities = City.objects.filter(country__name="India").order_by("-pk")

    branches = Branch.objects.all()
    context = {
        "issues": serviceissues,
        "brands": brands,
        "cities": cities,
        "brands": brands,
        "calling_code": calling_code,
        "branches": branches,
        "products": products,
        "url": url,
    }

    return render(request, "customerserviceentry.html", context)


def customerServiceEntryServices(request, service):

    serviceissues = ServiceIssues.objects.all().order_by("-pk")
    brands = PhoneBrand.objects.all().order_by("-pk")
    products = ServiceProduct.objects.all().order_by("-pk")

    calling_code = "+91"
    if str(timezone.get_current_timezone()) == "Asia/Kolkata":
        calling_code = "+91"

    if calling_code == "+91":
        cities = City.objects.filter(country__name="India").order_by("-pk")

    branches = Branch.objects.all()
    context = {
        "issues": serviceissues,
        "brands": brands,
        "cities": cities,
        "brands": brands,
        "calling_code": calling_code,
        "branches": branches,
        "products": products,
    }

    context = {"service": service}

    return render(request, "customerserviceentryservices.html", context)


def save_customer_service_booking(request):

    received_data = QueryDict(request.body)

    name = received_data.get("name")
    phone = received_data.get("phone")
    city = received_data.get("city")
    brand = received_data.get("brand")
    issue = received_data.get("issue")
    email = received_data.get("email")
    product = received_data.get("product")

    booking_obj = CustomerBookingRepair()
    booking_obj.name = name
    booking_obj.phone = phone
    booking_obj.city = city
    booking_obj.brand = brand
    booking_obj.issue = issue
    booking_obj.email = email
    booking_obj.status = "NotVerified"
    booking_obj.product = product
    booking_obj.save()

    resp = {"Response": "Success"}
    return JsonResponse(resp)


# sending email
def send_support_email(request):
    subject = request.POST.get("subject", "")
    message = request.POST.get("message", "")
    variables = custom_variables(None)
    receiver_email = variables["receiver_email"]

    if subject and message:
        try:
            sendEmail(receiver_email, subject, message)
        except Exception as e:
            context = {
                "Response": "An error occured.",
                "Image": "../static/images/somethingwrong.jpg",
            }
            return render(request, "emailsend.html", context)
        context = {
            "Response": "Email Send Successfully.",
            "Image": "../static/images/emailsuccess.jpg",
        }

        return render(request, "emailsend.html", context)

    else:
        context = {
            "Response": "Make sure all fields are entered and valid.",
            "Image": "../static/images/somethingwrong.jpg",
        }

        return render(request, "emailsend.html", context)


# custom error pages


def custom_404(request, exception):
    return render(request, "404.html", status=404)


def custom_500(request):
    return render(request, "500.html", status=500)


# documentation page
def documentation(request):

    return render(request, "documentation.html")


# for getting service tax
def get_service_tax(request):

    received_data = QueryDict(request.body)

    # name=received_data.get("name")

    servicetax = ServiceTax.objects.all().first()
    if not servicetax:
        servicetax = 0
    else:
        servicetax = servicetax.tax

    resp = {"service_tax": servicetax}
    return JsonResponse(resp)


def generate_rgba_strings(num_colors):
    import random

    rgba_strings = []
    for _ in range(num_colors):
        rgb = [random.randint(0, 255) for _ in range(3)]
        mid_range_index = random.randint(0, 2)
        # Ensure one of the RGB values is in the mid-range to avoid color extremes
        rgb[mid_range_index] = random.randint(64, 192)
        alpha = random.uniform(0.5, 1.0)
        rgba = f"rgba({rgb[0]}, {rgb[1]}, {rgb[2]}, {alpha:.1f})"
        rgba_strings.append(rgba)

    return rgba_strings


# get technicians persformance data
def get_technician_performance(request):

    received_data = QueryDict(request.body)
    # name=received_data.get("name")
    today = datetime.today().date().month
    if request.user.is_superuser:
        technican_service_income = (
            Service.objects.filter(
                Q(modifieddate__month=today) & Q(status="Delivered(Ok)")
            )
            .values("technician__username")
            .annotate(service_income=Sum("amountrecieved"))
        )
    else:
        technican_service_income = (
            Service.objects.filter(
                Q(modifieddate__month=today)
                & Q(status="Delivered(Ok)")
                & Q(branch=request.user.userprofile.branch)
            )
            .values("technician__username")
            .annotate(service_income=Sum("amountrecieved"))
        )

    technicians = []
    serviceincome = []
    for item in technican_service_income:
        technicians.append(item["technician__username"].capitalize())
        serviceincome.append(round(item["service_income"], 2))

    bgcolors = generate_rgba_strings(len(technicians))
    resp = {
        "technicians": technicians,
        "serviceincome": serviceincome,
        "bg_colors": bgcolors,
    }

    return JsonResponse(resp)


def func_calculate_spare_cost(service_numbers, branch_name):

    spare_cost = 0

    for num in service_numbers:
        spare_parts_data = SpareParts.objects.filter(
            Q(branch__name=branch_name) & Q(servicerefnumber=num)
        )
        for spare in spare_parts_data:

            product = spare.name
            qty = float(spare.totalquantity)
            # spare_purchase_cost = product.price
            spare_purchase_cost = spare.purchase_price

            # spare_purchase_tax = float(product.purchasegst.percentage)
            spare_purchase_tax = float(spare.purchase_tax)

            total = (
                spare_purchase_cost + ((spare_purchase_tax / 100) * spare_purchase_cost)
            ) * qty

            spare_cost += total

    return spare_cost


@login_required
def dashboardTable(request):



    #########################################################################
    if request.method == "POST" or request.method == "post":
        start_date = datetime.strptime(request.POST["startdate"], "%d-%m-%Y").strftime(
            "%Y-%m-%d"
        )

        end_date = datetime.strptime(request.POST["enddate"], "%d-%m-%Y").strftime(
            "%Y-%m-%d"
        )
        startdate = datetime.strptime(start_date, "%Y-%m-%d").strftime("%B %d, %Y")
        enddate = datetime.strptime(end_date, "%Y-%m-%d").strftime("%B %d, %Y")
    else:
        start_date = datetime.today().date()
        end_date = start_date
        startdate = start_date
        enddate = end_date

    user = request.user

    branches_with_service_count = (
        Branch.objects.filter(Q(branchtype="Own") | Q(branchtype="Franchise"))
        .annotate(
            service_count=Count(
                "services",
                filter=Q(services__createddate__gte=start_date)
                & Q(services__createddate__lte=end_date),
            ),
            service_completed=Count(
                "services",
                filter=Q(services__modifieddate__gte=start_date)
                & Q(services__modifieddate__lte=end_date)
                & Q(services__status="Delivered(Ok)"),
            ),
            service_not_completed=Count(
                "services",
                filter=Q(services__modifieddate__gte=start_date)
                & Q(services__modifieddate__lte=end_date)
                & Q(services__status="Delivered(NotOk)"),
            ),
            completed_waiting_dispatch=Count(
                "services",
                filter=Q(services__modifieddate__gte=start_date)
                & Q(services__modifieddate__lte=end_date)
                & Q(services__status="CNP Completed(Ok)"),
            ),
            pending_under_repair=Count(
                "services",
                filter=Q(services__modifieddate__gte=start_date)
                & Q(services__modifieddate__lte=end_date)
                & (
                    Q(services__status="Unacknowledged")
                    | Q(services__status="In Progress")
                    | Q(services__status="Spare Requested")
                    | Q(services__status="Spare Allocated")
                ),
            ),
            service_income=Sum(
                "services__amountrecieved",
                filter=Q(services__modifieddate__gte=start_date)
                & Q(services__modifieddate__lte=end_date)
                & Q(services__status="Delivered(Ok)"),
            ),
        )
        .values(
            "name",
            "service_count",
            "service_completed",
            "service_not_completed",
            "service_income",
            "completed_waiting_dispatch",
            "pending_under_repair",
        )
    )

    data_list = [
        {
            "branch": branch["name"],
            "input": branch["service_count"],
            "output_ok": branch["service_completed"],
            "output_notok": branch["service_not_completed"],
            "completed_waiting_dispatch": branch["completed_waiting_dispatch"],
            "pending_under_repair": branch["pending_under_repair"],
            "service_income": branch["service_income"],
            # 'sale_income':branch['sale_income'],
        }
        for branch in branches_with_service_count
    ]

    #########################################################################

    branches_with_service = Branch.objects.filter(
        (Q(branchtype="Own") | Q(branchtype="Franchise"))
        & Q(services__modifieddate__gte=start_date)
        & Q(services__modifieddate__lte=end_date)
        & Q(services__status="Delivered(Ok)")
    ).values("name", "services__servicerefnumber")

    grouped_data = defaultdict(list)
    for item in branches_with_service:
        grouped_data[item["name"]].append(item["services__servicerefnumber"])

    result_list = [
        {"name": key, "servicerefnumber": value} for key, value in grouped_data.items()
    ]

    result_list_final = []

    for branch_data in result_list:
        branch_name = branch_data["name"]
        service_numbers = []

        for i in branch_data["servicerefnumber"]:
            if (
                Service.objects.filter(servicerefnumber=i).first().status
                == "Delivered(Ok)"
            ):
                service_numbers.append(i)

        spare_cost = func_calculate_spare_cost(service_numbers, branch_name)

        result_list_final.append(
            {
                "name": branch_name,
                "servicerefnumber": service_numbers,
                "spare_cost": spare_cost,
            }
        )

    final_result = []
    spare_cost_dict = {
        entry["name"]: entry["spare_cost"] for entry in result_list_final
    }

    for entry in data_list:
        branch_name = entry["branch"]

        spare_cost = spare_cost_dict.get(branch_name, 0)
        entry["spare_cost"] = spare_cost
        final_result.append(entry)

    net_service_income_list_for_graph = {"branches": [], "income": []}

    for entry in final_result:
        service_income = entry.get("service_income", 0)
        if not service_income:
            entry["service_income"] = 0
            service_income = 0
        spare_cost = entry.get("spare_cost", 0)
        net_service_income = service_income - spare_cost
        entry["net_service_income"] = net_service_income
        net_service_income_list_for_graph["branches"].append(entry["branch"])
        net_service_income_list_for_graph["income"].append(
            round(entry["net_service_income"], 2)
        )

    #########################################################################

    # -------------------------------------------------------------------
    branches_with_saleincome = Branch.objects.filter(
        (Q(branchtype="Own") | Q(branchtype="Franchise"))
        & Q(branch_sales__invoicedate__gte=start_date)
        & Q(branch_sales__invoicedate__lte=end_date)
    ).values("name", "branch_sales__amountrecieved")

    grouped_data_sales = defaultdict(list)
    for item in branches_with_saleincome:
        grouped_data_sales[item["name"]].append(item["branch_sales__amountrecieved"])

    result_list_saleincome = [
        {"name": key, "sale_income": value} for key, value in grouped_data_sales.items()
    ]
    # -------------------------------------------------------------------
    branches_with_saleid = Branch.objects.filter(
        (Q(branchtype="Own") | Q(branchtype="Franchise"))
        & Q(branch_sales__invoicedate__gte=start_date)
        & Q(branch_sales__invoicedate__lte=end_date)
    ).values("name", "branch_sales__saleid")

    grouped_data_sales = defaultdict(list)

    for item in branches_with_saleid:
        grouped_data_sales[item["name"]].append(item["branch_sales__saleid"])

    result_list_saleid = [
        {"name": key, "saleid": value} for key, value in grouped_data_sales.items()
    ]
    # -------------------------------------------------------------------

    out = calculate_unique_income(result_list_saleid, result_list_saleincome)

    for item in data_list:
        for inc in out:
            if "sale_income" not in inc.keys():
                inc["sale_income"]= 0
            if inc["name"] == item["branch"]:
                item["sale_income"] = inc["sale_income"]

    # ------------------------------------------------
    branches_with_salebarcode = Branch.objects.filter(
        (Q(branchtype="Own") | Q(branchtype="Franchise"))
        & Q(branch_sales__invoicedate__gte=start_date)
        & Q(branch_sales__invoicedate__lte=end_date)
    ).values("name", "branch_sales__invoicenumber")

    grouped_data_sales = defaultdict(list)

    for item in branches_with_salebarcode:
        grouped_data_sales[item["name"]].append(item["branch_sales__invoicenumber"])

    result_list_salebarcode = [
        {"name": key, "barcode": value} for key, value in grouped_data_sales.items()
    ]

    net_sale_income_list_for_graph = {"branches": [], "income": []}
    purchase_costs = calculate_purchase_cost(result_list_salebarcode)
    for item in data_list:
        for inc in purchase_costs:
            if "purchase_cost" not in inc.keys():
                inc["purchase_cost"] = 0
            if inc["name"] == item["branch"]:
                item["purchase_cost"] = inc["purchase_cost"]
                item["net_sales_income"] = item["sale_income"] - item["purchase_cost"]
                net_sale_income_list_for_graph["branches"].append(item["branch"])
                net_sale_income_list_for_graph["income"].append(
                    round(item["net_sales_income"], 2)
                )
    # ------------------------------------------------

    #########################################################################
    ###### for service vs sale stacked chart ############
    service_sale_stacked_chart = {
        "branches": list(
            set(
                net_sale_income_list_for_graph["branches"]
                + net_service_income_list_for_graph["branches"]
            )
        ),
        "sale": [],
        "service": [],
    }
    for item in service_sale_stacked_chart["branches"]:
        try:
            service_branch_index = net_service_income_list_for_graph["branches"].index(
                item
            )
            service_income = net_service_income_list_for_graph["income"][
                service_branch_index
            ]
            service_sale_stacked_chart["service"].append(service_income)
        except:
            service_sale_stacked_chart["service"].append(0)

        try:
            sale_branch_index = net_sale_income_list_for_graph["branches"].index(item)
            sale_income = net_sale_income_list_for_graph["income"][sale_branch_index]
            service_sale_stacked_chart["sale"].append(sale_income)
        except:
            service_sale_stacked_chart["sale"].append(0)

    ######################################################################3

    total = {
        "branch": "Total",
        "input": sum(item.get("input", 0) for item in data_list),
        "output_ok": sum(item.get("output_ok", 0) for item in data_list),
        "output_notok": sum(item.get("output_notok", 0) for item in data_list),
        "completed_waiting_dispatch": sum(
            item.get("completed_waiting_disalatch", 0) for item in data_list
        ),
        "pending_under_repair": sum(
            item.get("pending_under_repair", 0) for item in data_list
        ),
        "service_income": sum(
            (
                item.get("service_income", 0)
                if item.get("service_income") is not None
                else 0
            )
            for item in data_list
        ),
        "spare_cost": sum(
            item.get("spare_cost", 0) if item.get("spare_cost") is not None else 0
            for item in data_list
        ),
        "net_service_income": sum(
            (
                item.get("net_service_income", 0)
                if item.get("net_service_income") is not None
                else 0
            )
            for item in data_list
        ),
        "sale_income": sum(
            item.get("sale_income", 0) if item.get("sale_income") is not None else 0
            for item in data_list
        ),
        "purchase_cost": sum(
            item.get("purchase_cost", 0) if item.get("purchase_cost") is not None else 0
            for item in data_list
        ),
        "net_sales_income": sum(
            (
                item.get("net_sales_income", 0)
                if item.get("net_sales_income") is not None
                else 0
            )
            for item in data_list
        ),
    }
    data_list.append(total)

    if user.is_superuser:
        data_list_final = data_list
    else:
        data_list_final = [
            data for data in data_list if user.userprofile.branch.name == data["branch"]
        ]

    context = {
        "branch_data": data_list_final,
        "start_date": startdate,
        "end_date": enddate,
        "net_sale_graph": net_sale_income_list_for_graph,
        "net_service_graph": net_service_income_list_for_graph,
        "service_sale_graph": service_sale_stacked_chart,
    }
    return render(request, "dashboardtable.html", context)


@login_required
def serviceReport(request):

    username = request.user
    all_branches = Branch.objects.filter(
        (Q(branchtype="Own") | Q(branchtype="Franchise")) & ~Q(name="WAREHOUSE")
    )
    all_technician = technician = UserProfile.objects.filter(role="Technician")
    all_years = Service.objects.values("memodate__year").distinct()
    # daily
    service_obj = (
        Service.objects.filter(modifieddate=date.today())
        .values("status")
        .annotate(Count("status"))
    )
    service_status = get_service_details(service_obj)

    if (
        username.userprofile.role == "Branch Admin"
        or username.userprofile.role == "Franchise Admin"
    ):
        admin_branch = username.userprofile.branch
        all_technician = UserProfile.objects.filter(
            Q(role="Technician") & Q(branch=admin_branch)
        )
        service_obj = (
            Service.objects.filter(
                Q(branch=admin_branch) & Q(modifieddate=date.today())
            )
            .values("status")
            .annotate(Count("status"))
        )
        service_status = get_service_details(service_obj)
    elif username.userprofile.role == "Technician":
        technician_branch = username.userprofile.branch
        all_technician = UserProfile.objects.filter(
            Q(role="Technician") & Q(branch=technician_branch)
        )
        service_obj = (
            Service.objects.filter(
                Q(branch=technician_branch)
                & Q(modifieddate=date.today())
                & Q(technician=username)
            )
            .values("status")
            .annotate(Count("status"))
        )
        service_status = get_service_details(service_obj)

    # monthly
    service_obj_monthly = (
        Service.objects.filter(
            Q(modifieddate__month=date.today().month)
            & Q(modifieddate__year=date.today().year)
        )
        .values("status")
        .annotate(Count("status"))
    )
    service_status_monthly = get_service_details(service_obj_monthly)
    if (
        username.userprofile.role == "Branch Admin"
        or username.userprofile.role == "Franchise Admin"
    ):
        admin_branch_month = username.userprofile.branch
        service_obj_monthly = (
            Service.objects.filter(
                Q(branch=admin_branch_month)
                & Q(modifieddate__month=date.today().month)
                & Q(modifieddate__year=date.today().year)
            )
            .values("status")
            .annotate(Count("status"))
        )
        service_status_monthly = get_service_details(service_obj_monthly)
    elif username.userprofile.role == "Technician":
        technician_branch = username.userprofile.branch
        service_obj_monthly = (
            Service.objects.filter(
                Q(branch=technician_branch)
                & Q(modifieddate__month=date.today().month)
                & Q(technician=username)
                & Q(modifieddate__year=date.today().year)
            )
            .values("status")
            .annotate(Count("status"))
        )
        service_status_monthly = get_service_details(service_obj_monthly)

    # yearly
    service_obj_yearly = (
        Service.objects.filter(modifieddate__year=date.today().year)
        .values("status")
        .annotate(Count("status"))
    )
    service_status_yearly = get_service_details(service_obj_yearly)
    if (
        username.userprofile.role == "Branch Admin"
        or username.userprofile.role == "Franchise Admin"
    ):
        admin_branch_yearly = username.userprofile.branch
        service_obj_yearly = (
            Service.objects.filter(
                Q(branch=admin_branch_yearly) & Q(modifieddate__year=date.today().year)
            )
            .values("status")
            .annotate(Count("status"))
        )
        service_status_yearly = get_service_details(service_obj_yearly)
    elif username.userprofile.role == "Technician":
        technician_branch = username.userprofile.branch
        service_obj_yearly = (
            Service.objects.filter(
                Q(branch=technician_branch)
                & Q(modifieddate__year=date.today().year)
                & Q(technician=username)
            )
            .values("status")
            .annotate(Count("status"))
        )
        service_status_yearly = get_service_details(service_obj_yearly)

    month_dict = {
        "1": "January",
        "2": "February",
        "3": "March",
        "4": "April",
        "5": "May",
        "6": "June",
        "7": "July",
        "8": "August",
        "9": "September",
        "10": "October",
        "11": "November",
        "12": "December",
    }

    ###### service income by technicians
    if request.method == "POST" or request.method == "post":
        firstday = datetime.strptime(request.POST["startdate"], "%d-%m-%Y").strftime(
            "%Y-%m-%d"
        )

        lastday = datetime.strptime(request.POST["enddate"], "%d-%m-%Y").strftime(
            "%Y-%m-%d"
        )
        startday = datetime.strptime(firstday, "%Y-%m-%d").strftime("%B %d, %Y")
        endday = datetime.strptime(lastday, "%Y-%m-%d").strftime("%B %d, %Y")
    else:
        current_month = datetime.today().date()
        firstday = current_month + relativedelta(day=1)
        lastday = current_month + relativedelta(day=31)
        startday = firstday
        endday = lastday

    user = request.user

    if request.user.is_superuser:
        technican_service_income = (
            Service.objects.filter(
                Q(modifieddate__gte=firstday)
                & Q(modifieddate__lte=lastday)
                & Q(status="Delivered(Ok)")
            )
            .values("technician__username")
            .annotate(service_income=Sum("amountrecieved"))
        )

        service_ref_numbers = Service.objects.filter(
            Q(modifieddate__gte=firstday)
            & Q(modifieddate__lte=lastday)
            & Q(status="Delivered(Ok)")
        ).values("technician__username", "servicerefnumber")
    else:
        technican_service_income = (
            Service.objects.filter(
                Q(modifieddate__gte=firstday)
                & Q(modifieddate__lte=lastday)
                & Q(status="Delivered(Ok)")
                & Q(branch=request.user.userprofile.branch)
            )
            .values("technician__username")
            .annotate(service_income=Sum("amountrecieved"))
        )
        service_ref_numbers = Service.objects.filter(
            Q(modifieddate__gte=firstday)
            & Q(modifieddate__lte=lastday)
            & Q(status="Delivered(Ok)")
            & Q(branch=request.user.userprofile.branch)
        ).values("technician__username", "servicerefnumber")

    grouped_data = defaultdict(list)
    for item in service_ref_numbers:
        grouped_data[item["technician__username"]].append(item["servicerefnumber"])

    result_list = [
        {"name": key, "servicerefnumber": value} for key, value in grouped_data.items()
    ]

    result_list_final = []

    for data in result_list:
        branch_name = (
            User.objects.filter(username=data["name"]).first().userprofile.branch.name
        )
        service_numbers = []

        for i in data["servicerefnumber"]:
            if (
                Service.objects.filter(servicerefnumber=i).first().status
                == "Delivered(Ok)"
            ):
                service_numbers.append(i)

        spare_cost = func_calculate_spare_cost(service_numbers, branch_name)

        result_list_final.append(
            {
                "name": data["name"],
                "servicerefnumber": service_numbers,
                "spare_cost": spare_cost,
            }
        )

    technicians = []
    serviceincome = []
    technican_income = []

    for item in technican_service_income:
        technicians.append(item["technician__username"].capitalize())
        serviceincome.append(round(item["service_income"], 2))
        technican_income.append(
            {
                "technician": item["technician__username"],
                "income": item["service_income"],
            }
        )

    final_result = []
    spare_cost_dict = {
        entry["name"]: entry["spare_cost"] for entry in result_list_final
    }

    for entry in technican_income:
        technician_name = entry["technician"]

        spare_cost = spare_cost_dict.get(technician_name, 0)
        entry["spare_cost"] = spare_cost
        entry["branch"] = (
            User.objects.filter(username=technician_name)
            .first()
            .userprofile.branch.name
        )
        final_result.append(entry)

    all_tech = []
    all_serv_income = []
    all_serv_prof = []

    for entry in final_result:
        service_income = entry.get("income", 0)
        if not service_income:
            entry["income"] = 0
            service_income = 0
        spare_cost = entry.get("spare_cost", 0)
        net_service_income = service_income - spare_cost
        entry["net_service_income"] = net_service_income

        all_tech.append(entry["technician"])
        all_serv_income.append(round(service_income, 2))
        all_serv_prof.append(round(net_service_income, 2))

    bgcolors = generate_rgba_strings(len(technicians))

    resp = {
        "technicians": technicians,
        "serviceincome": serviceincome,
        "technicianincome": technican_income,
        "bg_colors": bgcolors,
        "startdate": startday,
        "enddate": endday,
    }

    #########################################################################

    context = {
        "technician_income": resp,
        "all_branches": all_branches,
        "all_technician": all_technician,
        "username": username,
        "all_service": service_status,
        "all_service_monthly": service_status_monthly,
        "all_service_yearly": service_status_yearly,
        "current_month": {
            "month": date.today().month,
            "month_str": month_dict[str(date.today().month)],
        },
        "current_year": {"year": date.today().year},
        "all_years": list(all_years),
        "all_tech": all_tech,
        "all_serv_income": all_serv_income,
        "all_serv_prof": all_serv_prof,
    }

    return render(request, "servicereport.html", context)


@login_required
def update_language(request):

    language = request.POST["language"]
    lan_obg = Language.objects.first()
    if lan_obg:
        lan_obg.language = language
        lan_obg.save()
    else:
        lan_obg = Language()
        lan_obg.language = language
        lan_obg.save()

    return redirect("settings")


@login_required
def update_pagesize(request):

    size_id = request.POST["pagesize"]
    pagesize = PageSize.objects.filter(id=int(size_id)).first()

    if pagesize:
        pagesize.active = True
        pagesize.save()

    return redirect("settings")


# modal product list
@login_required
def modal_product_list(request):

    current_user = request.user
    if current_user.is_superuser:
        prod_list_obj = ProductPriceList.objects.all()
    else:
        prod_list_obj = ProductPriceList.objects.filter(
            branch=current_user.userprofile.branch
        )

    context = {"prod_list_obj": prod_list_obj}
    return render(request, "modalproductlist.html", context)


@login_required
def modal_product_form(request):

    context = {}
    return render(request, "modalproductform.html", context)


@login_required
def add_product_price_list(request):

    brand = request.POST.get("brand")
    modal = request.POST.get("modal")
    product = request.POST.get("product")
    price1 = request.POST.get("price1")
    price2 = request.POST.get("price2")
    price3 = request.POST.get("price3")

    modal_obj = ProductPriceList()
    modal_obj.brand = brand
    modal_obj.modal = modal
    modal_obj.product = product
    modal_obj.price1 = price1
    modal_obj.price2 = price2
    modal_obj.price3 = price3
    modal_obj.added_by = request.user
    modal_obj.branch = request.user.userprofile.branch
    modal_obj.save()

    return redirect("modalproductlist")


@login_required
def update_modal_product_price(request, id):

    modal_obj = ProductPriceList.objects.filter(id=int(id)).first()
    if not modal_obj:
        return redirect("modalproductlist")

    context = {"data": modal_obj}
    return render(request, "modalproductupdateform.html", context)


@login_required
def update_product_price_list(request):

    modal_id = request.POST.get("id")
    brand = request.POST.get("brand")
    modal = request.POST.get("modal")
    product = request.POST.get("product")
    price1 = request.POST.get("price1")
    price2 = request.POST.get("price2")
    price3 = request.POST.get("price3")

    modal_obj = ProductPriceList.objects.filter(id=int(modal_id)).first()
    if modal_obj:
        modal_obj.brand = brand
        modal_obj.modal = modal
        modal_obj.product = product
        modal_obj.price1 = price1
        modal_obj.price2 = price2
        modal_obj.price3 = price3
        modal_obj.added_by = request.user
        modal_obj.branch = request.user.userprofile.branch
        modal_obj.modified_date = datetime.now()
        modal_obj.save()
        messages.success(request, "Updated!")
    else:
        messages.error(request, "Something went wrong.")
        return redirect(reverse("updatemodalproductprice", kwargs={"id": modal_id}))

    return redirect(reverse("updatemodalproductprice", kwargs={"id": modal_id}))


@login_required
def delete_modal_product_price(request, id):

    modal_obj = ProductPriceList.objects.filter(id=int(id)).first()
    if not modal_obj:
        messages.error(request, "Something went wrong.")
        return redirect(reverse("updatemodalproductprice", kwargs={"id": id}))
    else:
        modal_obj.delete()

    return redirect("modalproductlist")


@login_required
def addcustomer(request):
    data = Customers()
    data.firstname = request.POST["firstname"]
    data.lastname = request.POST["lastname"]
    data.phone = request.POST["phone"]
    data.phonemodel = request.POST["phonemodel"]
    unique_id = generate_unique_id("Customers", "MAGNUS")
    data.unique_id = unique_id
    if request.POST["purchasedate"]:
        data.purchasedate = request.POST["purchasedate"]
    if request.POST["dob"]:
        data.dob = request.POST["dob"]
    data.address = request.POST["address"]
    data.addedby = request.user
    data.branch = request.user.userprofile.branch
    data.vatnumber = request.POST["vatnumber"]
    data.customertype = request.POST["customertype"]
    try:
        data.save()
    except IntegrityError as e:
        messages.error(request, f"Phone number already exists.")
        return redirect("customerform")
    except:
        messages.error(request, f"An error occured.")
        return redirect("customerform")
    if data.phone and data.unique_id:
        whatsapp(data.phone, data.unique_id)

    cust_obj = Customers.objects.filter(unique_id=unique_id).first()
    if cust_obj:
        func_create_customer_ledger(cust_obj,unique_id,request)

    return HttpResponseRedirect("/customers")


# SG-29
@login_required
def addcustomerfromsales(request):

    received_data = QueryDict(request.body)
    firstname = received_data.get("firstname")
    lastname = received_data.get("lastname")
    phone = received_data.get("phone")
    address = received_data.get("address")
    vatnumber = received_data.get("vatnumber")
    customertype = received_data.get("customertype")

    data = Customers()
    data.firstname = firstname
    data.lastname = lastname
    data.phone = phone
    unique_id = generate_unique_id("Customers", "MAGNUS")
    data.unique_id = unique_id
    # if request.POST['purchasedate']:
    #     data.purchasedate = request.POST['purchasedate']
    # if request.POST['dob']:
    #     data.dob = request.POST['dob']
    data.address = address
    data.addedby = request.user
    data.vatnumber = vatnumber
    data.customertype = customertype
    data.branch = request.user.userprofile.branch

    try:
        data.save()
        resp = {
            "firstname": firstname,
            "lastname": lastname,
            "phone": phone,
            "address": address,
            "id": Customers.objects.filter(phone=phone).first().id,
            "magnusid": Customers.objects.filter(phone=phone).first().unique_id,
            "vatnumber": vatnumber,
            "customertype": customertype,
        }
    except IntegrityError as e:
        resp = "exist_error"
    except:
        resp = "error"

    cust_obj = Customers.objects.filter(unique_id=unique_id).first()
    if cust_obj:
        func_create_customer_ledger(cust_obj,unique_id,request)

    return JsonResponse({"Response": resp})


@login_required
def addexternalfranchisefromsales(request):

    received_data = QueryDict(request.body)
    name = received_data.get("name")
    phone = received_data.get("phone")
    branchType = received_data.get("branchType")
    branchCategory = received_data.get("branchCategory")
    branchGstin = received_data.get("branchGstin")
    branchAddres = received_data.get("branchAddres")

    data = Branch()
    data.name = name
    data.address = branchAddres
    data.branchtype = branchType
    data.branchcategory = branchCategory
    data.gstin = branchGstin

    try:
        data.save()
        resp = {
            "name": name,
            "phone": phone,
            "branchType": branchType,
            "branchCategory": branchCategory,
            "gstin": branchGstin,
            "id": Branch.objects.filter(name=name).first().id,
        }

    except IntegrityError as e:
        resp = "exist_error"
    except:
        resp = "error"

    return JsonResponse({"Response": resp})


def combine_taxes(tax_list):
    combined = {}

    for tax in tax_list:
        percentage = tax["percentage"]

        if percentage in combined:
            combined[percentage]["perc_tax"] += tax["perc_tax"]
            combined[percentage]["perc_sale"] += tax["perc_sale"]
        else:
            combined[percentage] = {
                # 'price': tax['price'],
                "percentage": tax["percentage"],
                "perc_tax": tax["perc_tax"],
                "perc_sale": tax["perc_sale"],
                "type": "Combined",
            }

    # Convert the combined dictionary back to a list
    result = list(combined.values())
    return result


def combine_gst(gst_list):
    # Dictionary to hold combined data
    combined_data = {}

    # Processing the sale_data list
    for entry in gst_list:
        percentage = entry["percentage"]
        discount = entry.get("discount", 0.0)

        if percentage not in combined_data:
            combined_data[percentage] = {
                "discount": discount,
                "percentage": percentage,
                "CGST": 0.0,
                "SGST": 0.0,
            }

        # Summing up CGST and SGST values
        for key in entry:
            if key.startswith("CGST"):
                combined_data[percentage]["CGST"] += entry[key]
            elif key.startswith("SGST"):
                combined_data[percentage]["SGST"] += entry[key]

    # Converting combined data to the desired format
    result = []
    for percentage, data in combined_data.items():
        dic = {
            "discount": data["discount"],
            "percentage": data["percentage"],
            f"CGST{percentage / 2}": data["CGST"],
            f"SGST{percentage / 2}": data["SGST"],
        }
        result.append(dic)

    # Sorting the result list by percentage
    result.sort(key=lambda x: x["percentage"])
    return result


def combine_taxes_purchase(tax_list):
    combined = {}

    for tax in tax_list:
        percentage = tax["percentage"]

        if percentage in combined:
            combined[percentage]["perc_tax"] += tax["perc_tax"]
            combined[percentage]["perc_purchase"] += tax["perc_purchase"]
        else:
            combined[percentage] = {
                # 'price': tax['price'],
                "percentage": tax["percentage"],
                "perc_tax": tax["perc_tax"],
                "perc_purchase": tax["perc_purchase"],
                "type": "Combined",
            }

    # Convert the combined dictionary back to a list
    result = list(combined.values())
    return result


def combine_gst_purchase_return(gst_list):
    # Dictionary to hold combined data
    combined_data = {}

    # Processing the sale_data list
    for entry in gst_list:
        percentage = entry["percentage"]
        discount = entry.get("adjustment", 0.0)

        if percentage not in combined_data:
            combined_data[percentage] = {
                "adjustment": discount,
                "percentage": percentage,
                "CGST": 0.0,
                "SGST": 0.0,
            }

        # Summing up CGST and SGST values
        for key in entry:
            if key.startswith("CGST"):
                combined_data[percentage]["CGST"] += entry[key]
            elif key.startswith("SGST"):
                combined_data[percentage]["SGST"] += entry[key]

    # Converting combined data to the desired format
    result = []
    for percentage, data in combined_data.items():
        dic = {
            "adjustment": data["adjustment"],
            "percentage": data["percentage"],
            f"CGST{percentage / 2}": data["CGST"],
            f"SGST{percentage / 2}": data["SGST"],
        }
        result.append(dic)

    # Sorting the result list by percentage
    result.sort(key=lambda x: x["percentage"])
    return result


# SG-24 , SG-34
@login_required
def saletaxreport(request):
    current_user = request.user
    current_branch = current_user.userprofile.branch
    current_date = datetime.now().date()
    filters = Q()

    search_params = {
        "branch": "All",
        "start_date": date.today(),
        "end_date": date.today(),
    }

    # Handle POST request parameters
    if request.method == "POST":
        branch = request.POST.get("branch", None)
        startdate = request.POST.get("startdate", None)
        enddate = request.POST.get("enddate", None)

        if current_user.is_superuser and branch:
            filters &= Q(branch=branch)
            search_params["branch"] = Branch.objects.filter(id=int(branch)).first().name
        else:
            filters &= Q(branch=current_branch)

        if startdate:
            start_date = datetime.strptime(startdate, "%d-%m-%Y").date()
            filters &= Q(invoicedate__gte=start_date)
            search_params["start_date"] = start_date

        if enddate:
            end_date = datetime.strptime(enddate, "%d-%m-%Y").date()
            filters &= Q(invoicedate__lte=end_date)
            search_params["end_date"] = end_date
    else:
        filters &= Q(invoicedate=current_date)
        if not current_user.is_superuser:
            filters &= Q(branch=current_branch)

    # Query Sale data
    sale_data = (
        Sale.objects.filter(filters)
        .values(
            "invoicenumber",
            "invoicedate",
            "customer",
            "totalbillingamount",
            "totalamount",
            "branch",
            "totaltax",
            "discount",
            "discountmethod",
        )
        .annotate(quantity=Count("invoicenumber"))
    )



    if current_user.is_superuser:
        all_branches = Branch.objects.filter(
            Q(branchtype="Own") | Q(branchtype="Franchise") | Q(name="WAREHOUSE")
        )
    else:
        all_branches = [current_branch]


    taxes = Tax.objects.values("percentage").distinct()
    taxes = [{"percentage": float(i["percentage"])} for i in taxes]

    gsts = []
    for t in taxes:
        gsts.append(f"CGST{t['percentage']/2}")
        gsts.append(f"SGST{t['percentage']/2}")

    sale_data_final = []

    for item in sale_data:
        inv_taxes = []
        gst_split = []
        tx_list = []

        if current_user.is_superuser:
            sale_obj = Sale.objects.filter(invoicenumber=item["invoicenumber"])
        else:
            sale_obj = Sale.objects.filter(
                Q(branch=current_branch) & Q(invoicenumber=item["invoicenumber"])
            )

        for i in sale_obj:
            sub_dict = {}
            gst_dict = {}
            tx = (
                Tax.objects.filter(Q(branch=i.branch) & Q(name=i.salegst))
                .first()
                .percentage
            )
            try:
                # sub_dict["discount"] = float(i.discount)
                # gst_dict["discount"] = float(i.discount)
                ######### added on 26/08/2024 #######
   
                if i.discountmethod == 'flat':
                    sub_dict["discount"] = float(i.discount)
                    gst_dict["discount"] = float(i.discount)
                elif i.discountmethod == 'percentage':
                    disc = (float(i.totalamount)*(float(i.discount)/100))

                    sub_dict["discount"] = float(disc)
                    gst_dict["discount"] = float(disc)
                    item['discount'] = disc
                else:
                    sub_dict["discount"] = 0.00
                    gst_dict["discount"] = 0.00
                
                #####################################
            except:
                sub_dict["discount"] = 0.00
                gst_dict["discount"] = 0.00

            sub_dict["percentage"] = float(tx)
            gst_dict["percentage"] = float(tx)
            gst_dict["totaltax"] = float(i.totaltax)


            disc_pad=sub_dict['discount']
            finalamnt_pad = i.totalbillingamount
            price_pad = i.price
            price_after_discount = ((price_pad  - (price_pad  *((disc_pad/(finalamnt_pad+disc_pad))))))

            # sub_dict["perc_sale"] = round(float(i.price) * int(i.totalquantity), 2)
            sub_dict["perc_sale"] = round(float(price_after_discount) * int(i.totalquantity), 2)


            # sub_dict["perc_tax"] = round(
            #     round((float(i.price) * (int(tx) / 100)), 2) * int(i.totalquantity), 2
            # )
            sub_dict["perc_tax"] = round(
                round((float(price_after_discount) * (int(tx) / 100)), 2) * int(i.totalquantity), 2
            )



            sub_dict["totaltax"] = float(i.totaltax)

            # perc_tx = round(
            #     round((float(i.price) * (int(tx) / 100)), 2) * int(i.totalquantity), 2
            # )
            perc_tx = round(
                round((float(price_after_discount) * (int(tx) / 100)), 2) * int(i.totalquantity), 2
            )



            gst_dict[f"CGST{float(tx)/2}"] = round(perc_tx / 2, 2)
            gst_dict[f"SGST{float(tx)/2}"] = round(perc_tx / 2, 2)

            inv_taxes.append(sub_dict)
            tx_list.append(float(tx))
            gst_split.append(gst_dict)

        # calculate the amount tat should be deducted from each product total

        no_of_products = len(tx_list)
        # for j in inv_taxes:
        #     amount_to_deduct = j["discount"] / no_of_products
        #     j["perc_sale"] = j["perc_sale"] - amount_to_deduct

        for x in taxes:
            if float(x["percentage"]) not in tx_list:
                dic = {}
                gst_dict = {}
                dic["discount"] = 0.00
                dic["percentage"] = float(x["percentage"])
                dic["perc_tax"] = 0.00
                dic["perc_sale"] = 0.00
                gst_dict["percentage"] = float(x["percentage"])
                perc_half = float(x["percentage"]) / 2
                gst_dict[f"CGST{perc_half}"] = 0.00
                gst_dict[f"SGST{perc_half}"] = 0.00
                inv_taxes.append(dic)
                gst_split.append(gst_dict)

        item["sale_taxes"] = combine_taxes(inv_taxes)
        item["gst_taxes"] = combine_gst(gst_split)

        sale_data_final.append(item)



    total = []
    dic = {}
    total_tax = 0
    invoice_total = 0
    for j in sale_data_final:
        for x in j["sale_taxes"]:
            perc = x["percentage"]
            if f"{perc}% Sales Total" in dic.keys():
                dic[f"{perc}% Sales Total"] += x["perc_sale"]
            else:
                dic[f"{perc}% Sales Total"] = x["perc_sale"]

            if f"{perc}% Tax Total" in dic.keys():
                dic[f"{perc}% Tax Total"] += x["perc_tax"]
            else:
                dic[f"{perc}% Tax Total"] = x["perc_tax"]

            total_tax += x["perc_tax"]
            invoice_total += x["perc_sale"]

    sale_data_final = sorted(
        sale_data_final, key=lambda x: x["invoicedate"], reverse=True
    )

   

    data = {
        "data": sale_data_final,
        "total": dic,
        "total_tax": total_tax,
        "invoice_total": invoice_total + total_tax,
    }

    context = {
        "data": data,
        "taxes": taxes,
        "gsts": gsts,
        "all_branches": all_branches,
        "search_params": search_params,
    }

    # print("sale data final -- ",context)

    return render(request, "saletaxreport.html", context)


@login_required
def salereturntaxreport(request):
    current_user = request.user
    current_branch = current_user.userprofile.branch
    current_date = datetime.now().date()
    filters = Q()

    search_params = {
        "branch": "All",
        "start_date": date.today(),
        "end_date": date.today(),
    }

    # Handle POST request parameters
    if request.method == "POST":
        branch = request.POST.get("branch", None)
        startdate = request.POST.get("startdate", None)
        enddate = request.POST.get("enddate", None)

        if current_user.is_superuser and branch:
            filters &= Q(branch=branch)
            search_params["branch"] = Branch.objects.filter(id=int(branch)).first().name
        else:
            filters &= Q(branch=current_branch)

        if startdate:
            start_date = datetime.strptime(startdate, "%d-%m-%Y").date()
            filters &= Q(createddate__gte=start_date)
            search_params["start_date"] = start_date

        if enddate:
            end_date = datetime.strptime(enddate, "%d-%m-%Y").date()
            filters &= Q(createddate__lte=end_date)
            search_params["end_date"] = end_date
    else:
        filters &= Q(createddate=current_date)
        if not current_user.is_superuser:
            filters &= Q(branch=current_branch)

    # Query Sale data
    sale_data = (
        SaleReturn.objects.filter(filters)
        .values(
            "invoicenumber",
            "createddate",
            "customer",
            "nettotal",
            "totalamount",
            "branch",
            "totaltax",
            "discount",
            "salereturnid"
        )
        .annotate(quantity=Count("salereturnid"))
    )

    if current_user.is_superuser:
        all_branches = Branch.objects.filter(
            Q(branchtype="Own") | Q(branchtype="Franchise") | Q(name="WAREHOUSE")
        )
    else:
        all_branches = [current_branch]

    taxes = Tax.objects.values("percentage").distinct()
    taxes = [{"percentage": float(i["percentage"])} for i in taxes]

    gsts = []
    for t in taxes:
        gsts.append(f"CGST{t['percentage']/2}")
        gsts.append(f"SGST{t['percentage']/2}")

    sale_data_final = []

    for item in sale_data:
        inv_taxes = []
        gst_split = []
        tx_list = []

        if current_user.is_superuser:
            sale_obj = SaleReturn.objects.filter(salereturnid=item["salereturnid"])
        else:
            sale_obj = SaleReturn.objects.filter(
                Q(branch=current_branch) & Q(salereturnid=item["salereturnid"])
            )

        for i in sale_obj:
            sub_dict = {}
            gst_dict = {}
            tx = (
                Tax.objects.filter(Q(branch=i.branch) & Q(name=i.tax))
                .first()
                .percentage
            )
            try:
                sub_dict["discount"] = float(i.discount)
                gst_dict["discount"] = float(i.discount)
            except:
                sub_dict["discount"] = 0.00
                gst_dict["discount"] = 0.00
            sub_dict["percentage"] = float(tx)
            gst_dict["percentage"] = float(tx)
            gst_dict["totaltax"] = float(i.totaltax)


            ################################# 26/12/2024 #############################
            disc_pad=sub_dict['discount']
            finalamnt_pad = i.nettotal
            price_pad = i.rate
            price_after_discount = ((price_pad  - (price_pad  *((disc_pad/(finalamnt_pad+disc_pad))))))
            ##########################################################################

            # sub_dict["perc_sale"] = round(float(i.rate) * int(i.returnquantity ), 2)

            sub_dict["perc_sale"] = round(float(price_after_discount) * int(i.returnquantity ), 2)


            # sub_dict["perc_tax"] = round(
            #     round((float(i.rate) * (int(tx) / 100)), 2) * int(i.returnquantity ), 2
            # )
            sub_dict["perc_tax"] = round(
                round((float(price_after_discount) * (int(tx) / 100)), 2) * int(i.returnquantity ), 2
            )

            sub_dict["totaltax"] = float(i.totaltax)

            # perc_tx = round(
            #     round((float(i.rate) * (int(tx) / 100)), 2) * int(i.returnquantity ), 2
            # )

            perc_tx = round(
                round((float(price_after_discount) * (int(tx) / 100)), 2) * int(i.returnquantity ), 2
            )


            inv_taxes.append(sub_dict)
            tx_list.append(float(tx))
            gst_split.append(gst_dict)

        # calculate the amount tat should be deducted from each product total
        no_of_products = len(tx_list)
   
        # for j in inv_taxes:
        #     amount_to_deduct = j["discount"] / no_of_products
        #     j["perc_sale"] = j["perc_sale"] - amount_to_deduct

        for x in taxes:
            if float(x["percentage"]) not in tx_list:
                dic = {}
                gst_dict = {}
                dic["discount"] = 0.00
                dic["percentage"] = float(x["percentage"])
                dic["perc_tax"] = 0.00
                dic["perc_sale"] = 0.00
                gst_dict["percentage"] = float(x["percentage"])
                inv_taxes.append(dic)
                gst_split.append(gst_dict)

        item["sale_taxes"] = combine_taxes(inv_taxes)

        sale_data_final.append(item)

    total = []
    dic = {}
    total_tax = 0
    invoice_total = 0
    for j in sale_data_final:
        for x in j["sale_taxes"]:
            perc = x["percentage"]
            if f"{perc}% Sales Return Total" in dic.keys():
                dic[f"{perc}% Sales Return Total"] += x["perc_sale"]
            else:
                dic[f"{perc}% Sales Return Total"] = x["perc_sale"]

            if f"{perc}% Tax Total" in dic.keys():
                dic[f"{perc}% Tax Total"] += x["perc_tax"]
            else:
                dic[f"{perc}% Tax Total"] = x["perc_tax"]

            total_tax += x["perc_tax"]
            invoice_total += x["perc_sale"]

    sale_data_final = sorted(
        sale_data_final, key=lambda x: x["createddate"], reverse=True
    )

    data = {
        "data": sale_data_final,
        "total": dic,
        "total_tax": total_tax,
        "invoice_total": invoice_total + total_tax,
    }



    context = {
        "data": data,
        "taxes": taxes,
        "gsts": gsts,
        "all_branches": all_branches,
        "search_params": search_params,
    }


    return render(request, "salereturntaxreport.html", context)


# SG-33
@login_required
def purchasetaxreport(request):
    # branch =None
    current_user = request.user
    current_branch = current_user.userprofile.branch
    current_date = datetime.now().date()
    filters = Q()

    search_params = {
        "branch": "All",
        "start_date": date.today(),
        "end_date": date.today(),
    }

    if request.method == "POST":
        branch = request.POST.get("branch", None)
        startdate = request.POST.get("startdate", None)
        enddate = request.POST.get("enddate", None)

        if current_user.is_superuser and branch:
            filters &= Q(branch=branch)
            search_params["branch"] = Branch.objects.filter(id=int(branch)).first().name
        else:
            filters &= Q(branch=current_branch)

        if startdate:
            start_date = datetime.strptime(startdate, "%d-%m-%Y").date()
            filters &= Q(invoicedate__gte=start_date)
            search_params["start_date"] = start_date

        if enddate:
            end_date = datetime.strptime(enddate, "%d-%m-%Y").date()
            filters &= Q(invoicedate__lte=end_date)
            search_params["end_date"] = end_date
    else:
        filters &= Q(invoicedate=current_date)
        if not current_user.is_superuser:
            filters &= Q(branch=current_branch)

    # Puchase details of WAREHOUSE is saving in Purchase modal and purchase details of all other branches saving in BranchPurchase modal
    purchase_data = (
        BranchPurchase.objects.filter(filters)
        .values(
            "invoicenumber",
            "invoicedate",
            "externalsupplier",
            "totalbillingamount",
            "totalamount",
            "branch",
            "totaltax",
            "discount",
            "purchaseid",
            "purchase_type",
            "discountmethod"
        )
        .annotate(quantity=Count("purchaseid"))
    )

    purchase_data_warehouse = (
        Purchase.objects.filter(filters)
        .values(
            "invoicenumber",
            "invoicedate",
            "supplier",
            "totalbillingamount",
            "totalamount",
            "branch",
            "totaltax",
            "discount",
            "purchaseid",
            "purchase_type",
            "discountmethod"
        )
        .annotate(quantity=Count("purchaseid"))
    )

    purchase_data_2 = []
    for p_data in purchase_data:
        if (
            p_data["purchase_type"] == "stockadd"
            or p_data["purchase_type"] == "transfer"
        ):
            pass
        else:
            dic = {}
            dic["invoicenumber"] = p_data["invoicenumber"]
            dic["invoicedate"] = p_data["invoicedate"]
            dic["supplier"] = p_data["externalsupplier"]
            dic["totalbillingamount"] = p_data["totalbillingamount"]
            dic["totalamount"] = p_data["totalamount"]
            dic["branch"] = p_data["branch"]
            dic["totaltax"] = p_data["totaltax"]
            dic["discount"] = p_data["discount"]
            dic["discountmethod"] = p_data["discountmethod"]
            dic["purchaseid"] = p_data["purchaseid"]
            dic["quantity"] = p_data["quantity"]
            purchase_data_2.append(dic)

    for p_data in purchase_data_warehouse:
        if (
            p_data["purchase_type"] == "stockadd"
            or p_data["purchase_type"] == "transfer"
        ):
            pass
        else:
            dic = {}
            dic["invoicenumber"] = p_data["invoicenumber"]
            dic["invoicedate"] = p_data["invoicedate"]
            dic["supplier"] = p_data["supplier"]
            dic["totalbillingamount"] = p_data["totalbillingamount"]
            dic["totalamount"] = p_data["totalamount"]
            dic["branch"] = p_data["branch"]
            dic["totaltax"] = p_data["totaltax"]
            dic["discount"] = p_data["discount"]
            dic["discountmethod"] = p_data["discountmethod"]
            dic["purchaseid"] = p_data["purchaseid"]
            dic["quantity"] = p_data["quantity"]
            purchase_data_2.append(dic)

    if current_user.is_superuser:
        all_branches = Branch.objects.filter(
            Q(branchtype="Own") | Q(branchtype="Franchise") | Q(name="WAREHOUSE")
        )
    else:
        all_branches = [current_branch]

    taxes = Tax.objects.values("percentage").distinct()
    taxes = [{"percentage": float(i["percentage"])} for i in taxes]

    gsts = []
    for t in taxes:
        gsts.append(f"CGST{t['percentage']/2}")
        gsts.append(f"SGST{t['percentage']/2}")

    purchase_data_final = []

    for item in purchase_data_2:
        try:
            branch_name = Branch.objects.filter(id=int(item["branch"])).first().name
            item["branch"] = branch_name
        except:
            item["branch"] = ""

        try:
            supplier_name = (
                Suppliers.objects.filter(id=int(item["supplier"])).first().name
            )
            item["supplier"] = supplier_name
        except:
            item["supplier"] = ""

        if not item["totaltax"]:
            item["totaltax"] = 0
        item["value_of_goods"] = round(
            float(item["totalbillingamount"] - item["totaltax"]), 2
        )

        inv_taxes = []
        gst_split = []
        tx_list = []

        # Puchase details of WAREHOUSE is saving in Purchase modal and purchase details of all other branches saving in BranchPurchase modal
        if current_user.is_superuser:
            pur_obj = BranchPurchase.objects.filter(purchaseid=item["purchaseid"])
            if not pur_obj:
                pur_obj = Purchase.objects.filter(purchaseid=item["purchaseid"])
        else:
            pur_obj = BranchPurchase.objects.filter(
                Q(branch=current_branch) & Q(purchaseid=item["purchaseid"])
            )

        purchase_type = ""
        for i in pur_obj:
            if i.purchase_type == "transfer" or i.purchase_type == "stockadd":
                purchase_type = i.purchase_type
                continue
            sub_dict = {}
            gst_dict = {}
            tx = (
                Tax.objects.filter(Q(branch=i.branch) & Q(name=i.purchasegst))
                .first()
                .percentage
            )
            try:
                # sub_dict["discount"] = float(i.discount)
                # gst_dict["discount"] = float(i.discount)
                ######### added on 26/08/2024 #######
                if i.discountmethod == 'flat':
                    sub_dict["discount"] = float(i.discount)
                    gst_dict["discount"] = float(i.discount)
                elif i.discountmethod == 'percentage':
                    disc = (float(i.totalamount)*(float(i.discount)/100))

                    sub_dict["discount"] = float(disc)
                    gst_dict["discount"] = float(disc)
                    item['discount'] = disc
                else:
                    sub_dict["discount"] = 0.00
                    gst_dict["discount"] = 0.00
                #####################################
            except:
                sub_dict["discount"] = 0.00
                gst_dict["discount"] = 0.00

            sub_dict["percentage"] = float(tx)

            gst_dict["percentage"] = float(tx)
            gst_dict["totaltax"] = float(i.totaltax)


            disc_pad=sub_dict['discount']
            finalamnt_pad = i.totalbillingamount
            price_pad = i.price
            price_after_discount = ((price_pad  - (price_pad  *((disc_pad/(finalamnt_pad+disc_pad))))))
            sub_dict["perc_purchase"] = round(float(price_after_discount) * int(i.totalquantity), 2)
   

            # sub_dict["perc_purchase"] = round(float(i.price) * int(i.totalquantity), 2)



            # sub_dict["perc_tax"] = round(
            #     round((float(i.price) * (int(tx) / 100)), 2) * int(i.totalquantity), 2
            # )

            sub_dict["perc_tax"] = round(
                round((float(price_after_discount) * (int(tx) / 100)), 2) * int(i.totalquantity), 2
            )


            sub_dict["totaltax"] = float(i.totaltax)

            # perc_tx = round(
            #     round((float(i.price) * (int(tx) / 100)), 2) * int(i.totalquantity), 2
            # )

            perc_tx = round(
                round((float(price_after_discount) * (int(tx) / 100)), 2) * int(i.totalquantity), 2
            )

            gst_dict[f"CGST{float(tx)/2}"] = round(perc_tx / 2, 2)
            gst_dict[f"SGST{float(tx)/2}"] = round(perc_tx / 2, 2)

            inv_taxes.append(sub_dict)
            tx_list.append(float(tx))
            gst_split.append(gst_dict)

        if purchase_type == "stockadd" or purchase_type == "transfer":
            continue

        no_of_products = len(tx_list)

        # for j in inv_taxes:
        #     amount_to_deduct = j["discount"] / no_of_products
        #     j["perc_purchase"] = j["perc_purchase"] - amount_to_deduct
            

        for x in taxes:
            if float(x["percentage"]) not in tx_list:
                dic = {}
                gst_dict = {}
                dic["discount"] = 0.00
                dic["percentage"] = float(x["percentage"])
                dic["perc_tax"] = 0.00
                dic["perc_purchase"] = 0.00
                gst_dict["percentage"] = float(x["percentage"])
                perc_half = float(x["percentage"]) / 2
                gst_dict[f"CGST{perc_half}"] = 0.00
                gst_dict[f"SGST{perc_half}"] = 0.00
                inv_taxes.append(dic)
                gst_split.append(gst_dict)

        item["purchase_taxes"] = combine_taxes_purchase(inv_taxes)
        item["gst_taxes"] = combine_gst(gst_split)

        purchase_data_final.append(item)

    dic = {}
    total_tax = 0
    invoice_total = 0
    for j in purchase_data_final:
        for x in j["purchase_taxes"]:
            perc = x["percentage"]
            if f"{perc}% Purchase" in dic.keys():
                dic[f"{perc}% Purchase Total"] += x["perc_purchase"]
            else:
                dic[f"{perc}% Purchase Total"] = x["perc_purchase"]

            if f"{perc}% Tax" in dic.keys():
                dic[f"{perc}% Tax Total"] += x['perc_tax']
            else:
                dic[f"{perc}% Tax Total"] = x['perc_tax']

            total_tax += x["perc_tax"]
            invoice_total += x["perc_purchase"]

    purchase_data_final = sorted(
        purchase_data_final, key=lambda x: x["invoicedate"], reverse=True
    )

    dic2 = {}
    for item in purchase_data_final:
        for item2 in item["gst_taxes"]:
            for key, value in item2.items():
                if key in dic2.keys():
                    dic2[key] += value
                else:
                    dic2[key] = value
    if "percentage" in dic2.keys():
        del dic2["percentage"]
        del dic2["discount"]
    dic.update(dic2)

    data = {
        "data": purchase_data_final,
        "total": dic,
        "total_tax": total_tax,
        "invoice_total": invoice_total + total_tax,
    }

    context = {
        "data": data,
        "gst_values": dic,
        "taxes": taxes,
        "gsts": gsts,
        "all_branches": all_branches,
        "search_params": search_params,
    }

    print("\n\n purchase tax report - ", context)


    return render(request, "purchasetaxreport.html", context)


@login_required
def purchasereturntaxreport(request):

    current_user = request.user
    current_branch = current_user.userprofile.branch
    current_date = datetime.now().date()
    filters = Q()

    search_params = {
        "branch": "All",
        "start_date": date.today(),
        "end_date": date.today(),
    }

    if request.method == "POST":
        branch = request.POST.get("branch", None)
        startdate = request.POST.get("startdate", None)
        enddate = request.POST.get("enddate", None)

        if current_user.is_superuser and branch:
            filters &= Q(branch=branch)
            search_params["branch"] = Branch.objects.filter(id=int(branch)).first().name
        else:
            filters &= Q(branch=current_branch)

        if startdate:
            start_date = datetime.strptime(startdate, "%d-%m-%Y").date()
            filters &= Q(createddate__gte=start_date)
            search_params["start_date"] = start_date

        if enddate:
            end_date = datetime.strptime(enddate, "%d-%m-%Y").date()
            filters &= Q(createddate__lte=end_date)
            search_params["end_date"] = end_date
    else:
        filters &= Q(createddate=current_date)
        if not current_user.is_superuser:
            filters &= Q(branch=current_branch)
    filters &= Q(status="Processed")

    purchase_return_data = (
        PurchaseReturn.objects.filter(filters)
        .values(
            "invoicenumber",
            "createddate",
            "externalsupplier",
            "nettotal",
            "totalamount",
            "branch",
            "totaltax",
            "adjustment",
            "purchasereturnid",
        )
        .annotate(quantity=Count("purchasereturnid"))
    )

    purchase_data_2 = []
    for p_data in purchase_return_data:
        dic = {}
        dic["createddate"] = p_data["createddate"]
        dic["invoicenumber"] = p_data["invoicenumber"]
        dic["supplier"] = p_data["externalsupplier"]
        dic["nettotal"] = p_data["nettotal"]
        dic["totalamount"] = p_data["totalamount"]
        dic["branch"] = p_data["branch"]
        dic["totaltax"] = p_data["totaltax"]
        dic["adjustment"] = p_data["adjustment"]
        dic["purchasereturnid"] = p_data["purchasereturnid"]
        dic["quantity"] = p_data["quantity"]
        purchase_data_2.append(dic)

    if current_user.is_superuser:
        all_branches = Branch.objects.filter(
            Q(branchtype="Own") | Q(branchtype="Franchise") | Q(name="WAREHOUSE")
        )
    else:
        all_branches = [current_branch]

    taxes = Tax.objects.values("percentage").distinct()
    taxes = [{"percentage": float(i["percentage"])} for i in taxes]

    gsts = []
    for t in taxes:
        gsts.append(f"CGST{t['percentage']/2}")
        gsts.append(f"SGST{t['percentage']/2}")

    purchase_data_final = []

    for item in purchase_data_2:
        try:
            branch_name = Branch.objects.filter(id=int(item["branch"])).first().name
            item["branch"] = branch_name
        except:
            item["branch"] = ""

        try:
            supplier_name = (
                Suppliers.objects.filter(id=int(item["supplier"])).first().name
            )
            item["supplier"] = supplier_name
        except:
            item["supplier"] = ""

        if not item["totaltax"]:
            item["totaltax"] = 0
        item["value_of_goods"] = round(float(item["nettotal"] - item["totaltax"]), 2)

        inv_taxes = []
        gst_split = []
        tx_list = []

        if current_user.is_superuser:
            pur_obj = PurchaseReturn.objects.filter(
                purchasereturnid=item["purchasereturnid"]
            )

        else:
            pur_obj = PurchaseReturn.objects.filter(
                Q(branch=current_branch) & Q(purchasereturnid=item["purchasereturnid"])
            )

        for i in pur_obj:

            sub_dict = {}
            gst_dict = {}
            tx = (
                Tax.objects.filter(Q(branch=i.branch) & Q(name=i.tax.name))
                .first()
                .percentage
            )
            try:
                sub_dict["adjustment"] = float(i.adjustment)
                gst_dict["adjustment"] = float(i.adjustment)
            except:
                sub_dict["adjustment"] = 0.00
                gst_dict["adjustment"] = 0.00

            sub_dict["percentage"] = float(tx)

            gst_dict["percentage"] = float(tx)
            gst_dict["totaltax"] = float(i.totaltax)


            ################################# 26/12/2024 #############################
            disc_pad=sub_dict['adjustment']
            finalamnt_pad = i.nettotal
            price_pad = i.rate
            price_after_discount = ((price_pad  - (price_pad  *((disc_pad/(finalamnt_pad+disc_pad))))))
            ##########################################################################


            # sub_dict["perc_purchase"] = round(float(i.rate) * int(i.returnquantity), 2)
            sub_dict["perc_purchase"] = round(float(price_after_discount) * int(i.returnquantity), 2)

            # sub_dict["perc_tax"] = round(
            #     round((float(i.rate) * (int(tx) / 100)), 2) * int(i.returnquantity), 2
            # )
            sub_dict["perc_tax"] = round(
                round((float(price_after_discount) * (int(tx) / 100)), 2) * int(i.returnquantity), 2
            )

            sub_dict["totaltax"] = float(i.totaltax)

            # perc_tx = round(
            #     round((float(i.rate) * (int(tx) / 100)), 2) * int(i.returnquantity), 2
            # )
            perc_tx = round(
                round((float(price_after_discount) * (int(tx) / 100)), 2) * int(i.returnquantity), 2
            )

            gst_dict[f"CGST{float(tx)/2}"] = round(perc_tx / 2, 2)
            gst_dict[f"SGST{float(tx)/2}"] = round(perc_tx / 2, 2)

            inv_taxes.append(sub_dict)
            tx_list.append(float(tx))
            gst_split.append(gst_dict)

        no_of_products = len(tx_list)
        # for j in inv_taxes:
        #     amount_to_deduct = j["adjustment"] / no_of_products
        #     j["perc_purchase"] = j["perc_purchase"] - amount_to_deduct

        for x in taxes:
            if float(x["percentage"]) not in tx_list:
                dic = {}
                gst_dict = {}
                dic["adjustment"] = 0.00
                dic["percentage"] = float(x["percentage"])
                dic["perc_tax"] = 0.00
                dic["perc_purchase"] = 0.00
                gst_dict["percentage"] = float(x["percentage"])
                perc_half = float(x["percentage"]) / 2
                gst_dict[f"CGST{perc_half}"] = 0.00
                gst_dict[f"SGST{perc_half}"] = 0.00
                inv_taxes.append(dic)
                gst_split.append(gst_dict)

        item["purchase_taxes"] = combine_taxes_purchase(inv_taxes)
        item["gst_taxes"] = combine_gst_purchase_return(gst_split)

        purchase_data_final.append(item)

    dic = {}
    total_tax = 0
    invoice_total = 0
    for j in purchase_data_final:
        for x in j["purchase_taxes"]:
            perc = x["percentage"]
            if f"{perc}% Purchase Return Total" in dic.keys():
                dic[f"{perc}% Purchase Return Total"] += x["perc_purchase"]
            else:
                dic[f"{perc}% Purchase Return Total"] = x["perc_purchase"]

            if f"{perc}% P-Return Tax Total" in dic.keys():
                dic[f"{perc}% P-Return Tax Total"] += x["perc_purchase"]
            else:
                dic[f"{perc}% P-Return Tax Total"] = x["perc_purchase"]

            total_tax += x["perc_tax"]
            invoice_total += x["perc_purchase"]

    purchase_data_final = sorted(
        purchase_data_final, key=lambda x: x["createddate"], reverse=True
    )

    dic2 = {}
    for item in purchase_data_final:
        for item2 in item["gst_taxes"]:

            for key, value in item2.items():
                if key in dic2.keys():
                    dic2[key] += value
                else:
                    dic2[key] = value
    if "percentage" in dic2.keys():
        del dic2["percentage"]
        del dic2["adjustment"]
    dic.update(dic2)

    data = {
        "data": purchase_data_final,
        "total": dic,
        "total_tax": total_tax,
        "invoice_total": invoice_total + total_tax,
    }

    context = {
        "data": data,
        "gst_values": dic,
        "taxes": taxes,
        "gsts": gsts,
        "all_branches": all_branches,
        "search_params": search_params,
    }


    print("purchase return total tax - ",context)

    return render(request, "purchasereturntaxreport.html", context)


# SG-16
@login_required
def editlivestreamurl(request):

    url = request.POST.get("url", None)

    url_obj = LiveStreamUrl.objects.all().first()
    if not url_obj:
        url_obj = LiveStreamUrl()
    url_obj.url = url
    url_obj.save()

    return redirect("servicesettings")


@login_required
def deleteLivestreamUrl(request, url_id):

    url_obj = LiveStreamUrl.objects.filter(id=int(url_id)).first()
    url_obj.delete()

    countries = Country.objects.all()
    cities = City.objects.all()
    products = ServiceProduct.objects.all()
    brands = PhoneBrand.objects.all()
    modals = PhoneModal.objects.all()
    serviceissues = ServiceIssues.objects.all()
    charges = ServiceCharge.objects.all()
    rack_nos = Rack.objects.filter(branch=request.user.userprofile.branch)
    servicetax = ServiceTax.objects.all().first()
    url = LiveStreamUrl.objects.all().first()

    context = {
        "countries": countries,
        "cities": cities,
        "brands": brands,
        "modals": modals,
        "issues": serviceissues,
        "charges": charges,
        "racks": rack_nos,
        "servicetax": servicetax,
        "products": products,
        "url": url,
    }
    return render(request, "servicesettings.html", context)


# SG-25
@login_required
def servicetaxreport(request):
    current_user = request.user
    current_branch = current_user.userprofile.branch
    current_date = datetime.now().date()
    filters = Q()

    search_params = {
        "branch": "All",
        "start_date": date.today(),
        "end_date": date.today(),
    }

    # Handle POST request parameters
    if request.method == "POST":
        branch = request.POST.get("branch", None)
        startdate = request.POST.get("startdate", None)
        enddate = request.POST.get("enddate", None)

        if current_user.is_superuser and branch:
            filters &= Q(branch=branch)
            search_params["branch"] = Branch.objects.filter(id=int(branch)).first().name
        else:
            filters &= Q(branch=current_branch)

        if startdate:
            start_date = datetime.strptime(startdate, "%d-%m-%Y").date()
            filters &= Q(modifieddate__gte=start_date)
            search_params["start_date"] = start_date

        if enddate:
            end_date = datetime.strptime(enddate, "%d-%m-%Y").date()
            filters &= Q(modifieddate__lte=end_date)
            search_params["end_date"] = end_date
    else:
        filters &= Q(modifieddate=current_date)
        if not current_user.is_superuser:
            filters &= Q(branch=current_branch)
    filters &= Q(status="Delivered(Ok)")

    # Query Service data
    service_data = Service.objects.filter(filters).values(
        "servicerefnumber",
        "memodate",
        "firstname",
        "lastname",
        "servicecharge",
        "branch",
        "servicetax",
        "modifieddate",
        "discount",
        "totalamount",
        "finalamount",
        "totaltax",
        "invoicenumber",
    )

    if current_user.is_superuser:
        all_branches = Branch.objects.filter(
            Q(branchtype="Own") | Q(branchtype="Franchise") | Q(name="WAREHOUSE")
        )
    else:
        all_branches = [current_branch]

    taxes = (
        Service.objects.filter(filters).values_list("servicetax", flat=True).distinct()
    )
    taxes = [{"percentage": float(i)} for i in taxes]

    gsts = []
    for t in taxes:
        gsts.append(f"CGST{t['percentage']/2}")
        gsts.append(f"SGST{t['percentage']/2}")

    service_data_final = []
    service_total_combined = 0
    for item in service_data:
        inv_taxes = []
        gst_split = []
        tx_list = []

        if current_user.is_superuser:
            service_obj = Service.objects.filter(
                servicerefnumber=item["servicerefnumber"]
            )
        else:
            service_obj = Service.objects.filter(
                Q(branch=current_branch) & Q(servicerefnumber=item["servicerefnumber"])
            )

        item["total"] = float(item["servicecharge"]) 
        service_total_combined += float(item["servicecharge"]) 
        item["totaltaxamount"] = item["totaltax"] 
        item["totalamount"] = item["totalamount"] 

        for i in service_obj:
            sub_dict = {}
            gst_dict = {}
            tx = i.servicetax
            # try:
            #     sub_dict['discount'] = float(i.discount)
            #     gst_dict['discount'] = float(i.discount)
            # except:
            #     sub_dict['discount'] = 0.00
            #     gst_dict['discount'] = 0.00
            # sub_dict['branch'] = i.branch

            sub_dict["percentage"] = float(tx)
            gst_dict["percentage"] = float(tx)
            gst_dict["totaltax"] = float(i.servicecharge) -  (float(i.servicecharge) / (1 + (float(tx) / 100))) 
            sub_dict["perc_sale"] = float(i.servicecharge) - float(item["totaltax"]) 
            sub_dict["perc_tax"] = float(i.servicecharge) -  (float(i.servicecharge) / (1 + (float(tx) / 100))) 
            sub_dict["totaltax"] = float(i.servicecharge) -  (float(i.servicecharge) / (1 + (float(tx) / 100))) 
            # gst_dict[f'CGST{float(tx)/2}'] = round(round(float(i.price)*int(i.totalquantity),2)/2,2)
            # gst_dict[f'SGST{float(tx)/2}'] = round(round(float(i.price)*int(i.totalquantity),2)/2,2)
            perc_tx = float(i.servicecharge) -  (float(i.servicecharge) / (1 + (float(tx) / 100))) 
            gst_dict[f"CGST{float(tx)/2}"] = round(perc_tx / 2, 2)
            gst_dict[f"SGST{float(tx)/2}"] = round(perc_tx / 2, 2)

            inv_taxes.append(sub_dict)
            tx_list.append(float(tx))
            gst_split.append(gst_dict)

        # calculate the amount tat should be deducted from each product total
        # no_of_products = len(tx_list)
        # for j in inv_taxes:
        #     amount_to_deduct = j['discount']/no_of_products
        #     j['perc_sale'] =j['perc_sale'] - amount_to_deduct

        for x in taxes:
            if float(x["percentage"]) not in tx_list:
                dic = {}
                gst_dict = {}
                # dic['discount'] = 0.00
                dic["percentage"] = float(x["percentage"])
                dic["perc_tax"] = 0.00
                dic["perc_sale"] = 0.00
                gst_dict["percentage"] = float(x["percentage"])
                perc_half = float(x["percentage"]) / 2
                gst_dict[f"CGST{perc_half}"] = 0.00
                gst_dict[f"SGST{perc_half}"] = 0.00
                inv_taxes.append(dic)
                gst_split.append(gst_dict)

        item["sale_taxes"] = combine_taxes(inv_taxes)
        item["gst_taxes"] = combine_gst(gst_split)

        service_data_final.append(item)

    total = []
    dic = {}
    total_tax = 0
    invoice_total = 0
    for j in service_data_final:
        for x in j["sale_taxes"]:
            perc = x["percentage"]
            if f"{perc}% Service Total" in dic.keys():
                dic[f"{perc}% Service Total"] += x["perc_sale"]
            else:
                dic[f"{perc}% Service Total"] = x["perc_sale"]

            if f"{perc}% Tax Total" in dic.keys():
                dic[f"{perc}% Tax Total"] += x["perc_tax"]
            else:
                dic[f"{perc}% Tax Total"] = x["perc_tax"]

            total_tax += x["perc_tax"]
            invoice_total += x["perc_sale"]

    service_data_final = sorted(
        service_data_final, key=lambda x: x["memodate"], reverse=True
    )

   

    data = {
        "data": service_data_final,
        "total": dic,
        "total_tax": total_tax,
        "invoice_total": invoice_total ,
        "service_total_combined":service_total_combined
    }

    context = {
        "data": data,
        "taxes": taxes,
        "gsts": gsts,
        "all_branches": all_branches,
        "search_params": search_params,
    }



    return render(request, "servicetaxreport.html", context)


# SG-25
@login_required
def sparetaxreport(request):
    current_user = request.user
    current_branch = current_user.userprofile.branch
    current_date = datetime.now().date()
    filters = Q()

    search_params = {
        "branch": "All",
        "start_date": date.today(),
        "end_date": date.today(),
    }

    # Handle POST request parameters
    if request.method == "POST":
        branch = request.POST.get("branch", None)
        startdate = request.POST.get("startdate", None)
        enddate = request.POST.get("enddate", None)

        if current_user.is_superuser and branch:
            filters &= Q(branch=branch)
            search_params["branch"] = Branch.objects.filter(id=int(branch)).first().name
        else:
            filters &= Q(branch=current_branch)

        if startdate:
            start_date = datetime.strptime(startdate, "%d-%m-%Y").date()
            filters &= Q(modifieddate__gte=start_date)
            search_params["start_date"] = start_date

        if enddate:
            end_date = datetime.strptime(enddate, "%d-%m-%Y").date()
            filters &= Q(modifieddate__lte=end_date)
            search_params["end_date"] = end_date
    else:
        filters &= Q(modifieddate=current_date)
        if not current_user.is_superuser:
            filters &= Q(branch=current_branch)
    filters &= Q(status="Delivered(Ok)")

    # Query Service data
    service_data = Service.objects.filter(filters).values(
        "servicerefnumber",
        "memodate",
        "firstname",
        "lastname",
        "servicecharge",
        "branch",
        "servicetax",
        "modifieddate",
        "discount",
        "totalamount",
        "finalamount",
        "totaltax",
        "invoicenumber",
    )

    if current_user.is_superuser:
        all_branches = Branch.objects.filter(
            Q(branchtype="Own") | Q(branchtype="Franchise") | Q(name="WAREHOUSE")
        )
    else:
        all_branches = [current_branch]

    taxes = Tax.objects.values("percentage").distinct()
    taxes = [{"percentage": float(i["percentage"])} for i in taxes]

    gsts = []
    for t in taxes:
        gsts.append(f"CGST{t['percentage']/2}")
        gsts.append(f"SGST{t['percentage']/2}")

    spare_data_final = []

    for item in service_data:
        item["totalamount"] = item["totalamount"] 
        inv_taxes = []
        gst_split = []
        tx_list = []
        if current_user.is_superuser:
            spare_obj = SpareParts.objects.filter(
                servicerefnumber=item["servicerefnumber"]
            )
        else:
            spare_obj = SpareParts.objects.filter(
                Q(branch=current_branch) & Q(servicerefnumber=item["servicerefnumber"])
            )

        # item['total'] = float(item['servicecharge']) + (float(item['servicecharge']) * float(item['servicetax'])/100)
        # item['totaltax'] = (float(item['servicecharge']) * float(item['servicetax'])/100)

        if len(spare_obj) == 0:
            continue

        for i in spare_obj:

            sub_dict = {}
            gst_dict = {}
            tx = float(i.salegst)
            # try:
            #     sub_dict['discount'] = float(i.discount)
            #     gst_dict['discount'] = float(i.discount)
            # except:
            #     sub_dict['discount'] = 0.00
            #     gst_dict['discount'] = 0.00
            # sub_dict['branch'] = i.branch
            sub_dict["percentage"] = float(tx)
            gst_dict["percentage"] = float(tx)
            # gst_dict['totaltax']=float(i.totaltax)
            sub_dict["perc_sale"] = round(float(i.price) * int(i.totalquantity), 2)
            sub_dict["perc_tax"] = round(
                round((float(i.price) * (int(tx) / 100)), 2) * int(i.totalquantity), 2
            )
            # sub_dict['totaltax']=float(i.totaltax)
            # gst_dict[f'CGST{float(tx)/2}'] = round(round(float(i.price)*int(i.totalquantity),2)/2,2)
            # gst_dict[f'SGST{float(tx)/2}'] = round(round(float(i.price)*int(i.totalquantity),2)/2,2)
            perc_tx = round(
                round((float(i.price) * (int(tx) / 100)), 2) * int(i.totalquantity), 2
            )
            gst_dict[f"CGST{float(tx)/2}"] = round(perc_tx / 2, 2)
            gst_dict[f"SGST{float(tx)/2}"] = round(perc_tx / 2, 2)

            inv_taxes.append(sub_dict)
            tx_list.append(float(tx))
            gst_split.append(gst_dict)

        # calculate the amount tat should be deducted from each product total
        # no_of_products = len(tx_list)
        # for j in inv_taxes:
        #     amount_to_deduct = j['discount']/no_of_products
        #     j['perc_sale'] =j['perc_sale'] - amount_to_deduct

        for x in taxes:
            if float(x["percentage"]) not in tx_list:
                dic = {}
                gst_dict = {}

                dic["percentage"] = float(x["percentage"])
                dic["perc_tax"] = 0.00
                dic["perc_sale"] = 0.00
                gst_dict["percentage"] = float(x["percentage"])
                perc_half = float(x["percentage"]) / 2
                gst_dict[f"CGST{perc_half}"] = 0.00
                gst_dict[f"SGST{perc_half}"] = 0.00
                inv_taxes.append(dic)
                gst_split.append(gst_dict)

        item["sale_taxes"] = combine_taxes(inv_taxes)
        item["gst_taxes"] = combine_gst(gst_split)

        spare_data_final.append(item)

    total = []
    dic = {}
    total_tax = 0
    invoice_total = 0
    for j in spare_data_final:
        for x in j["sale_taxes"]:
            perc = x["percentage"]
            if f"{perc}% Spare Total" in dic.keys():
                dic[f"{perc}% Spare Total"] += x["perc_sale"]
            else:
                dic[f"{perc}% Spare Total"] = x["perc_sale"]

            if f"{perc}% Tax Total" in dic.keys():
                dic[f"{perc}% Tax Total"] += x["perc_tax"]
            else:
                dic[f"{perc}% Tax Total"] = x["perc_tax"]

            total_tax += x["perc_tax"]
            invoice_total += x["perc_sale"]

    spare_data_ = sorted(
        spare_data_final, key=lambda x: x["modifieddate"], reverse=True
    )

    total_tax_combined = total_tax


    spare_data_final = []
    for sp in spare_data_:
        total_tax = 0
        total_sale = 0
        taxes = sp["sale_taxes"]
        for item in taxes:
            total_tax += float(item["perc_tax"])
            total_sale += float(item["perc_sale"])
            total_sale += float(item["perc_tax"])
        sp["total"] = total_sale
        sp["totaltaxamount"] = total_tax
        spare_data_final.append(sp)

    data = {
        "data": spare_data_final,
        "total": dic,
        "total_tax": total_tax_combined,
        "invoice_total": invoice_total + total_tax,
    }

    context = {
        "data": data,
        "taxes": taxes,
        "gsts": gsts,
        "all_branches": all_branches,
        "search_params": search_params,
    }




    return render(request, "sparetaxreport.html", context)


@login_required
def show_map(request, latitude, longitude):

    try:
        latitude = float(latitude)
        longitude = float(longitude)
    except:
        return redirect("servicebooking")

    context = {
        "latitude": latitude,
        "longitude": longitude,
    }

    return render(request, "map.html", context)




# detailed sales report
@login_required
def detailed_sales_report(request):

    user = request.user
    if request.method == 'POST':
        startdate =  request.POST['startdate']
        startdate = datetime.strptime(startdate, "%d-%m-%Y").date()
        enddate = request.POST['enddate']
        enddate = datetime.strptime(enddate, "%d-%m-%Y").date()
        branch = Branch.objects.filter(id=int(request.POST['branch'])).first()
    else:
        startdate = date.today()
        enddate = date.today()
        branch = user.userprofile.branch
    

    if user.is_superuser:

        sales_obj = Sale.objects.filter(Q(invoicedate__gte=startdate)&Q(invoicedate__lte=enddate)&Q(branch=branch)).order_by("-pk")

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) | Q(name="WAREHOUSE")
        )
    else:
        branch = user.userprofile.branch
        sales_obj = Sale.objects.filter(
            Q(Q(invoicedate__gte=startdate)&Q(invoicedate__lte=enddate)) & Q(branch=branch)
        ).order_by("-pk")

        all_branches = [user.userprofile.branch]


    saleid_set = set()
    sales_obj = [
        sale
        for sale in sales_obj
        if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
    ]

    
    #### calculate cost,tax,profile etc
    final_list = []
    total_sale_price=0
    total_purchase_cost = 0
    total_tax = 0
    total_profit = 0
    for items in sales_obj:
        dic={"products":'',
        'totalpurchasecost':0}
        sales = Sale.objects.filter(saleid=items.saleid)
        for count,sub_items in enumerate(sales):
            dic['saleid'] = items.saleid
            dic['customer'] = items.customer
            dic['invoicenumber'] = items.invoicenumber
            dic['products'] += f"{count+1}){sub_items.name.name},<br>"
            dic['totalsaleprice'] = items.amountrecieved
            dic['totalpurchasecost'] += round(((sub_items.purchase_price + (sub_items.purchase_price * (sub_items.purchase_tax/100)))*sub_items.totalquantity),2)
            dic['totaltax']=items.totaltax
            dic['profit']= round((dic['totalsaleprice'] - dic['totalpurchasecost'] - dic['totaltax']),2)
        total_sale_price += dic['totalsaleprice']
        total_purchase_cost += dic['totalpurchasecost']
        total_tax  += dic['totaltax']
        total_profit += dic['profit']
        final_list.append(dic)
    context = {
        "total_sale_price":round(total_sale_price,2),
        "total_purchase_cost":round(total_purchase_cost,2),
        "total_tax":round(total_tax,2),
        "total_profit":round(total_profit,2),
        "all_sales": final_list,
        "all_branches": all_branches,
        "selected_branch": user.userprofile.branch,
        "startdate":startdate,
        "enddate":enddate,
        "branch":branch
    }
    return render(request, "detailedsalesreport.html", context)








# detailed service report
@login_required
def detailed_service_report(request):

    user = request.user
    if request.method == 'POST':
        startdate =  request.POST['startdate']
        startdate = datetime.strptime(startdate, "%d-%m-%Y").date()
        enddate = request.POST['enddate']
        enddate = datetime.strptime(enddate, "%d-%m-%Y").date()
        branch = Branch.objects.filter(id=int(request.POST['branch'])).first()
    else:
        startdate = date.today()
        enddate = date.today()
        branch = user.userprofile.branch
    

    if user.is_superuser:

        service_obj = Service.objects.filter(Q(modifieddate__gte=startdate)&Q(modifieddate__lte=enddate)&Q(branch=branch)&Q(status="Delivered(Ok)")).order_by("-pk")

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) | Q(name="WAREHOUSE")
        )
    else:
        branch = user.userprofile.branch
        service_obj = Service.objects.filter(
            Q(Q(modifieddate__gte=startdate)&Q(modifieddate__lte=enddate)) & Q(branch=branch)&Q(status="Delivered(Ok)")
        ).order_by("-pk")

        all_branches = [user.userprofile.branch]


  

    
    #### calculate cost,tax,profile etc
    final_list = []
    total_service_income=0
    total_purchase_cost = 0
    total_tax = 0
    total_profit = 0
    for items in service_obj:
        dic={"spares":'',
        'totalpurchasecost':0,
        "totaltax":0,
        'totalserviceincome':0}
        
        dic['totaltax'] += items.totaltax 
        dic['totalserviceincome'] = items.amountrecieved
        dic['servicerefnumber'] = items.servicerefnumber
        dic['product'] = f"{items.brand} {items.model}"
        dic['customer'] = f"{items.firstname} {items.lastname}"

        spares = SpareParts.objects.filter(servicerefnumber=items.servicerefnumber)
        if spares:
            for count,sub_items in enumerate(spares):
                dic['spares'] += f"{count+1}){sub_items.name.name},<br>"
                dic['totalpurchasecost'] += round(((sub_items.purchase_price + (sub_items.purchase_price * (sub_items.purchase_tax/100)))*sub_items.totalquantity),2)
                sub_item_tax = (sub_items.price * (float(sub_items.salegst) / 100)) * sub_items.totalquantity
                dic['totaltax'] += round(sub_item_tax,2)
                dic['profit']= round((dic['totalserviceincome'] - dic['totalpurchasecost'] - dic['totaltax']),2)
        else:
            dic['profit']= round((dic['totalserviceincome'] - dic['totaltax']),2)
        total_service_income += dic['totalserviceincome']
        total_purchase_cost += dic['totalpurchasecost']
        total_tax  += dic['totaltax']
        total_profit += dic['profit']
        final_list.append(dic)


    context = {
        "total_service_income":round(total_service_income,2),
        "total_purchase_cost":round(total_purchase_cost,2),
        "total_tax":round(total_tax,2),
        "total_profit":round(total_profit,2),
        "all_sales": final_list,
        "all_branches": all_branches,
        "selected_branch": user.userprofile.branch,
        "startdate":startdate,
        "enddate":enddate,
        "branch":branch
    }
    return render(request, "detailedservicereport.html", context)











def func_cashbook_in_all_in_one_report(request):

    if request.method == "POST":
        try:
            startdate = request.POST["startdate"]
            ss = startdate
            startdate = datetime.strptime(startdate, "%d-%m-%Y")
            enddate = request.POST["enddate"]
            enddate = datetime.strptime(enddate, "%d-%m-%Y")
        except:
            startdate = date.today()
            enddate = date.today()

        if request.user.is_superuser:
            branch = request.POST["branch"]
        else:
            branch = request.user.userprofile.branch
    else:
        branch = request.user.userprofile.branch
        startdate = date.today()
        enddate = date.today()

    # Cash Transactions
    # Identify the opening balance
    # TBD : Multiple database query, needs to be replaced with pandas query
  
    try:
        all_cashbook_cash = CashBook.objects.filter(Q(branch=branch) & Q(mode="Cash"))
        df_cash_opening = pd.DataFrame.from_records(all_cashbook_cash.values())
        df_cash_opening["date"] = pd.to_datetime(
            df_cash_opening["date"], errors="coerce"
        )
        df_cash_opening = df_cash_opening.dropna(subset=["date"])
        filtered_df = df_cash_opening[
            df_cash_opening["date"] < pd.to_datetime(startdate)
        ]
        opening_cash_payment = filtered_df["payment"].sum()
        opening_cash_receipt = filtered_df["receipt"].sum()
    except:
        opening_cash_payment = 0
        opening_cash_receipt = 0

    if opening_cash_payment > opening_cash_receipt:
        opening_cash_balance = opening_cash_payment - opening_cash_receipt
        opening_cash_balance_type = "payment"

    else:
        opening_cash_balance = opening_cash_receipt - opening_cash_payment
        opening_cash_balance_type = "receipt"

    opening_cash_balance = round(opening_cash_balance, 2)

    cashbook_cash = CashBook.objects.filter(
        Q(branch=branch) & Q(date__range=(startdate, enddate)) & Q(mode="Cash")
    )

    
    excluded_value_cash = [
        "Purchase",
        "Sale",
        "Service",
        "Sale Return",
        "Purchase Return",
        "PAYMENT",
        "RECEIPT",
    ]
    cashbookother_cash = CashBook.objects.exclude(
        Q(branch=branch) & Q(mode="Cash") & Q(date__range=(startdate, enddate)),
        description__in=excluded_value_cash,
    )
    df_cash = pd.DataFrame.from_records(cashbook_cash.values())

    try:
        totalsale_cash = (
            df_cash[df_cash["description"] == "Sale"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        # convert the above dataframes into django query sets for all the dfs
        totalsaleqs_cash = totalsale_cash.to_dict(orient="records")
    except KeyError:
        totalsaleqs_cash = None
    try:
        totalpurchase_cash = (
            df_cash[df_cash["description"] == "Purchase"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalpurchaseqs_cash = totalpurchase_cash.to_dict(orient="records")
    except KeyError:
        totalpurchaseqs_cash = None
    try:
        totalservice_cash = (
            df_cash[df_cash["description"] == "Service"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalserviceqs_cash = totalservice_cash.to_dict(orient="records")
    except KeyError:
        totalserviceqs_cash = None
    try:
        totalsalereturn_cash = (
            df_cash[df_cash["description"] == "Sale Return"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalsalereturnqs_cash = totalsalereturn_cash.to_dict(orient="records")
    except KeyError:
        totalsalereturnqs_cash = None
    try:
        totalpurchasereturn_cash = (
            df_cash[df_cash["description"] == "Purchase Return"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalpurchasereturnqs_cash = totalpurchasereturn_cash.to_dict(orient="records")
    except KeyError:
        totalpurchasereturnqs_cash = None
    try:
        totalpayment_cash = (
            df_cash[df_cash["description"] == "PAYMENT"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalpaymentqs_cash = totalpayment_cash.to_dict(orient="records")
    except KeyError:
        totalpaymentqs_cash = None
    try:
        totalreceipt_cash = (
            df_cash[df_cash["description"] == "RECEIPT"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalreceiptqs_cash = totalreceipt_cash.to_dict(orient="records")
    except KeyError:
        totalreceiptqs_cash = None

    # Calculate the closing balance
    # TBD: add the filter and then identify the opening balance as well
    totalpaymentbalance_cash = 0
    totalreceiptbalance_cash = 0
    for item in cashbook_cash:
        totalpaymentbalance_cash += item.payment
        totalreceiptbalance_cash += item.receipt

    if opening_cash_balance_type == "payment":
        totalpaymentbalance_cash += opening_cash_balance
    elif opening_cash_balance_type == "receipt":
        totalreceiptbalance_cash += opening_cash_balance

    if totalpaymentbalance_cash > totalreceiptbalance_cash:
        balancetype_cash = "payment"
        closingbalance_cash = totalpaymentbalance_cash - totalreceiptbalance_cash
    else:
        balancetype_cash = "receipt"
        closingbalance_cash = totalreceiptbalance_cash - totalpaymentbalance_cash

    closingbalance_cash = round(closingbalance_cash, 2)



    # Get today's date and filter for today's cash receipts and payment
   
    total_today_receipt_cash = cashbook_cash.aggregate(
        total_today_receipt=Sum('receipt')
    )['total_today_receipt'] or 0

    total_today_payment_cash = cashbook_cash.aggregate(
        total_today_payment=Sum('payment')
    )['total_today_payment'] or 0

   

    # UPI Transactions
    # Identify the opening balance for UPI
    # TBD : Multiple database query, needs to be replaced with pandas query
    try:
        all_cashbook_upi = CashBook.objects.filter(Q(branch=branch) & Q(mode="UPI"))
        df_upi_opening = pd.DataFrame.from_records(all_cashbook_upi.values())
        df_upi_opening["date"] = pd.to_datetime(df_upi_opening["date"], errors="coerce")
        df_upi_opening = df_upi_opening.dropna(subset=["date"])
        filtered_df_upi = df_upi_opening[
            df_upi_opening["date"] < pd.to_datetime(startdate)
        ]
        opening_upi_payment = filtered_df_upi["payment"].sum()
        opening_upi_receipt = filtered_df_upi["receipt"].sum()
    except:
        opening_upi_payment = 0
        opening_upi_receipt = 0

    if opening_upi_payment > opening_upi_receipt:
        opening_upi_balance = opening_upi_payment - opening_upi_receipt
        opening_upi_balance_type = "payment"

    else:
        opening_upi_balance = opening_upi_receipt - opening_upi_payment
        opening_upi_balance_type = "receipt"

    opening_upi_balance = round(opening_upi_balance, 2)

    cashbook_upi = CashBook.objects.filter(
        Q(branch=branch) & Q(date__range=(startdate, enddate)) & Q(mode="UPI")
    )
    excluded_value_upi = [
        "Purchase",
        "Sale",
        "Service",
        "Sale Return",
        "Purchase Return",
        "PAYMENT",
        "RECEIPT",
    ]
    cashbookother_upi = CashBook.objects.exclude(
        Q(branch=branch) & Q(mode="UPI") & Q(date__range=(startdate, enddate)),
        description__in=excluded_value_upi,
    )
    df_upi = pd.DataFrame.from_records(cashbook_upi.values())

    try:
        totalsale_upi = (
            df_upi[df_upi["description"] == "Sale"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        # convert the above dataframes into django query sets for all the dfs
        totalsaleqs_upi = totalsale_upi.to_dict(orient="records")
    except KeyError:
        totalsaleqs_upi = None
    try:
        totalpurchase_upi = (
            df_upi[df_upi["description"] == "Purchase"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalpurchaseqs_upi = totalpurchase_upi.to_dict(orient="records")
    except KeyError:
        totalpurchaseqs_upi = None
    try:
        totalservice_upi = (
            df_upi[df_upi["description"] == "Service"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalserviceqs_upi = totalservice_upi.to_dict(orient="records")
    except KeyError:
        totalserviceqs_upi = None
    try:
        totalsalereturn_upi = (
            df_upi[df_upi["description"] == "Sale Return"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalsalereturnqs_upi = totalsalereturn_upi.to_dict(orient="records")
    except KeyError:
        totalsalereturnqs_upi = None
    try:
        totalpurchasereturn_upi = (
            df_upi[df_upi["description"] == "Purchase Return"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalpurchasereturnqs_upi = totalpurchasereturn_upi.to_dict(orient="records")
    except KeyError:
        totalpurchasereturnqs_upi = None
    try:
        totalpayment_upi = (
            df_upi[df_upi["description"] == "PAYMENT"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalpaymentqs_upi = totalpayment_upi.to_dict(orient="records")
    except KeyError:
        totalpaymentqs_upi = None
    try:
        totalreceipt_upi = (
            df_upi[df_upi["description"] == "RECEIPT"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalreceiptqs_upi = totalreceipt_upi.to_dict(orient="records")
    except KeyError:
        totalreceiptqs_upi = None

    # Calculate the closing balance
    # TBD: add the filter and then identify the opening balance as well
    totalpaymentbalance_upi = 0
    totalreceiptbalance_upi = 0
    for item in cashbook_upi:
        totalpaymentbalance_upi += item.payment
        totalreceiptbalance_upi += item.receipt

    if opening_upi_balance_type == "payment":
        totalpaymentbalance_upi += opening_upi_balance
    elif opening_upi_balance_type == "receipt":
        totalreceiptbalance_upi += opening_upi_balance

    if totalpaymentbalance_upi > totalreceiptbalance_upi:
        balancetype_upi = "payment"
        closingbalance_upi = totalpaymentbalance_upi - totalreceiptbalance_upi
    else:
        balancetype_upi = "receipt"
        closingbalance_upi = totalreceiptbalance_upi - totalpaymentbalance_upi

    closingbalance_upi = round(closingbalance_upi, 2)


    # Get today's date and filter for today's UPI receipts
    
    total_today_receipt_upi = cashbook_upi.aggregate(
        total_today_receipt=Sum('receipt')
    )['total_today_receipt'] or 0

    total_today_payment_upi = cashbook_upi.aggregate(
        total_today_payment=Sum('payment')
    )['total_today_payment'] or 0

    

    

    # Bank Transactions
    # Identify the opening balance for Bank
    # TBD : Multiple database query, needs to be replaced with pandas query
    try:
        all_cashbook_bank = CashBook.objects.filter(Q(branch=branch) & Q(mode="Bank"))
        df_bank_opening = pd.DataFrame.from_records(all_cashbook_bank.values())
        df_bank_opening["date"] = pd.to_datetime(
            df_bank_opening["date"], errors="coerce"
        )
        df_bank_opening = df_bank_opening.dropna(subset=["date"])
        filtered_df_bank = df_bank_opening[
            df_bank_opening["date"] < pd.to_datetime(startdate)
        ]
        opening_bank_payment = filtered_df_bank["payment"].sum()
        opening_bank_receipt = filtered_df_bank["receipt"].sum()
    except:
        opening_bank_payment = 0
        opening_bank_receipt = 0

    if opening_bank_payment > opening_bank_receipt:
        opening_bank_balance = opening_bank_payment - opening_bank_receipt
        opening_bank_balance_type = "payment"

    else:
        opening_bank_balance = opening_bank_receipt - opening_bank_payment
        opening_bank_balance_type = "receipt"

    opening_bank_balance = round(opening_bank_balance, 2)

    cashbook_bank = CashBook.objects.filter(
        Q(branch=branch) & Q(date__range=(startdate, enddate)) & Q(mode="Bank")
    )
    excluded_value_bank = [
        "Purchase",
        "Sale",
        "Service",
        "Sale Return",
        "Purchase Return",
        "PAYMENT",
        "RECEIPT",
    ]
    cashbookother_bank = CashBook.objects.exclude(
        Q(branch=branch) & Q(mode="Bank") & Q(date__range=(startdate, enddate)),
        description__in=excluded_value_bank,
    )
    df_bank = pd.DataFrame.from_records(cashbook_bank.values())
    try:
        totalsale_bank = (
            df_bank[df_bank["description"] == "Sale"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        # convert the above dataframes into django query sets for all the dfs
        totalsaleqs_bank = totalsale_bank.to_dict(orient="records")
    except KeyError:
        totalsaleqs_bank = None
    try:
        totalpurchase_bank = (
            df_bank[df_bank["description"] == "Purchase"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalpurchaseqs_bank = totalpurchase_bank.to_dict(orient="records")
    except KeyError:
        totalpurchaseqs_bank = None
    try:
        totalservice_bank = (
            df_bank[df_bank["description"] == "Service"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalserviceqs_bank = totalservice_bank.to_dict(orient="records")
    except KeyError:
        totalserviceqs_bank = None
    try:
        totalsalereturn_bank = (
            df_bank[df_bank["description"] == "Sale Return"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalsalereturnqs_bank = totalsalereturn_bank.to_dict(orient="records")
    except KeyError:
        totalsalereturnqs_bank = None
    try:
        totalpurchasereturn_bank = (
            df_bank[df_bank["description"] == "Purchase Return"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalpurchasereturnqs_bank = totalpurchasereturn_bank.to_dict(orient="records")
    except KeyError:
        totalpurchasereturnqs_bank = None
    try:
        totalpayment_bank = (
            df_bank[df_bank["description"] == "PAYMENT"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalpaymentqs_bank = totalpayment_bank.to_dict(orient="records")
    except KeyError:
        totalpaymentqs_bank = None
    try:
        totalreceipt_bank = (
            df_bank[df_bank["description"] == "RECEIPT"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalreceiptqs_bank = totalreceipt_bank.to_dict(orient="records")
    except KeyError:
        totalreceiptqs_bank = None

    # Calculate the closing balance
    # TBD: add the filter and then identify the opening balance as well
    totalpaymentbalance_bank = 0
    totalreceiptbalance_bank = 0
    for item in cashbook_bank:
        totalpaymentbalance_bank += item.payment
        totalreceiptbalance_bank += item.receipt

    if opening_bank_balance_type == "payment":
        totalpaymentbalance_bank += opening_bank_balance
    elif opening_bank_balance_type == "receipt":
        totalreceiptbalance_bank += opening_bank_balance

    if totalpaymentbalance_bank > totalreceiptbalance_bank:
        balancetype_bank = "payment"
        closingbalance_bank = totalpaymentbalance_bank - totalreceiptbalance_bank
    else:
        balancetype_bank = "receipt"
        closingbalance_bank = totalreceiptbalance_bank - totalpaymentbalance_bank

    closingbalance_bank = round(closingbalance_bank, 2)



    # Get today's date and filter for today's Bank receipts
    
    total_today_receipt_bank = cashbook_bank.aggregate(
        total_today_receipt=Sum('receipt')
    )['total_today_receipt'] or 0


    total_today_payment_bank = cashbook_bank.aggregate(
        total_today_payment=Sum('payment')
    )['total_today_payment'] or 0

 



    #### added on 4/10/2024 ################
    

    try:
        all_cashbook_card = CashBook.objects.filter(Q(branch=branch) & Q(mode="Card"))
        df_card_opening = pd.DataFrame.from_records(all_cashbook_card.values())
        df_card_opening["date"] = pd.to_datetime(df_card_opening["date"], errors="coerce")
        df_card_opening = df_card_opening.dropna(subset=["date"])
        filtered_df_card = df_card_opening[
            df_card_opening["date"] < pd.to_datetime(startdate)
        ]
        opening_card_payment = filtered_df_card["payment"].sum()
        opening_card_receipt = filtered_df_card["receipt"].sum()
    except:
        opening_card_payment = 0
        opening_card_receipt = 0

    if opening_card_payment > opening_card_receipt:
        opening_card_balance = opening_card_payment - opening_card_receipt
        opening_card_balance_type = "payment"
    else:
        opening_card_balance = opening_card_receipt - opening_card_payment
        opening_card_balance_type = "receipt"

    opening_card_balance = round(opening_card_balance, 2)


    # ######################### added on 4/10/2024 ##########################

    # Card Transactions

    cashbook_card = CashBook.objects.filter(
        Q(branch=branch) & Q(date__range=(startdate, enddate)) & Q(mode="Card")
    )
    excluded_value_card = [
        "Purchase",
        "Sale",
        "Service",
        "Sale Return",
        "Purchase Return",
        "PAYMENT",
        "RECEIPT",
    ]
    cashbookother_card = CashBook.objects.exclude(
        Q(branch=branch) & Q(mode="Card") & Q(date__range=(startdate, enddate)),
        description__in=excluded_value_card,
    )
    df_card = pd.DataFrame.from_records(cashbook_card.values())
    try:
        totalsale_card = (
            df_card[df_card["description"] == "Sale"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        # convert the above dataframes into django query sets for all the dfs
        totalsaleqs_card = totalsale_card.to_dict(orient="records")
    except KeyError:
        totalsaleqs_card = None
    try:
        totalpurchase_card = (
            df_card[df_card["description"] == "Purchase"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalpurchaseqs_card = totalpurchase_card.to_dict(orient="records")
    except KeyError:
        totalpurchaseqs_card = None
    try:
        totalservice_card = (
            df_card[df_card["description"] == "Service"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalserviceqs_card = totalservice_card.to_dict(orient="records")
    except KeyError:
        totalserviceqs_card = None
    try:
        totalsalereturn_card = (
            df_card[df_card["description"] == "Sale Return"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalsalereturnqs_card = totalsalereturn_card.to_dict(orient="records")
    except KeyError:
        totalsalereturnqs_card = None
    try:
        totalpurchasereturn_card = (
            df_card[df_card["description"] == "Purchase Return"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalpurchasereturnqs_card = totalpurchasereturn_card.to_dict(orient="records")
    except KeyError:
        totalpurchasereturnqs_card = None
    try:
        totalpayment_card = (
            df_card[df_card["description"] == "PAYMENT"]
            .groupby("date")["payment"]
            .sum()
            .reset_index()
        )
        totalpaymentqs_card = totalpayment_card.to_dict(orient="records")
    except KeyError:
        totalpaymentqs_card = None
    try:
        totalreceipt_card = (
            df_card[df_card["description"] == "RECEIPT"]
            .groupby("date")["receipt"]
            .sum()
            .reset_index()
        )
        totalreceiptqs_card = totalreceipt_card.to_dict(orient="records")
    except KeyError:
        totalreceiptqs_card = None

    # Calculate the closing balance
    # TBD: add the filter and then identify the opening balance as well
    totalpaymentbalance_card = 0
    totalreceiptbalance_card = 0
    for item in cashbook_card:
        totalpaymentbalance_card += item.payment
        totalreceiptbalance_card += item.receipt

    ## Added on 7/0/2024 ######
    # Add the opening balance for card
    if opening_card_balance_type == "payment":
        totalpaymentbalance_card += opening_card_balance
    elif opening_card_balance_type == "receipt":
        totalreceiptbalance_card += opening_card_balance
    ########################

    if totalpaymentbalance_card > totalreceiptbalance_card:
        balancetype_card = "payment"
        closingbalance_card = totalpaymentbalance_card - totalreceiptbalance_card
    else:
        balancetype_card = "receipt"
        closingbalance_card = totalreceiptbalance_card - totalpaymentbalance_card

    closingbalance_card = round(closingbalance_card, 2)
    

    # Get today's date and filter for today's Bank receipts
  
    total_today_receipt_card = cashbook_card.aggregate(
        total_today_receipt=Sum('receipt')
    )['total_today_receipt'] or 0

    total_today_payment_card = cashbook_card.aggregate(
        total_today_payment=Sum('payment')
    )['total_today_payment'] or 0





    if request.user.is_superuser:
        all_branches = Branch.objects.filter(
            Q(branchtype="Own") | Q(branchtype="Franchise") | Q(name="WAREHOUSE")
        )
    else:
        all_branches = [request.user.userprofile.branch]



    if balancetype_cash == 'receipt':
        closingbalance_cash_add =closingbalance_cash
    else:
        closingbalance_cash_add = 0
    if balancetype_card == 'receipt':
        closingbalance_card_add =closingbalance_card
    else:
        closingbalance_card_add = 0

    if balancetype_bank == 'receipt':
        closingbalance_bank_add =closingbalance_bank
    else:
        closingbalance_bank_add = 0

    if balancetype_upi == 'receipt':
        closingbalance_upi_add =closingbalance_upi
    else:
        closingbalance_upi_add = 0

    cash_balance_total = closingbalance_cash_add + closingbalance_bank_add + closingbalance_card_add + closingbalance_upi_add


    if opening_cash_balance_type == 'receipt':
        opening_cash_balance_add =opening_cash_balance
    else:
        opening_cash_balance_add = 0

    if opening_card_balance_type == 'receipt':
        opening_card_balance_add =opening_card_balance
    else:
        opening_card_balance_add = 0

    if opening_bank_balance_type == 'receipt':
        opening_bank_balance_add =opening_bank_balance
    else:
        opening_bank_balance_add= 0

    if opening_upi_balance_type == 'receipt':
        opening_upi_balance_add =opening_upi_balance
    else:
        opening_upi_balance_add  = 0

    opening_balance_total = opening_cash_balance_add + opening_bank_balance_add + opening_card_balance_add + opening_upi_balance_add 

   

    # Total receipt today
    total_today_receipt_total=total_today_receipt_card +total_today_receipt_cash+total_today_receipt_upi+total_today_receipt_bank
    
    # Total Payment today
    total_today_payment_total=total_today_payment_card +total_today_payment_cash+total_today_payment_upi+total_today_payment_bank


   
    cash_in_drow = total_today_receipt_cash - total_today_payment_cash

   
    if cash_in_drow < 0 :
        cash_in_drow = 0
    
    data = {
        "opening_balance_total":opening_balance_total,
        "cash_balance_total":cash_balance_total,
        "sale_cash": totalsaleqs_cash,
        "purchase_cash": totalpurchaseqs_cash,
        "service_cash": totalserviceqs_cash,
        "salereturn_cash": totalsalereturnqs_cash,
        "purchasereturn_cash": totalpurchasereturnqs_cash,
        "payments_cash": totalpaymentqs_cash,
        "receipts_cash": totalreceiptqs_cash,
        "other_cash": cashbookother_cash,
        "balancetype_cash": balancetype_cash,
        "closingbalance_cash": closingbalance_cash,
        "opening_cash_balance": opening_cash_balance,
        "opening_cash_balance_type": opening_cash_balance_type,
        "sale_upi": totalsaleqs_upi,
        "purchase_upi": totalpurchaseqs_upi,
        "service_upi": totalserviceqs_upi,
        "salereturn_upi": totalsalereturnqs_upi,
        "purchasereturn_upi": totalpurchasereturnqs_upi,
        "payments_upi": totalpaymentqs_upi,
        "receipts_upi": totalreceiptqs_upi,
        "other_upi": cashbookother_upi,
        "balancetype_upi": balancetype_upi,
        "closingbalance_upi": closingbalance_upi,
        "opening_upi_balance": opening_upi_balance,
        "opening_upi_balance_type": opening_upi_balance_type,
        "sale_bank": totalsaleqs_bank,
        "purchase_bank": totalpurchaseqs_bank,
        "service_bank": totalserviceqs_bank,
        "salereturn_bank": totalsalereturnqs_bank,
        "purchasereturn_bank": totalpurchasereturnqs_bank,
        "payments_bank": totalpaymentqs_bank,
        "receipts_bank": totalreceiptqs_bank,
        "other_bank": cashbookother_bank,
        "balancetype_bank": balancetype_bank,
        "closingbalance_bank": closingbalance_bank,
        "opening_bank_balance": opening_bank_balance,
        "opening_bank_balance_type": opening_bank_balance_type,
        "sale_card": totalsaleqs_card,
        "purchase_card": totalpurchaseqs_card,
        "service_card": totalserviceqs_card,
        "salereturn_card": totalsalereturnqs_card,
        "purchasereturn_card": totalpurchasereturnqs_card,
        "payments_card": totalpaymentqs_card,
        "receipts_card": totalreceiptqs_card,
        "other_card": cashbookother_card,
        "balancetype_card": balancetype_card,
        "closingbalance_card": closingbalance_card,
        ###### added on 4/10/2024 ######
        "opening_card_balance": opening_card_balance,
        "opening_card_balance_type": opening_card_balance_type,
        ###### added on 4/10/2024 ######
        "branch_list": all_branches,
        "startdate": startdate,
        "enddate": enddate,
        "branch": branch,
        #### added on 14/10/2024 ####
        "total_today_receipt_card":total_today_receipt_card ,
        "total_today_receipt_cash":total_today_receipt_cash ,
        "total_today_receipt_upi":total_today_receipt_upi ,
        "total_today_receipt_bank":total_today_receipt_bank ,
        "total_today_receipt_total":round(total_today_receipt_total,2),
        "cash_in_drow":round(cash_in_drow,2)
        ###################
    }

    return data





# def func_cashbook_in_all_in_one_report(request):

#     if request.method == "POST":
#         try:
#             startdate = request.POST["startdate"]
#             ss = startdate
#             startdate = datetime.strptime(startdate, "%d-%m-%Y")
#             enddate = request.POST["enddate"]
#             enddate = datetime.strptime(enddate, "%d-%m-%Y")
#         except:
#             startdate = date.today()
#             enddate = date.today()

#         if request.user.is_superuser:
#             branch = request.POST["branch"]
#         else:
#             branch = request.user.userprofile.branch
#     else:
#         branch = request.user.userprofile.branch
#         startdate = date.today()
#         enddate = date.today()

#     # Cash Transactions
#     try:
#         all_cashbook_cash = CashBook.objects.filter(Q(branch=branch) & Q(mode="Cash"))
#         df_cash_opening = pd.DataFrame.from_records(all_cashbook_cash.values())
#         df_cash_opening["created_date"] = pd.to_datetime(
#             df_cash_opening["created_date"], errors="coerce"
#         )
#         df_cash_opening = df_cash_opening.dropna(subset=["created_date"])
#         filtered_df = df_cash_opening[
#             df_cash_opening["created_date"] < pd.to_datetime(startdate)
#         ]
#         opening_cash_payment = filtered_df["payment"].sum()
#         opening_cash_receipt = filtered_df["receipt"].sum()
#     except:
#         opening_cash_payment = 0
#         opening_cash_receipt = 0

#     if opening_cash_payment > opening_cash_receipt:
#         opening_cash_balance = opening_cash_payment - opening_cash_receipt
#         opening_cash_balance_type = "payment"
#     else:
#         opening_cash_balance = opening_cash_receipt - opening_cash_payment
#         opening_cash_balance_type = "receipt"

#     opening_cash_balance = round(opening_cash_balance, 2)

#     cashbook_cash = CashBook.objects.filter(
#         Q(branch=branch) & Q(created_date__range=(startdate, enddate)) & Q(mode="Cash")
#     )

#     excluded_value_cash = [
#         "Purchase",
#         "Sale",
#         "Service",
#         "Sale Return",
#         "Purchase Return",
#         "PAYMENT",
#         "RECEIPT",
#     ]
#     cashbookother_cash = CashBook.objects.exclude(
#         Q(branch=branch) & Q(mode="Cash") & Q(created_date__range=(startdate, enddate)),
#         description__in=excluded_value_cash,
#     )
#     df_cash = pd.DataFrame.from_records(cashbook_cash.values())

#     try:
#         totalsale_cash = (
#             df_cash[df_cash["description"] == "Sale"]
#             .groupby("created_date")["receipt"]
#             .sum()
#             .reset_index()
#         )
#         totalsaleqs_cash = totalsale_cash.to_dict(orient="records")
#     except KeyError:
#         totalsaleqs_cash = None
#     try:
#         totalpurchase_cash = (
#             df_cash[df_cash["description"] == "Purchase"]
#             .groupby("created_date")["payment"]
#             .sum()
#             .reset_index()
#         )
#         totalpurchaseqs_cash = totalpurchase_cash.to_dict(orient="records")
#     except KeyError:
#         totalpurchaseqs_cash = None
#     try:
#         totalservice_cash = (
#             df_cash[df_cash["description"] == "Service"]
#             .groupby("created_date")["receipt"]
#             .sum()
#             .reset_index()
#         )
#         totalserviceqs_cash = totalservice_cash.to_dict(orient="records")
#     except KeyError:
#         totalserviceqs_cash = None
#     try:
#         totalsalereturn_cash = (
#             df_cash[df_cash["description"] == "Sale Return"]
#             .groupby("created_date")["payment"]
#             .sum()
#             .reset_index()
#         )
#         totalsalereturnqs_cash = totalsalereturn_cash.to_dict(orient="records")
#     except KeyError:
#         totalsalereturnqs_cash = None
#     try:
#         totalpurchasereturn_cash = (
#             df_cash[df_cash["description"] == "Purchase Return"]
#             .groupby("created_date")["receipt"]
#             .sum()
#             .reset_index()
#         )
#         totalpurchasereturnqs_cash = totalpurchasereturn_cash.to_dict(orient="records")
#     except KeyError:
#         totalpurchasereturnqs_cash = None
#     try:
#         totalpayment_cash = (
#             df_cash[df_cash["description"] == "PAYMENT"]
#             .groupby("created_date")["payment"]
#             .sum()
#             .reset_index()
#         )
#         totalpaymentqs_cash = totalpayment_cash.to_dict(orient="records")
#     except KeyError:
#         totalpaymentqs_cash = None
#     try:
#         totalreceipt_cash = (
#             df_cash[df_cash["description"] == "RECEIPT"]
#             .groupby("created_date")["receipt"]
#             .sum()
#             .reset_index()
#         )
#         totalreceiptqs_cash = totalreceipt_cash.to_dict(orient="records")
#     except KeyError:
#         totalreceiptqs_cash = None

#     # Calculate closing balance
#     totalpaymentbalance_cash = 0
#     totalreceiptbalance_cash = 0
#     for item in cashbook_cash:
#         totalpaymentbalance_cash += item.payment
#         totalreceiptbalance_cash += item.receipt

#     if opening_cash_balance_type == "payment":
#         totalpaymentbalance_cash += opening_cash_balance
#     elif opening_cash_balance_type == "receipt":
#         totalreceiptbalance_cash += opening_cash_balance

#     if totalpaymentbalance_cash > totalreceiptbalance_cash:
#         balancetype_cash = "payment"
#         closingbalance_cash = totalpaymentbalance_cash - totalreceiptbalance_cash
#     else:
#         balancetype_cash = "receipt"
#         closingbalance_cash = totalreceiptbalance_cash - totalpaymentbalance_cash

#     closingbalance_cash = round(closingbalance_cash, 2)

#     # Get today's totals for cash
#     total_today_receipt_cash = cashbook_cash.aggregate(
#         total_today_receipt=Sum('receipt')
#     )['total_today_receipt'] or 0

#     total_today_payment_cash = cashbook_cash.aggregate(
#         total_today_payment=Sum('payment')
#     )['total_today_payment'] or 0

#     # UPI Transactions
#     try:
#         all_cashbook_upi = CashBook.objects.filter(Q(branch=branch) & Q(mode="UPI"))
#         df_upi_opening = pd.DataFrame.from_records(all_cashbook_upi.values())
#         df_upi_opening["created_date"] = pd.to_datetime(
#             df_upi_opening["created_date"], errors="coerce"
#         )
#         df_upi_opening = df_upi_opening.dropna(subset=["created_date"])
#         filtered_df_upi = df_upi_opening[
#             df_upi_opening["created_date"] < pd.to_datetime(startdate)
#         ]
#         opening_upi_payment = filtered_df_upi["payment"].sum()
#         opening_upi_receipt = filtered_df_upi["receipt"].sum()
#     except:
#         opening_upi_payment = 0
#         opening_upi_receipt = 0

#     if opening_upi_payment > opening_upi_receipt:
#         opening_upi_balance = opening_upi_payment - opening_upi_receipt
#         opening_upi_balance_type = "payment"
#     else:
#         opening_upi_balance = opening_upi_receipt - opening_upi_payment
#         opening_upi_balance_type = "receipt"

#     opening_upi_balance = round(opening_upi_balance, 2)

#     cashbook_upi = CashBook.objects.filter(
#         Q(branch=branch) & Q(created_date__range=(startdate, enddate)) & Q(mode="UPI")
#     )

#     excluded_value_upi = [
#         "Purchase",
#         "Sale",
#         "Service",
#         "Sale Return",
#         "Purchase Return",
#         "PAYMENT",
#         "RECEIPT",
#     ]
#     cashbookother_upi = CashBook.objects.exclude(
#         Q(branch=branch) & Q(mode="UPI") & Q(created_date__range=(startdate, enddate)),
#         description__in=excluded_value_upi,
#     )
#     df_upi = pd.DataFrame.from_records(cashbook_upi.values())

#     try:
#         totalsale_upi = (
#             df_upi[df_upi["description"] == "Sale"]
#             .groupby("created_date")["receipt"]
#             .sum()
#             .reset_index()
#         )
#         totalsaleqs_upi = totalsale_upi.to_dict(orient="records")
#     except KeyError:
#         totalsaleqs_upi = None
#     try:
#         totalpurchase_upi = (
#             df_upi[df_upi["description"] == "Purchase"]
#             .groupby("created_date")["payment"]
#             .sum()
#             .reset_index()
#         )
#         totalpurchaseqs_upi = totalpurchase_upi.to_dict(orient="records")
#     except KeyError:
#         totalpurchaseqs_upi = None
#     try:
#         totalservice_upi = (
#             df_upi[df_upi["description"] == "Service"]
#             .groupby("created_date")["receipt"]
#             .sum()
#             .reset_index()
#         )
#         totalserviceqs_upi = totalservice_upi.to_dict(orient="records")
#     except KeyError:
#         totalserviceqs_upi = None
#     try:
#         totalsalereturn_upi = (
#             df_upi[df_upi["description"] == "Sale Return"]
#             .groupby("created_date")["payment"]
#             .sum()
#             .reset_index()
#         )
#         totalsalereturnqs_upi = totalsalereturn_upi.to_dict(orient="records")
#     except KeyError:
#         totalsalereturnqs_upi = None
#     try:
#         totalpurchasereturn_upi = (
#             df_upi[df_upi["description"] == "Purchase Return"]
#             .groupby("created_date")["receipt"]
#             .sum()
#             .reset_index()
#         )
#         totalpurchasereturnqs_upi = totalpurchasereturn_upi.to_dict(orient="records")
#     except KeyError:
#         totalpurchasereturnqs_upi = None
#     try:
#         totalpayment_upi = (
#             df_upi[df_upi["description"] == "PAYMENT"]
#             .groupby("created_date")["payment"]
#             .sum()
#             .reset_index()
#         )
#         totalpaymentqs_upi = totalpayment_upi.to_dict(orient="records")
#     except KeyError:
#         totalpaymentqs_upi = None
#     try:
#         totalreceipt_upi = (
#             df_upi[df_upi["description"] == "RECEIPT"]
#             .groupby("created_date")["receipt"]
#             .sum()
#             .reset_index()
#         )
#         totalreceiptqs_upi = totalreceipt_upi.to_dict(orient="records")
#     except KeyError:
#         totalreceiptqs_upi = None

#     # Calculate UPI closing balance
#     totalpaymentbalance_upi = 0
#     totalreceiptbalance_upi = 0
#     for item in cashbook_upi:
#         totalpaymentbalance_upi += item.payment
#         totalreceiptbalance_upi += item.receipt

#     if opening_upi_balance_type == "payment":
#         totalpaymentbalance_upi += opening_upi_balance
#     elif opening_upi_balance_type == "receipt":
#         totalreceiptbalance_upi += opening_upi_balance

#     if totalpaymentbalance_upi > totalreceiptbalance_upi:
#         balancetype_upi = "payment"
#         closingbalance_upi = totalpaymentbalance_upi - totalreceiptbalance_upi
#     else:
#         balancetype_upi = "receipt"
#         closingbalance_upi = totalreceiptbalance_upi - totalpaymentbalance_upi

#     closingbalance_upi = round(closingbalance_upi, 2)

#     # Get today's UPI totals
#     total_today_receipt_upi = cashbook_upi.aggregate(
#         total_today_receipt=Sum('receipt')
#     )['total_today_receipt'] or 0

#     total_today_payment_upi = cashbook_upi.aggregate(
#         total_today_payment=Sum('payment')
#     )['total_today_payment'] or 0

    

    

#     # Bank Transactions
#     # Identify the opening balance for Bank
#     try:
#         all_cashbook_bank = CashBook.objects.filter(Q(branch=branch) & Q(mode="Bank"))
#         df_bank_opening = pd.DataFrame.from_records(all_cashbook_bank.values())
#         df_bank_opening["created_date"] = pd.to_datetime(
#             df_bank_opening["created_date"], errors="coerce"
#         )
#         df_bank_opening = df_bank_opening.dropna(subset=["created_date"])
#         filtered_df_bank = df_bank_opening[
#             df_bank_opening["created_date"] < pd.to_datetime(startdate)
#         ]
#         opening_bank_payment = filtered_df_bank["payment"].sum()
#         opening_bank_receipt = filtered_df_bank["receipt"].sum()
#     except:
#         opening_bank_payment = 0
#         opening_bank_receipt = 0

#     if opening_bank_payment > opening_bank_receipt:
#         opening_bank_balance = opening_bank_payment - opening_bank_receipt
#         opening_bank_balance_type = "payment"
#     else:
#         opening_bank_balance = opening_bank_receipt - opening_bank_payment
#         opening_bank_balance_type = "receipt"

#     opening_bank_balance = round(opening_bank_balance, 2)

#     cashbook_bank = CashBook.objects.filter(
#         Q(branch=branch) & Q(created_date__range=(startdate, enddate)) & Q(mode="Bank")
#     )
#     excluded_value_bank = [
#         "Purchase",
#         "Sale",
#         "Service",
#         "Sale Return",
#         "Purchase Return",
#         "PAYMENT",
#         "RECEIPT",
#     ]
#     cashbookother_bank = CashBook.objects.exclude(
#         Q(branch=branch) & Q(mode="Bank") & Q(created_date__range=(startdate, enddate)),
#         description__in=excluded_value_bank,
#     )
#     df_bank = pd.DataFrame.from_records(cashbook_bank.values())
#     try:
#         totalsale_bank = (
#             df_bank[df_bank["description"] == "Sale"]
#             .groupby("created_date")["receipt"]
#             .sum()
#             .reset_index()
#         )
#         totalsaleqs_bank = totalsale_bank.to_dict(orient="records")
#     except KeyError:
#         totalsaleqs_bank = None
#     try:
#         totalpurchase_bank = (
#             df_bank[df_bank["description"] == "Purchase"]
#             .groupby("created_date")["payment"]
#             .sum()
#             .reset_index()
#         )
#         totalpurchaseqs_bank = totalpurchase_bank.to_dict(orient="records")
#     except KeyError:
#         totalpurchaseqs_bank = None
#     try:
#         totalservice_bank = (
#             df_bank[df_bank["description"] == "Service"]
#             .groupby("created_date")["receipt"]
#             .sum()
#             .reset_index()
#         )
#         totalserviceqs_bank = totalservice_bank.to_dict(orient="records")
#     except KeyError:
#         totalserviceqs_bank = None
#     try:
#         totalsalereturn_bank = (
#             df_bank[df_bank["description"] == "Sale Return"]
#             .groupby("created_date")["payment"]
#             .sum()
#             .reset_index()
#         )
#         totalsalereturnqs_bank = totalsalereturn_bank.to_dict(orient="records")
#     except KeyError:
#         totalsalereturnqs_bank = None
#     try:
#         totalpurchasereturn_bank = (
#             df_bank[df_bank["description"] == "Purchase Return"]
#             .groupby("created_date")["receipt"]
#             .sum()
#             .reset_index()
#         )
#         totalpurchasereturnqs_bank = totalpurchasereturn_bank.to_dict(orient="records")
#     except KeyError:
#         totalpurchasereturnqs_bank = None
#     try:
#         totalpayment_bank = (
#             df_bank[df_bank["description"] == "PAYMENT"]
#             .groupby("created_date")["payment"]
#             .sum()
#             .reset_index()
#         )
#         totalpaymentqs_bank = totalpayment_bank.to_dict(orient="records")
#     except KeyError:
#         totalpaymentqs_bank = None
#     try:
#         totalreceipt_bank = (
#             df_bank[df_bank["description"] == "RECEIPT"]
#             .groupby("created_date")["receipt"]
#             .sum()
#             .reset_index()
#         )
#         totalreceiptqs_bank = totalreceipt_bank.to_dict(orient="records")
#     except KeyError:
#         totalreceiptqs_bank = None

#     # Calculate the closing balance
#     totalpaymentbalance_bank = 0
#     totalreceiptbalance_bank = 0
#     for item in cashbook_bank:
#         totalpaymentbalance_bank += item.payment
#         totalreceiptbalance_bank += item.receipt

#     if opening_bank_balance_type == "payment":
#         totalpaymentbalance_bank += opening_bank_balance
#     elif opening_bank_balance_type == "receipt":
#         totalreceiptbalance_bank += opening_bank_balance

#     if totalpaymentbalance_bank > totalreceiptbalance_bank:
#         balancetype_bank = "payment"
#         closingbalance_bank = totalpaymentbalance_bank - totalreceiptbalance_bank
#     else:
#         balancetype_bank = "receipt"
#         closingbalance_bank = totalreceiptbalance_bank - totalpaymentbalance_bank

#     closingbalance_bank = round(closingbalance_bank, 2)

#     # Get today's totals for bank
#     total_today_receipt_bank = cashbook_bank.aggregate(
#         total_today_receipt=Sum('receipt')
#     )['total_today_receipt'] or 0

#     total_today_payment_bank = cashbook_bank.aggregate(
#         total_today_payment=Sum('payment')
#     )['total_today_payment'] or 0

#     # Card Transactions
#     try:
#         all_cashbook_card = CashBook.objects.filter(Q(branch=branch) & Q(mode="Card"))
#         df_card_opening = pd.DataFrame.from_records(all_cashbook_card.values())
#         df_card_opening["created_date"] = pd.to_datetime(df_card_opening["created_date"], errors="coerce")
#         df_card_opening = df_card_opening.dropna(subset=["created_date"])
#         filtered_df_card = df_card_opening[
#             df_card_opening["created_date"] < pd.to_datetime(startdate)
#         ]
#         opening_card_payment = filtered_df_card["payment"].sum()
#         opening_card_receipt = filtered_df_card["receipt"].sum()
#     except:
#         opening_card_payment = 0
#         opening_card_receipt = 0

#     if opening_card_payment > opening_card_receipt:
#         opening_card_balance = opening_card_payment - opening_card_receipt
#         opening_card_balance_type = "payment"
#     else:
#         opening_card_balance = opening_card_receipt - opening_card_payment
#         opening_card_balance_type = "receipt"

#     opening_card_balance = round(opening_card_balance, 2)

#     cashbook_card = CashBook.objects.filter(
#         Q(branch=branch) & Q(created_date__range=(startdate, enddate)) & Q(mode="Card")
#     )
#     excluded_value_card = [
#         "Purchase",
#         "Sale",
#         "Service",
#         "Sale Return",
#         "Purchase Return",
#         "PAYMENT",
#         "RECEIPT",
#     ]
#     cashbookother_card = CashBook.objects.exclude(
#         Q(branch=branch) & Q(mode="Card") & Q(created_date__range=(startdate, enddate)),
#         description__in=excluded_value_card,
#     )
#     df_card = pd.DataFrame.from_records(cashbook_card.values())
#     try:
#         totalsale_card = (
#             df_card[df_card["description"] == "Sale"]
#             .groupby("created_date")["receipt"]
#             .sum()
#             .reset_index()
#         )
#         totalsaleqs_card = totalsale_card.to_dict(orient="records")
#     except KeyError:
#         totalsaleqs_card = None
#     try:
#         totalpurchase_card = (
#             df_card[df_card["description"] == "Purchase"]
#             .groupby("created_date")["payment"]
#             .sum()
#             .reset_index()
#         )
#         totalpurchaseqs_card = totalpurchase_card.to_dict(orient="records")
#     except KeyError:
#         totalpurchaseqs_card = None
#     try:
#         totalservice_card = (
#             df_card[df_card["description"] == "Service"]
#             .groupby("created_date")["receipt"]
#             .sum()
#             .reset_index()
#         )
#         totalserviceqs_card = totalservice_card.to_dict(orient="records")
#     except KeyError:
#         totalserviceqs_card = None
#     try:
#         totalsalereturn_card = (
#             df_card[df_card["description"] == "Sale Return"]
#             .groupby("created_date")["payment"]
#             .sum()
#             .reset_index()
#         )
#         totalsalereturnqs_card = totalsalereturn_card.to_dict(orient="records")
#     except KeyError:
#         totalsalereturnqs_card = None
#     try:
#         totalpurchasereturn_card = (
#             df_card[df_card["description"] == "Purchase Return"]
#             .groupby("created_date")["receipt"]
#             .sum()
#             .reset_index()
#         )
#         totalpurchasereturnqs_card = totalpurchasereturn_card.to_dict(orient="records")
#     except KeyError:
#         totalpurchasereturnqs_card = None
#     try:
#         totalpayment_card = (
#             df_card[df_card["description"] == "PAYMENT"]
#             .groupby("created_date")["payment"]
#             .sum()
#             .reset_index()
#         )
#         totalpaymentqs_card = totalpayment_card.to_dict(orient="records")
#     except KeyError:
#         totalpaymentqs_card = None
#     try:
#         totalreceipt_card = (
#             df_card[df_card["description"] == "RECEIPT"]
#             .groupby("created_date")["receipt"]
#             .sum()
#             .reset_index()
#         )
#         totalreceiptqs_card = totalreceipt_card.to_dict(orient="records")
#     except KeyError:
#         totalreceiptqs_card = None

#     # Calculate the closing balance
#     totalpaymentbalance_card = 0
#     totalreceiptbalance_card = 0
#     for item in cashbook_card:
#         totalpaymentbalance_card += item.payment
#         totalreceiptbalance_card += item.receipt

#     if opening_card_balance_type == "payment":
#         totalpaymentbalance_card += opening_card_balance
#     elif opening_card_balance_type == "receipt":
#         totalreceiptbalance_card += opening_card_balance

#     if totalpaymentbalance_card > totalreceiptbalance_card:
#         balancetype_card = "payment"
#         closingbalance_card = totalpaymentbalance_card - totalreceiptbalance_card
#     else:
#         balancetype_card = "receipt"
#         closingbalance_card = totalreceiptbalance_card - totalpaymentbalance_card

#     closingbalance_card = round(closingbalance_card, 2)

#     # Get today's totals for card
#     total_today_receipt_card = cashbook_card.aggregate(
#         total_today_receipt=Sum('receipt')
#     )['total_today_receipt'] or 0

#     total_today_payment_card = cashbook_card.aggregate(
#         total_today_payment=Sum('payment')
#     )['total_today_payment'] or 0

#     # Rest of calculations and final data dictionary remain the same
#     if request.user.is_superuser:
#         all_branches = Branch.objects.filter(
#             Q(branchtype="Own") | Q(branchtype="Franchise") | Q(name="WAREHOUSE")
#         )
#     else:
#         all_branches = [request.user.userprofile.branch]

#     # Calculate balance totals
#     if balancetype_cash == 'receipt':
#         closingbalance_cash_add = closingbalance_cash
#     else:
#         closingbalance_cash_add = 0
#     if balancetype_card == 'receipt':
#         closingbalance_card_add = closingbalance_card
#     else:
#         closingbalance_card_add = 0

#     if balancetype_bank == 'receipt':
#         closingbalance_bank_add = closingbalance_bank
#     else:
#         closingbalance_bank_add = 0

#     if balancetype_upi == 'receipt':
#         closingbalance_upi_add = closingbalance_upi
#     else:
#         closingbalance_upi_add = 0

#     cash_balance_total = closingbalance_cash_add + closingbalance_bank_add + closingbalance_card_add + closingbalance_upi_add

#     # Calculate opening balance totals
#     if opening_cash_balance_type == 'receipt':
#         opening_cash_balance_add = opening_cash_balance
#     else:
#         opening_cash_balance_add = 0

#     if opening_card_balance_type == 'receipt':
#         opening_card_balance_add = opening_card_balance
#     else:
#         opening_card_balance_add = 0

#     if opening_bank_balance_type == 'receipt':
#         opening_bank_balance_add = opening_bank_balance
#     else:
#         opening_bank_balance_add = 0

#     if opening_upi_balance_type == 'receipt':
#         opening_upi_balance_add = opening_upi_balance
#     else:
#         opening_upi_balance_add = 0

#     opening_balance_total = opening_cash_balance_add + opening_bank_balance_add + opening_card_balance_add + opening_upi_balance_add

#     # Calculate total receipts and payments
#     total_today_receipt_total = total_today_receipt_card + total_today_receipt_cash + total_today_receipt_upi + total_today_receipt_bank
#     total_today_payment_total = total_today_payment_card + total_today_payment_cash + total_today_payment_upi + total_today_payment_bank

#     cash_in_drow = total_today_receipt_cash - total_today_payment_cash
#     if cash_in_drow < 0:
#         cash_in_drow = 0

#     data = {
#         "opening_balance_total":opening_balance_total,
#         "cash_balance_total":cash_balance_total,
#         "sale_cash": totalsaleqs_cash,
#         "purchase_cash": totalpurchaseqs_cash,
#         "service_cash": totalserviceqs_cash,
#         "salereturn_cash": totalsalereturnqs_cash,
#         "purchasereturn_cash": totalpurchasereturnqs_cash,
#         "payments_cash": totalpaymentqs_cash,
#         "receipts_cash": totalreceiptqs_cash,
#         "other_cash": cashbookother_cash,
#         "balancetype_cash": balancetype_cash,
#         "closingbalance_cash": closingbalance_cash,
#         "opening_cash_balance": opening_cash_balance,
#         "opening_cash_balance_type": opening_cash_balance_type,
#         "sale_upi": totalsaleqs_upi,
#         "purchase_upi": totalpurchaseqs_upi,
#         "service_upi": totalserviceqs_upi,
#         "salereturn_upi": totalsalereturnqs_upi,
#         "purchasereturn_upi": totalpurchasereturnqs_upi,
#         "payments_upi": totalpaymentqs_upi,
#         "receipts_upi": totalreceiptqs_upi,
#         "other_upi": cashbookother_upi,
#         "balancetype_upi": balancetype_upi,
#         "closingbalance_upi": closingbalance_upi,
#         "opening_upi_balance": opening_upi_balance,
#         "opening_upi_balance_type": opening_upi_balance_type,
#         "sale_bank": totalsaleqs_bank,
#         "purchase_bank": totalpurchaseqs_bank,
#         "service_bank": totalserviceqs_bank,
#         "salereturn_bank": totalsalereturnqs_bank,
#         "purchasereturn_bank": totalpurchasereturnqs_bank,
#         "payments_bank": totalpaymentqs_bank,
#         "receipts_bank": totalreceiptqs_bank,
#         "other_bank": cashbookother_bank,
#         "balancetype_bank": balancetype_bank,
#         "closingbalance_bank": closingbalance_bank,
#         "opening_bank_balance": opening_bank_balance,
#         "opening_bank_balance_type": opening_bank_balance_type,
#         "sale_card": totalsaleqs_card,
#         "purchase_card": totalpurchaseqs_card,
#         "service_card": totalserviceqs_card,
#         "salereturn_card": totalsalereturnqs_card,
#         "purchasereturn_card": totalpurchasereturnqs_card,
#         "payments_card": totalpaymentqs_card,
#         "receipts_card": totalreceiptqs_card,
#         "other_card": cashbookother_card,
#         "balancetype_card": balancetype_card,
#         "closingbalance_card": closingbalance_card,
#         ###### added on 4/10/2024 ######
#         "opening_card_balance": opening_card_balance,
#         "opening_card_balance_type": opening_card_balance_type,
#         ###### added on 4/10/2024 ######
#         "branch_list": all_branches,
#         "startdate": startdate,
#         "enddate": enddate,
#         "branch": branch,
#         #### added on 14/10/2024 ####
#         "total_today_receipt_card":total_today_receipt_card ,
#         "total_today_receipt_cash":total_today_receipt_cash ,
#         "total_today_receipt_upi":total_today_receipt_upi ,
#         "total_today_receipt_bank":total_today_receipt_bank ,
#         "total_today_receipt_total":round(total_today_receipt_total,2),
#         "cash_in_drow":round(cash_in_drow,2)
#         ###################
#     }

#     return data
    





# All in one report
@login_required
def all_in_one_report(request):

    user = request.user
    if request.method == 'POST':
        startdate =  request.POST['startdate']
        startdate = datetime.strptime(startdate, "%d-%m-%Y").date()
        enddate = request.POST['enddate']
        enddate = datetime.strptime(enddate, "%d-%m-%Y").date()
        branch = Branch.objects.filter(id=int(request.POST['branch'])).first()
    else:
        startdate = date.today()
        enddate = date.today()
        branch = user.userprofile.branch
    

    if user.is_superuser:

        #service
        service_obj = Service.objects.filter(Q(modifieddate__gte=startdate)&Q(modifieddate__gte__lte=enddate)&Q(branch=branch)&Q(status="Delivered(Ok)")).order_by("-pk")
        #sales
        sales_obj = Sale.objects.filter(Q(invoicedate__gte=startdate)&Q(invoicedate__lte=enddate)&Q(branch=branch)).order_by("-pk")
        #payment
        payment_obj = Payments.objects.filter(Q(paymentdate__gte=startdate)&Q(paymentdate__lte=enddate)&Q(branch=branch)).order_by("-pk")
        #Purchase
        if branch.name == 'WAREHOUSE':
            purchase_obj = Purchase.objects.filter(Q(invoicedate__gte=startdate)&Q(invoicedate__lte=enddate)).order_by("-pk")
        else:
            purchase_obj = BranchPurchase.objects.filter(Q(invoicedate__gte=startdate)&Q(invoicedate__lte=enddate)&Q(branch=branch)).order_by("-pk")

        all_branches = Branch.objects.filter(
            (Q(branchtype="Own") | Q(branchtype="Franchise")) | Q(name="WAREHOUSE")
        )
    else:
        branch = user.userprofile.branch
        all_branches = [user.userprofile.branch]
        #service
        service_obj = Service.objects.filter(
            Q(Q(modifieddate__gte=startdate)&Q(modifieddate__lte=enddate)) & Q(branch=branch)&Q(status="Delivered(Ok)")
        ).order_by("-pk")
        #sales
        sales_obj = Sale.objects.filter(
            Q(Q(invoicedate__gte=startdate)&Q(invoicedate__lte=enddate)) & Q(branch=branch)
        ).order_by("-pk")
        #payment
        payment_obj = Payments.objects.filter(Q(paymentdate__gte=startdate)&Q(paymentdate__lte=enddate)&Q(branch=branch)).order_by("-pk")
        #Purchase
        purchase_obj = BranchPurchase.objects.filter(Q(invoicedate__gte=startdate)&Q(invoicedate__lte=enddate)&Q(branch=branch)).order_by("-pk")
        


  

    #service section
    #### calculate cost,tax,profile etc
    final_list_service = []
    total_service_income=0
    total_purchase_cost_service = 0
    total_tax_service = 0
    total_profit_service = 0
    for items in service_obj:
        dic={"spares":'',
        'totalpurchasecost':0,
        "totaltax":0,
        'totalserviceincome':0}
        
        dic['totaltax'] += items.totaltax 
        dic['totalserviceincome'] = items.amountrecieved
        dic['servicerefnumber'] = items.servicerefnumber
        dic['product'] = f"{items.brand} {items.model}"
        dic['customer'] = f"{items.firstname} {items.lastname}"
        dic['complaint'] = items.problem

        spares = SpareParts.objects.filter(servicerefnumber=items.servicerefnumber)
        if spares:
            for count,sub_items in enumerate(spares):
                dic['spares'] += f"{count+1}){sub_items.name.name},<br>"
                dic['totalpurchasecost'] += round(((sub_items.purchase_price + (sub_items.purchase_price * (sub_items.purchase_tax/100)))*sub_items.totalquantity),2)
                sub_item_tax = (sub_items.price * (float(sub_items.salegst) / 100)) * sub_items.totalquantity
                dic['totaltax'] += round(sub_item_tax,2)
                dic['profit']= round((dic['totalserviceincome'] - dic['totalpurchasecost'] - dic['totaltax']),2)
        else:
            dic['profit']= round((dic['totalserviceincome'] - dic['totaltax']),2)
        total_service_income += dic['totalserviceincome']
        total_purchase_cost_service += dic['totalpurchasecost']
        total_tax_service  += dic['totaltax']
        total_profit_service += dic['profit']
        final_list_service.append(dic)




    #sales section
    saleid_set = set()
    sales_obj = [
        sale
        for sale in sales_obj
        if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
    ]
    #### calculate cost,tax,profile etc
    final_list_sale = []
    total_sale_price=0
    total_purchase_cost_sale = 0
    total_tax_sale = 0
    total_profit_sale = 0
    for items in sales_obj:
        dic={"products":'',
        'totalpurchasecost':0}
        sales = Sale.objects.filter(saleid=items.saleid)
        for count,sub_items in enumerate(sales):
            dic['saleid'] = items.saleid
            dic['customer'] = items.customer
            dic['invoicenumber'] = items.invoicenumber
            dic['products'] += f"{count+1}){sub_items.name.name},<br>"
            dic['totalsaleprice'] = items.amountrecieved
            dic['totalpurchasecost'] += round(((sub_items.purchase_price + (sub_items.purchase_price * (sub_items.purchase_tax/100)))*sub_items.totalquantity),2)
            dic['totaltax']=items.totaltax
            dic['profit']= round((dic['totalsaleprice'] - dic['totalpurchasecost'] - dic['totaltax']),2)
        total_sale_price += dic['totalsaleprice']
        total_purchase_cost_sale += dic['totalpurchasecost']
        total_tax_sale  += dic['totaltax']
        total_profit_sale += dic['profit']
        final_list_sale.append(dic)


    total_gross_profilt = total_profit_sale + total_profit_service


    # cashbook section
    cashbook_data = func_cashbook_in_all_in_one_report(request)



    #payment section
    payment_sum =0
    for pay in payment_obj:
        payment_sum += pay.amount


    #Purchase section
    purchaseid_set = set()
    purchase_obj = [
        purchase
        for purchase in purchase_obj 
        if (purchase.purchaseid not in purchaseid_set and not purchaseid_set.add(purchase.purchaseid))
    ]


    purchase_list_final=[]
    total_amount_paid = 0
    for pur in purchaseid_set:
   
        dic={}
        if branch.name == 'WAEHOUSE':
            purch_obj = Purchase.objects.filter(purchaseid=pur)
            first_obj = purch_obj.first()
            dic['supplier'] = first_obj.supplier.name
        else:
            purch_obj = BranchPurchase.objects.filter(purchaseid=pur)
            first_obj = purch_obj.first()
            dic['supplier'] = first_obj.externalsupplier.name

        
  
        dic['purchaseid'] = pur
        dic['amountpaid'] = first_obj.amountrecieved
        dic['totalamount'] = first_obj.totalbillingamount
        total_amount_paid += first_obj.totalbillingamount
        if first_obj.duebalance == 0:
            dic['status'] = "Paid"
        else:
            dic['status'] = "NotPaid"
        dic['products']=[]
        for pr in purch_obj:
            
            dic2={}
            dic2['prod'] = pr.name.name
            purchase_tax = float(Tax.objects.filter(Q(branch=branch)&Q(name=pr.purchasegst)).first().percentage)
            cost = round(((pr.price + (pr.price * (purchase_tax/100)))*pr.totalquantity),2)
            dic2['cost'] = cost
            dic2['quantity'] = pr.totalquantity
            dic['products'].append(dic2)
        purchase_list_final.append(dic)

    #Opening stock Closing stock section (QUANTITY)

    # Convert dates to datetime objects with time component
    start_datetime = timezone.make_aware(datetime.combine(startdate, datetime.min.time()))
    end_datetime = timezone.make_aware(datetime.combine(enddate, datetime.max.time()))

    # Calculate total opening stock
    additions_before_start = StockTransaction.objects.filter(
        created_date__lt=start_datetime,
        transactiontype='Add',
        branch=branch
    ).aggregate(total=Sum('quantity'))['total'] or 0

    subtractions_before_start = StockTransaction.objects.filter(
        created_date__lt=start_datetime,
        transactiontype='Sub',
        branch=branch
    ).aggregate(total=Sum('quantity'))['total'] or 0

    opening_stock = additions_before_start - subtractions_before_start

    # Calculate stock changes during the period
    additions_during_period = StockTransaction.objects.filter(
        created_date__gte=start_datetime,
        created_date__lte=end_datetime,
        transactiontype='Add',
        branch=branch
    ).aggregate(total=Sum('quantity'))['total'] or 0

    subtractions_during_period = StockTransaction.objects.filter(
        created_date__gte=start_datetime,
        created_date__lte=end_datetime,
        transactiontype='Sub',
        branch=branch
    ).aggregate(total=Sum('quantity'))['total'] or 0

    stock_change = additions_during_period - subtractions_during_period

    # Calculate closing stock
    closing_stock = opening_stock + stock_change

    #Opening stock Closing stock section (STOCK VALUE)

    # Convert dates to datetime objects with time component
    start_datetime = timezone.make_aware(datetime.combine(startdate, datetime.min.time()))
    end_datetime = timezone.make_aware(datetime.combine(enddate, datetime.max.time()))

    # Calculate total opening stock value
    additions_value_before_start = StockTransaction.objects.filter(
        created_date__lt=start_datetime,
        transactiontype='Add',
        branch=branch
    ).aggregate(total_value=Sum('transaction_value'))['total_value'] or 0

    subtractions_value_before_start = StockTransaction.objects.filter(
        created_date__lt=start_datetime,
        transactiontype='Sub',
        branch=branch
    ).aggregate(total_value=Sum('transaction_value'))['total_value'] or 0

    opening_stock_value = additions_value_before_start - subtractions_value_before_start

    # Calculate stock value changes during the period
    additions_value_during_period = StockTransaction.objects.filter(
        created_date__gte=start_datetime,
        created_date__lte=end_datetime,
        transactiontype='Add',
        branch=branch
    ).aggregate(total_value=Sum('transaction_value'))['total_value'] or 0

    subtractions_value_during_period = StockTransaction.objects.filter(
        created_date__gte=start_datetime,
        created_date__lte=end_datetime,
        transactiontype='Sub',
        branch=branch
    ).aggregate(total_value=Sum('transaction_value'))['total_value'] or 0

    stock_change_value = additions_value_during_period - subtractions_value_during_period

    # Calculate closing stock value
    closing_stock_value = opening_stock_value + stock_change_value


    # logo
    company = request.user.userprofile.company
    logo = company.logo_url



  
    context = {
          "opening_stock_value":round(opening_stock_value,2),
        "closing_stock_value":round(closing_stock_value,2),
        "opening_stock":opening_stock,
        "closing_stock":closing_stock,
        "total_amount_paid":total_amount_paid,
        "purchase_list":purchase_list_final,
        "payment_obj":payment_obj,
        "total_payment":payment_sum,
        "total_service_income":round(total_service_income,2),
        "logo": GLOBAL_VARIABLES["current_host"] + logo.url,
        "total_sale_price":round(total_sale_price,2),
        "total_purchase_cost_service":round(total_purchase_cost_service,2),
        "total_purchase_cost_sale":round(total_purchase_cost_sale,2),
        "total_tax_service":round(total_tax_service,2),
        "total_tax_sale":round(total_tax_sale,2),
        "total_profit_service":round(total_profit_service,2),
        "total_profit_sale":round(total_profit_sale,2),
        "all_service": final_list_service,
        "all_sales": final_list_sale,
        "all_branches": all_branches,
        "selected_branch": user.userprofile.branch,
        "startdate":startdate,
        "enddate":enddate,
        "branch":branch,
        "total_gross_profit":total_gross_profilt,
        "cashbook":cashbook_data
    }
    

    return render(request, "allinonereport.html", context)







########################## New Balancesheet ############################################

def func_get_placcount_for_balancesheet(startdate,enddate,request):
     
    branch=request.user.userprofile.branch

    income_total = 0
    expense_total = 0

    #Opening stock Closing stock section

    # Convert dates to datetime objects with time component
    start_datetime = timezone.make_aware(datetime.combine(startdate, datetime.min.time()))
    end_datetime = timezone.make_aware(datetime.combine(enddate, datetime.max.time()))

    # Calculate total opening stock
    additions_before_start = StockTransaction.objects.filter(
        created_date__lt=start_datetime,
        transactiontype='Add',
        branch=branch
    ).aggregate(total=Sum('quantity'))['total'] or 0

    subtractions_before_start = StockTransaction.objects.filter(
        created_date__lt=start_datetime,
        transactiontype='Sub',
        branch=branch
    ).aggregate(total=Sum('quantity'))['total'] or 0

    opening_stock = additions_before_start - subtractions_before_start

    # Calculate stock changes during the period
    additions_during_period = StockTransaction.objects.filter(
        created_date__gte=start_datetime,
        created_date__lte=end_datetime,
        transactiontype='Add',
        branch=branch
    ).aggregate(total=Sum('quantity'))['total'] or 0

    subtractions_during_period = StockTransaction.objects.filter(
        created_date__gte=start_datetime,
        created_date__lte=end_datetime,
        transactiontype='Sub',
        branch=branch
    ).aggregate(total=Sum('quantity'))['total'] or 0

    stock_change = additions_during_period - subtractions_during_period

    # Calculate closing stock
    closing_stock = opening_stock + stock_change

    

    #Opening stock Closing stock section (STOCK VALUE)

    # Convert dates to datetime objects with time component
    start_datetime = timezone.make_aware(datetime.combine(startdate, datetime.min.time()))
    end_datetime = timezone.make_aware(datetime.combine(enddate, datetime.max.time()))

    # Calculate total opening stock value
    additions_before_start_transactions = StockTransaction.objects.filter(
        created_date__lt=start_datetime,
        transactiontype='Add',
        branch=branch
    ).values('purchase_rate', 'quantity')
    
    additions_value_before_start = sum(
        transaction['purchase_rate'] * transaction['quantity']
        for transaction in additions_before_start_transactions
    )

    subtractions_before_start_transactions = StockTransaction.objects.filter(
        created_date__lt=start_datetime,
        transactiontype='Sub',
        branch=branch
    ).values('purchase_rate', 'quantity')
    
    subtractions_value_before_start = sum(
        transaction['purchase_rate'] * transaction['quantity']
        for transaction in subtractions_before_start_transactions
    )

    opening_stock_value = additions_value_before_start - subtractions_value_before_start

    expense_total += opening_stock_value

    # Calculate stock value changes during the period
    additions_during_period_transactions = StockTransaction.objects.filter(
        created_date__gte=start_datetime,
        created_date__lte=end_datetime,
        transactiontype='Add',
        branch=branch
    ).values('purchase_rate', 'quantity')
    
    additions_value_during_period = sum(
        transaction['purchase_rate'] * transaction['quantity']
        for transaction in additions_during_period_transactions
    )
    
    subtractions_during_period_transactions = StockTransaction.objects.filter(
        created_date__gte=start_datetime,
        created_date__lte=end_datetime,
        transactiontype='Sub',
        branch=branch
    ).values('purchase_rate', 'quantity')
    
    subtractions_value_during_period = sum(
        transaction['purchase_rate'] * transaction['quantity']
        for transaction in subtractions_during_period_transactions
    )


    stock_change_value = additions_value_during_period - subtractions_value_during_period

    # Calculate closing stock value
    closing_stock_value = opening_stock_value + stock_change_value

    income_total += closing_stock_value



    #Purchase Expense

    data = BranchPurchase.objects.filter(
        Q(branch=branch)
        & ~Q(purchase_type="transfer")
        & ~Q(purchase_type="stockadd")
        & Q(invoicedate__gte=startdate)
        & Q(invoicedate__lte=enddate)
    ).order_by("-pk")
    purchaseid_set = set()
    purchase_obj = [
        purchase
        for purchase in data
        if (
            purchase.purchaseid not in purchaseid_set
            and not purchaseid_set.add(purchase.purchaseid)
        )
    ]

    purchase_expense = 0
    for items in purchase_obj:
        purchase_expense += (items.totalbillingamount-items.totaltax)

    expense_total += purchase_expense 


    data = Sale.objects.filter(Q(branch=branch)& Q(invoicedate__gte=startdate)
        & Q(invoicedate__lte=enddate)).order_by("-pk")
    saleid_set = set()
    sale_obj = [
        sale
        for sale in data
        if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
    ]
    sale_income = 0
    for items in sale_obj :
        sale_income += (items.totalbillingamount-items.totaltax)
    income_total += sale_income



    # service income

    # service_obj =Service.objects.filter(Q(branch=branch)& Q(memodate__gte=startdate)
    #     & Q(memodate__lte=enddate)& Q(status='Delivered(Ok)'))
    statuses = [
        'Unassigned',
        'Unacknowledged',
        'In Progress',
        'QC Failed',
        'Completed',
        'QC Passed(Ok)',
        'CNP Inprogress(Ok)',
        'CNP Pending(Ok)',
        'CNP Completed(Ok)',
    ]
    # Build the query
    service_obj = Service.objects.filter(
        Q(branch=branch) &
        Q(memodate__gte=startdate) &
        Q(memodate__lte=enddate) &
        (
            Q(status='Delivered(Ok)') |
            (
                # Q(amountrecieved__gt=0) &
                Q(finalamount__gt=F('amountrecieved')) &
                Q(status__in=statuses)
            )
        )
    )
    service_income = 0
    for item in service_obj:
        finalamount = item.finalamount
        servicerefnumber = item.servicerefnumber
        servicedic_obj = ServiceDiscountDetails.objects.filter(servicerefnumber=servicerefnumber).first()
        if servicedic_obj:
            total_tax = servicedic_obj.sparetaxtotal_afterdiscount + servicedic_obj.servicetaxtotal_afterdiscount
            service_income += (finalamount - total_tax)
        else:
            service_tax = item.totaltax
            spare_tax = 0
            spare_obj = SpareParts.objects.filter(servicerefnumber=servicerefnumber)
            if spare_obj:
                for sub_item in spare_obj:
                    spare_tax += (sub_item.price * (float(sub_item.salegst) / 100))
            total_tax = service_tax + spare_tax
            service_income += (finalamount - total_tax)
    income_total += service_income

    # spare cost
    # spare_cost_total = 0
    # for item in service_obj:
    #     spare_obj = SpareParts.objects.filter(servicerefnumber=item.servicerefnumber)
    #     if spare_obj:
    #         for sub_item in spare_obj:
    #             purchase_price = sub_item.purchase_price 
    #             purchase_tax = float(sub_item.purchase_tax)
    #             purchase_total = purchase_price + (purchase_price * (purchase_tax / 100))
    #             spare_cost_total += purchase_total

    purchase_return = 0
    data = PurchaseReturn.objects.filter(Q(status='Processed') & Q(branch=branch)& Q(createddate__gte=startdate)
        & Q(createddate__lte=enddate))
    purchase_return_set = set()
    purchase_return_obj = [
        purchase
        for purchase in data
        if (
            purchase.purchasereturnid not in purchase_return_set
            and not purchase_return_set.add(purchase.purchasereturnid)
        )
    ]

    for ret in purchase_return_obj:
        purchase_return += (ret.nettotal - ret.totaltax)
    income_total += purchase_return



    sale_return = 0
    data = SaleReturn.objects.filter(Q(branch=branch)& Q(createddate__gte=startdate)
        & Q(createddate__lte=enddate))
    sale_return_set = set()
    sale_return_obj = [
        sale
        for sale in data
        if (
            sale.salereturnid not in sale_return_set
            and not sale_return_set.add(sale.salereturnid)
        )
    ]

    for ret in sale_return_obj:
        sale_return += (ret.nettotal - ret.totaltax)
    expense_total += sale_return
  
    # OTHER EXPENSE

    # INCOME_SIDE = ['INCOMES',
    # 'SALES ACCOUNT',
    # 'SERVICE ACCOUNT',
    # 'PURCHASE RETURN',
    # ]
    # EXPENSE_SIDE = [
    #     'EXPENSES',
    #     'PURCHASE ACCOUNTS',
    #     'SALARY AND WAGES',
    #     'SALES RETURN',
    #     'TRADE EXPENSES',
    #     'OTHER INDIRECT EXPENSES'
        
    # ]

    # Initialize dictionaries to store accumulated values for each account
    income_accounts = {}
    expense_accounts = {}

    # Process all payments
    payments_obj = Payments.objects.filter(Q(branch=branch)& Q(paymentdate__gte=startdate)
        & Q(paymentdate__lte=enddate))
    for pay in payments_obj:
        debit_acc = pay.debitaccount
        acc_key = debit_acc.title.replace(" ", "_")

        # print("\n\ndebit account - ", debit_acc , "\n\n")
        acc_head = CoASubAccounts.objects.filter(title=debit_acc).first().head_root.name
        
        # Process based on account type
        if debit_acc.head_root.account_group.account_head.name == 'INCOME':
            # Accumulate amounts for the same account
            if acc_key in income_accounts:
                income_accounts[acc_key] -= pay.amount
                income_total -= pay.amount
            else:
                income_accounts[acc_key] = -pay.amount
                income_total -= pay.amount
            
        elif debit_acc.head_root.account_group.account_head.name == 'EXPENSE':
            if acc_key in expense_accounts:
                expense_accounts[acc_key] += pay.amount
                expense_total += pay.amount
            else:
                expense_accounts[acc_key] = pay.amount
                expense_total += pay.amount



    # OTHER INCOME

    # Initialize dictionaries to store accumulated values for each account
    income_accounts = {}
    expense_accounts = {}

    # Process all receipts
    receipts_obj = Receipts.objects.filter(Q(branch=branch)& Q(receiptdate__gte=startdate)
        & Q(receiptdate__lte=enddate))
    for receipt in receipts_obj:
        credit_acc = receipt.creditaccount
        acc_key = credit_acc.title.replace(" ", "_")
        try:
            acc_head = CoASubAccounts.objects.filter(title=credit_acc).first().head_root.name
            
            # Process based on account type
            if credit_acc.head_root.account_group.account_head.name == 'INCOME':
                # Accumulate amounts for the same account
                if acc_key in income_accounts:
                    income_accounts[acc_key] += receipt.amount
                    income_total += receipt.amount
                else:
                    income_accounts[acc_key] = receipt.amount
                    income_total += receipt.amount
                
            elif credit_acc.head_root.account_group.account_head.name == 'EXPENSE':
                if acc_key in expense_accounts:
                    expense_accounts[acc_key] -= receipt.amount
                    expense_total -= receipt.amount
                else:
                    expense_accounts[acc_key] = -receipt.amount
                    expense_total -= receipt.amount

        except:
            pass



    # Initialize dictionaries to store accumulated values for each account
    income_accounts = {}
    expense_accounts = {}

    cash_list = ['CASH ACCOUNT']

    # Process all journals
    journals_obj = Journals.objects.filter(Q(branch=branch)& Q(journaldate__gte=startdate)
        & Q(journaldate__lte=enddate))

    for journal in journals_obj:
        credit_acc = journal.creditaccount
        debit_acc = journal.debitaccount
        credit_acc_key = credit_acc.title.replace(" ", "_")
        debit_acc_key = debit_acc.title.replace(" ", "_")

        # Get account heads
        # if credit_acc in cash_list:
        #     credit_acc_head = credit_acc
        # elif CoASubAccounts.objects.filter(title=credit_acc).first():
        #     credit_acc_head = CoASubAccounts.objects.filter(title=credit_acc).first().head_root.name
        # else:
        #     credit_acc_head = credit_acc

        # if debit_acc in cash_list:
        #     debit_acc_head = debit_acc
        # elif CoASubAccounts.objects.filter(title=debit_acc).first():
        #     debit_acc_head = CoASubAccounts.objects.filter(title=debit_acc).first().head_root.name
        # else:
        #     debit_acc_head = debit_acc
        
        # Process credit side
        if credit_acc.head_root.account_group.account_head.name == "INCOME":
            if credit_acc_key in income_accounts:
                income_accounts[credit_acc_key] += journal.amount
                income_total += journal.amount
            else:
                income_accounts[credit_acc_key] = journal.amount
                income_total += journal.amount
                
        elif credit_acc.head_root.account_group.account_head.name == "EXPENSE":
            if credit_acc_key in expense_accounts:
                expense_accounts[credit_acc_key] -= journal.amount
                expense_total -= journal.amount
            else:
                expense_accounts[credit_acc_key] = journal.amount
                expense_total -= journal.amount

        # Process debit side
        if debit_acc.head_root.account_group.account_head.name == "INCOME":
            if debit_acc_key in income_accounts:
                income_accounts[debit_acc_key] -= journal.amount
                income_total -= journal.amount
            else:
                income_accounts[debit_acc_key] = journal.amount
                income_total -= journal.amount
                
        elif debit_acc.head_root.account_group.account_head.name == "EXPENSE":
            if debit_acc_key in expense_accounts:
                expense_accounts[debit_acc_key] += journal.amount
                expense_total += journal.amount
            else:
                expense_accounts[debit_acc_key] = journal.amount
                expense_total += journal.amount


    if income_total > expense_total:
        balance = round(income_total - expense_total,2)
        balance_text = 'Net Profilt (Income > Expenses)'
        pnl = 'Profit'
        final = income_total
    else:
        balance = round(expense_total - income_total,2)
        balance_text = 'Net Loss (Expenses > Income)'
        pnl = 'Loss'
        final = expense_total

    # balance = round((balance / (1 + (15/100))),2)

    return {"balance":balance,'pnl':pnl}


def func_get_transaction_for_balancesheet(startdate,enddate,request):

    currentuser = request.user
    transaction = []

    filters = Q()

    if not currentuser.is_superuser:
        filters &= Q(branch=currentuser.userprofile.branch)

    if filters:
        transaction = Transaction.objects.filter(filters).order_by("-pk")

    invoicenumber_list = set()
    accounts_list = set()

    if currentuser.is_superuser:
        transactions_all = Transaction.objects.all().order_by("-pk")
    else:
        transactions_all = Transaction.objects.filter(
            branch=currentuser.userprofile.branch
        ).order_by("-pk")
    for trans in transactions_all:
        accounts_list.add(trans.accounts)
        invoicenumber_list.add(trans.invoice_number)

    transaction_list = []
    purchase_due_balance = 0
    sale_due_balance = 0
    service_due_balance = 0

    search='Yes'
    total_debit = 0
    total_credit = 0
    
    for tr in transaction:
        if tr.transactiontype == "purchase":

            transactionid = tr.transactionid
            transaction_dict = {}
            if currentuser.is_superuser:

                purchase_p = Purchase.objects.filter(purchaseid=transactionid).first()
                if not purchase_p:
                    pass
                else:
                    ###########
                    if purchase_p.duebalance:
                        purchase_due_balance += purchase_p.duebalance
                    ###########

                    invoicenumber_list.add(purchase_p.invoicenumber)
                    accounts_list.add(purchase_p.supplier.name)
                    transaction_dict["invoicenumber"] = purchase_p.invoicenumber
                    transaction_dict["accounts"] = purchase_p.supplier.name
                    transaction_dict["paymentmode"] = tr.paymentmode
                    transaction_dict["transaction"] = tr
                    transaction_dict["branch"] = tr.branch
                    transaction_dict["title"] = "Purchase"
                    transaction_dict["amounttype"] = "Credit"
                  
                    transaction_dict['date'] = purchase_p.invoicedate
               

                    ###############
                    # trans_obj =Transaction.objects.filter(transactionid=purchase_p.purchaseid)
                    # is_first = False
                    # if tr==trans_obj.first():
                    #     is_first=True
                    # else:
                    #     is_first = False

                    # if is_first:
                    #     transaction_dict['createddate'] = purchase_p.invoicedate
                    # else:
                    #     transaction_dict['createddate'] = tr.createddate
                    transaction_date = tr.transactiondate
                    if transaction_date:
                        transaction_dict['createddate'] = transaction_date
                    else:
                        transaction_dict['createddate'] = tr.createddate
                    ###############

                    transaction_list.append(transaction_dict)
                purchase_b = BranchPurchase.objects.filter(
                    purchaseid=transactionid
                ).first()
                if not purchase_b:
                    pass
                else:
                    ###########
                    if purchase_b.duebalance:
                        purchase_due_balance += purchase_b.duebalance
                    ###########
                    invoicenumber_list.add(purchase_b.invoicenumber)
                    if purchase_b.supplier == None:
                        accounts_list.add(purchase_b.externalsupplier.name)
                    else:
                        accounts_list.add(purchase_b.supplier.name)
                    transaction_dict["invoicenumber"] = purchase_b.invoicenumber
                    if purchase_b.supplier == None:
                        transaction_dict["accounts"] = purchase_b.externalsupplier.name
                    else:
                        transaction_dict["accounts"] = purchase_b.supplier.name
                    transaction_dict["paymentmode"] = tr.paymentmode
                    transaction_dict["transaction"] = tr
                    transaction_dict["branch"] = tr.branch
                    transaction_dict["title"] = "Purchase"
                    transaction_dict["amounttype"] = "Credit"
                  
                    transaction_dict['date'] = purchase_b.invoicedate

                   

                    ###############
                    # trans_obj =Transaction.objects.filter(transactionid=purchase_b.purchaseid)
                    # is_first = False
                    # if tr==trans_obj.first():
                    #     is_first=True
                    # else:
                    #     is_first = False
                   
                    # if is_first:
                    #     transaction_dict['createddate'] = purchase_b.invoicedate
                    # else:
                    #     transaction_dict['createddate'] = tr.createddate
                    transaction_date = tr.transactiondate
                    if transaction_date:
                        transaction_dict['createddate'] = transaction_date
                    else:
                        transaction_dict['createddate'] = tr.createddate
                    ###############

                    transaction_list.append(transaction_dict)

            else:
                purchase = BranchPurchase.objects.filter(
                    purchaseid=transactionid
                ).first()
                if not purchase:
                    pass
                else:

                    ###########
                    if purchase.duebalance:
                        purchase_due_balance += purchase.duebalance
                    ###########

                    invoicenumber_list.add(purchase.invoicenumber)
                    if purchase.supplier == None:
                        accounts_list.add(purchase.externalsupplier.name)
                    else:
                        accounts_list.add(purchase.supplier.name)
                    transaction_dict["invoicenumber"] = purchase.invoicenumber
                    if purchase.supplier == None:
                        transaction_dict["accounts"] = purchase.externalsupplier.name
                    else:
                        transaction_dict["accounts"] = purchase.supplier.name
                    transaction_dict["paymentmode"] = tr.paymentmode
                    transaction_dict["transaction"] = tr
                    transaction_dict["branch"] = tr.branch
                    transaction_dict["title"] = "Purchase"
                    transaction_dict["amounttype"] = "Credit"
               
                    transaction_dict['date'] = purchase.invoicedate

                 

                    ###############
                    # trans_obj =Transaction.objects.filter(transactionid=purchase.purchaseid)
                    # is_first = False
                    # if tr==trans_obj.first():
                    #     is_first=True
                    # else:
                    #     is_first = False
                   
                    # if is_first:
                    #     transaction_dict['createddate'] = purchase.invoicedate
                    # else:
                    #     transaction_dict['createddate'] = tr.createddate
                    transaction_date = tr.transactiondate
                    if transaction_date:
                        transaction_dict['createddate'] = transaction_date
                    else:
                        transaction_dict['createddate'] = tr.createddate
                    ###############

                    transaction_list.append(transaction_dict)

        if tr.transactiontype == "purchasereturn":

            transactionid = tr.transactionid
            transaction_dict = {}
            # if currentuser.is_superuser:

            purchase_p = PurchaseReturn.objects.filter(
                purchasereturnid=transactionid
            ).first()
            if not purchase_p:
                pass
            else:
                invoicenumber_list.add(purchase_p.invoicenumber)
                if purchase_p.supplier == None:
                    accounts_list.add(purchase_p.externalsupplier.name)
                else:
                    accounts_list.add(purchase_p.supplier.name)
                transaction_dict["invoicenumber"] = purchase_p.invoicenumber
                if purchase_p.supplier == None:
                    transaction_dict["accounts"] = purchase_p.externalsupplier.name
                else:
                    transaction_dict["accounts"] = purchase_p.supplier.name
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Purchase Return"
                transaction_dict["amounttype"] = "Debit"
              
                transaction_dict['date'] = purchase_p.createddate

       

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=purchase_p.purchasereturnid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = purchase_p.createddate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "sale":

            transactionid = tr.transactionid
            transaction_dict = {}
            sale = Sale.objects.filter(saleid=transactionid).first()
            if not sale:
                pass
            else:
                ###########
                if sale.duebalance:
                    sale_due_balance += sale.duebalance
                ###########
                invoicenumber_list.add(sale.invoicenumber)
                accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = sale.invoicenumber
                transaction_dict["accounts"] = sale.customer
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Sale"
                transaction_dict["amounttype"] = "Debit"
              
                transaction_dict['date'] = sale.invoicedate


                ###############
                # trans_obj =Transaction.objects.filter(transactionid=sale.saleid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = sale.invoicedate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "salereturn":
            transactionid = tr.transactionid
            transaction_dict = {}
            sale = SaleReturn.objects.filter(salereturnid=transactionid).first()
            if not sale:
                pass
            else:
                invoicenumber_list.add(sale.invoicenumber)
                accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = sale.invoicenumber
                transaction_dict["accounts"] = sale.customer
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Sale Return"
                transaction_dict["amounttype"] = "Credit"
               
                transaction_dict['date'] = sale.createddate

              

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=sale.salereturnid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = sale.createddate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "expense":

            transactionid = tr.transactionid
            transaction_dict = {}
            expense = Expenses.objects.filter(expenseid=transactionid).first()
            if not expense:
                pass
            else:
                invoicenumber_list.add(expense.billnumber)
                # accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = expense.billnumber
                transaction_dict["accounts"] = ""
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = expense.remarks
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Expense"
                transaction_dict["amounttype"] = "Credit"
             
                transaction_dict['date'] = expense.expensedate

           

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=expense.expenseid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = expense.expensedate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "payment":

            transactionid = tr.transactionid
            transaction_dict = {}
            payment = Payments.objects.filter(paymentid=transactionid).first()
            if not payment:
                pass
            else:
                invoicenumber_list.add(payment.referenceno)
                # accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = payment.referenceno
                transaction_dict["accounts"] = payment.debitaccount
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = payment.description
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Payment"
                transaction_dict["amounttype"] = "Credit"
              
                transaction_dict['date'] = payment.paymentdate

             

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=payment.paymentid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = payment.paymentdate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "receipt":

            transactionid = tr.transactionid
            transaction_dict = {}
            receipt = Receipts.objects.filter(receiptid=transactionid).first()
            if not receipt:
                pass
            else:
                invoicenumber_list.add(receipt.referenceno)
                # accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = receipt.referenceno
                transaction_dict["accounts"] =receipt.creditaccount
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = receipt.description
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Receipt"
                transaction_dict["amounttype"] = "Debit"
             
                transaction_dict['date'] = receipt.receiptdate

      

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=receipt.receiptid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = receipt.receiptdate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "journal":

            transactionid = tr.transactionid
            transaction_dict = {}
            journal = Journals.objects.filter(journalid=transactionid).first()
            if not journal:
                pass
            else:
                amount_type = ''
                accounts = ''
                cash_list = ['CASH ACCOUNT']
                
                if journal.creditaccount in cash_list:
                    amount_type = 'Credit'
                    accounts = journal.debitaccount
                elif journal.debitaccount in cash_list:
                    amount_type = 'Debit'
                    accounts = journal.creditaccount

                invoicenumber_list.add(journal.referenceno)
                # accounts_list.add(sale.customer)
                transaction_dict["invoicenumber"] = journal.referenceno
                transaction_dict["accounts"] = accounts
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["remarks"] = journal.description
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Journal"
                transaction_dict["amounttype"] = amount_type
                transaction_dict['date'] = journal.journaldate
         

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=journal.journalid)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = journal.journaldate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)

        if tr.transactiontype == "service":

            transactionid = tr.transactionid
            transaction_dict = {}
            # expense =Expenses.objects.filter(expenseid = transactionid).first()
            service = Service.objects.filter(servicerefnumber=transactionid).first()
            if not service:
                pass
            else:

                ###########
                if service.duebalance:
                    service_due_balance += service.duebalance
                ###########

                invoicenumber_list.add(service.servicerefnumber)
                accounts_list.add(f"{service.firstname} {service.lastname}")
                transaction_dict["invoicenumber"] = service.servicerefnumber
                transaction_dict["accounts"] = f"{service.firstname} {service.lastname}"
                transaction_dict["paymentmode"] = tr.paymentmode
                transaction_dict["transaction"] = tr
                transaction_dict["branch"] = tr.branch
                transaction_dict["title"] = "Service"
                transaction_dict["amounttype"] = "Debit"
             
                transaction_dict['date'] = service.memodate
           

                ###############
                # trans_obj =Transaction.objects.filter(transactionid=service.servicerefnumber)
                # is_first = False
                # if tr==trans_obj.first():
                #     is_first=True
                # else:
                #     is_first = False

                # if is_first:
                #     transaction_dict['createddate'] = service.memodate
                # else:
                #     transaction_dict['createddate'] = tr.createddate
                transaction_date = tr.transactiondate
                if transaction_date:
                    transaction_dict['createddate'] = transaction_date
                else:
                    transaction_dict['createddate'] = tr.createddate
                ###############

                transaction_list.append(transaction_dict)


    # if request.method == 'POST':
        # if startdate:
        #     startdate = datetime.strptime(startdate, "%d-%m-%Y").date()

        # if enddate:
        #     enddate = datetime.strptime(enddate, "%d-%m-%Y").date()

    if startdate and enddate:
        transaction_list  = sorted(
        [
            transaction for transaction in transaction_list 
            if startdate <= transaction['createddate'] <= enddate
        ],
        key=lambda x: x['createddate'],
        reverse=False
        )
    else:
        transaction_list = sorted(
        transaction_list,
        key=lambda x: x['createddate'],
        reverse=False
    )

    return transaction_list




def func_get_opening_closing_stock_for_balancesheet(startdate, enddate, request):
    branch = request.user.userprofile.branch
    
    # Convert dates to datetime objects with time component
    start_datetime = timezone.make_aware(datetime.combine(startdate, datetime.min.time()))
    end_datetime = timezone.make_aware(datetime.combine(enddate, datetime.max.time()))
    
    # Calculate total opening stock quantity
    additions_before_start = StockTransaction.objects.filter(
        created_date__lt=start_datetime,
        transactiontype='Add',
        branch=branch
    ).aggregate(total=Sum('quantity'))['total'] or 0
    
    subtractions_before_start = StockTransaction.objects.filter(
        created_date__lt=start_datetime,
        transactiontype='Sub',
        branch=branch
    ).aggregate(total=Sum('quantity'))['total'] or 0
    
    opening_stock = additions_before_start - subtractions_before_start
    
    # Calculate stock changes during the period
    additions_during_period = StockTransaction.objects.filter(
        created_date__gte=start_datetime,
        created_date__lte=end_datetime,
        transactiontype='Add',
        branch=branch
    ).aggregate(total=Sum('quantity'))['total'] or 0
    
    subtractions_during_period = StockTransaction.objects.filter(
        created_date__gte=start_datetime,
        created_date__lte=end_datetime,
        transactiontype='Sub',
        branch=branch
    ).aggregate(total=Sum('quantity'))['total'] or 0
    
    stock_change = additions_during_period - subtractions_during_period
    
    # Calculate closing stock
    closing_stock = opening_stock + stock_change
    
    # Calculate opening stock value using purchase_rate * quantity
    additions_before_start_transactions = StockTransaction.objects.filter(
        created_date__lt=start_datetime,
        transactiontype='Add',
        branch=branch
    ).values('purchase_rate', 'quantity')
    
    additions_value_before_start = sum(
        transaction['purchase_rate'] * transaction['quantity']
        for transaction in additions_before_start_transactions
    )
    
    subtractions_before_start_transactions = StockTransaction.objects.filter(
        created_date__lt=start_datetime,
        transactiontype='Sub',
        branch=branch
    ).values('purchase_rate', 'quantity')
    
    subtractions_value_before_start = sum(
        transaction['purchase_rate'] * transaction['quantity']
        for transaction in subtractions_before_start_transactions
    )
    
    opening_stock_value = additions_value_before_start - subtractions_value_before_start
    
    # Calculate stock value changes during the period
    additions_during_period_transactions = StockTransaction.objects.filter(
        created_date__gte=start_datetime,
        created_date__lte=end_datetime,
        transactiontype='Add',
        branch=branch
    ).values('purchase_rate', 'quantity')
    
    additions_value_during_period = sum(
        transaction['purchase_rate'] * transaction['quantity']
        for transaction in additions_during_period_transactions
    )
    
    subtractions_during_period_transactions = StockTransaction.objects.filter(
        created_date__gte=start_datetime,
        created_date__lte=end_datetime,
        transactiontype='Sub',
        branch=branch
    ).values('purchase_rate', 'quantity')
    
    subtractions_value_during_period = sum(
        transaction['purchase_rate'] * transaction['quantity']
        for transaction in subtractions_during_period_transactions
    )
    
    stock_change_value = additions_value_during_period - subtractions_value_during_period
    
    # Calculate closing stock value
    closing_stock_value = opening_stock_value + stock_change_value
    
    return closing_stock_value







def process_account_lists(asset_list, liability_list, equity_list):
    """
    Process lists of financial accounts, group them by head_root, and sort them.
    
    Args:
        asset_list: List of asset dictionaries
        liability_list: List of liability dictionaries
        equity_list: List of equity dictionaries
    
    Returns:
        tuple: Three dictionaries (assets, liabilities, equity) grouped by head_root
    """
    def process_single_list(account_list):
        # Dictionary to store results grouped by head_root
        grouped_accounts = {}



        
        for account_dict in account_list:
            for key, value in account_dict.items():
                # Convert key from underscore format to original title format
                original_title = key.replace('_', ' ')
                
                try:
                    # Query the CoASubAccounts model to get the head_root
                    sub_account = CoASubAccounts.objects.get(title=original_title)
                    head_root = sub_account.head_root.name
                    
                    # Initialize the list for this head_root if it doesn't exist
                    if head_root not in grouped_accounts:
                        grouped_accounts[head_root] = []
                    
                    # Add the account to its head_root group
                    grouped_accounts[head_root].append({
                        'title': original_title,
                        'value': value
                    })
                    
                except CoASubAccounts.DoesNotExist:
                    print(f"Warning: No CoASubAccounts entry found for title: {original_title}")
                    continue
        
        # Sort accounts within each head_root group by title
        for head_root in grouped_accounts:
            grouped_accounts[head_root].sort(key=lambda x: x['title'])
            
        return grouped_accounts

    grouped_assets = process_single_list(asset_list)
    grouped_liabilities = process_single_list(liability_list)
    grouped_equity = process_single_list(equity_list)
    
    return grouped_assets, grouped_liabilities, grouped_equity


def format_negative_value(value):
    if value < 0:
        return f"({abs(round(value,2))})" 
    return format(value, '.2f')


def process_grouped_accounts(grouped_accounts):
    """
    Process grouped accounts to add totals for each group, handling negative values in parentheses.
    
    Args:
        grouped_accounts: Dictionary of grouped accounts
        
    Returns:
        Dictionary with totals and data for each group
    """
    def convert_value_to_float(value_str):
        # Remove any spaces and commas
        cleaned_value = value_str.replace(' ', '').replace(',', '')
        
        # Check if the value is in parentheses (negative)
        if cleaned_value.startswith('(') and cleaned_value.endswith(')'):
            # Remove parentheses and make it negative
            return -float(cleaned_value[1:-1])
        
        # Regular positive value
        return float(cleaned_value)
    
    result = {}
    
    for head_root, accounts in grouped_accounts.items():
        # Calculate total for the group
        total = sum(convert_value_to_float(account['value']) for account in accounts)

        total = format_negative_value(round(total,2))
   
        # Create new structure with total and original data
        result[head_root] = {
            "total": total,
            "data": accounts
        }
    
    return result


def balancesheet(request):

    if request.method == 'POST':
        enddate = request.POST.get('enddate')
        enddate = datetime.strptime(enddate, "%d-%m-%Y").date()
    else:
        # startdate = date.today()
        enddate = date.today()
    
    startdate = datetime(1900, 1, 1, 0, 0, 0).date()
    startdate_text = startdate
    enddate_text = enddate

    currentuser = request.user
    homebranch = UserProfile.objects.get(user=request.user).branch

    equity_total = 0
    liability_total = 0
    asset_total = 0

    balance_sheet_dict = {"asset":[],
    "liability":[]}
    cash_credit=0
    cash_debit = 0
    card_credit = 0 
    card_debit = 0
    bank_credit = 0 
    bank_debit = 0
    upi_credit = 0
    upi_debit = 0

    transaction_obj = func_get_transaction_for_balancesheet(startdate,enddate,request)

    for trans in transaction_obj:

        credit_or_debit = 'credit'
        if trans['transaction'].transactiontype == 'purchase':
            credit_or_debit = 'credit'
        elif trans['transaction'].transactiontype == 'purchasereturn':
            credit_or_debit = 'debit'
        elif trans['transaction'].transactiontype == 'sale':
            credit_or_debit = 'debit'
        elif trans['transaction'].transactiontype == 'salereturn':
            credit_or_debit = 'credit'
        elif trans['transaction'].transactiontype == 'service':
            credit_or_debit = 'debit'
        elif trans['transaction'].transactiontype == 'payment':
            credit_or_debit = 'credit'
        elif trans['transaction'].transactiontype == 'receipt':
            credit_or_debit = 'debit'
        elif trans['transaction'].transactiontype == 'journal':
            credit_or_debit = trans['amounttype'].lower()

        # All possible combinations
        if trans['transaction'].paymentmode == 'Cash':
            if credit_or_debit == 'credit':
                cash_credit += trans['transaction'].amount
            elif credit_or_debit == 'debit':
                cash_debit += trans['transaction'].amount

        elif trans['transaction'].paymentmode == 'Bank':
            if credit_or_debit == 'credit':
                bank_credit += trans['transaction'].amount
            elif credit_or_debit == 'debit':
                bank_debit += trans['transaction'].amount

        elif trans['transaction'].paymentmode == 'UPI':
            if credit_or_debit == 'credit':
                upi_credit += trans['transaction'].amount
            elif credit_or_debit == 'debit':
                upi_debit += trans['transaction'].amount

        elif trans['transaction'].paymentmode == 'Card':
            if credit_or_debit == 'credit':
                card_credit += trans['transaction'].amount
            elif credit_or_debit == 'debit':
                card_debit += trans['transaction'].amount

        else:
            pass


    CASH_ACCOUNT = cash_debit-cash_credit
    CASH_IN_BANK = bank_debit-bank_credit
    CASH_IN_UPI = upi_debit-upi_credit
    CASH_IN_CARD = card_debit-card_credit

    balance_sheet_dict['asset'].append({"Cash":format_negative_value(CASH_ACCOUNT)})
    balance_sheet_dict['asset'].append({"Bank":format_negative_value(CASH_IN_BANK)})
    balance_sheet_dict['asset'].append({"UPI":format_negative_value(CASH_IN_UPI)})
    balance_sheet_dict['asset'].append({"Card":format_negative_value(CASH_IN_CARD)})

    

    # Calculate values
    CASH_ACCOUNT = cash_debit - cash_credit
    CASH_IN_BANK = bank_debit - bank_credit
    CASH_IN_UPI = upi_debit - upi_credit
    CASH_IN_CARD = card_debit - card_credit

    total_cash_in_hand = CASH_ACCOUNT + CASH_IN_BANK + CASH_IN_UPI + CASH_IN_CARD
    total_cash_in_hand = format_negative_value(round(total_cash_in_hand,2))

    asset_total += ((cash_debit-cash_credit)+(bank_debit-bank_credit)+(upi_debit-upi_credit)+(card_debit-card_credit))

    # ASSET_SIDE =[
    #     'BRANCH ACCOUNTS',
    # 'STOCK IN HAND',
    # 'FIXED ASSETS',
    # 'INVESTMENTS',
    # 'LOAN AND ADVANCES',
    # 'OTHER ASSETS',
    # 'BRANCH ACCOUNTS'
    # ]
    # LIABILITY_SIDE = ['BORROWINGS',
    # 'DEPOSITS',
    # 'OTHER LIABILITIES',
    # ]
    # EQUITY_SIDE = [
    #     'RESERVES AND SURPLUSES',
    #     'SHARE CAPITAL',
    # ]


    # Initialize dictionaries to store accumulated values for each account
    asset_accounts = {}
    liability_accounts = {}
    equity_accounts = {}

    # Initialize lists for final results
    payment_list_asset = []
    payment_list_liability = []
    payment_list_equity = []
    # Process all payments
    payments_obj = Payments.objects.filter(Q(branch=homebranch)& Q(paymentdate__gte=startdate)
        & Q(paymentdate__lte=enddate))
    for pay in payments_obj:
        debit_acc = pay.debitaccount
        acc_key = debit_acc.title.replace(" ", "_")
        # try:
       

        # acc_head = CoASubAccounts.objects.filter(title=debit_acc).first().head_root.name
        
        # Process based on account type
        if debit_acc.head_root.account_group.account_head.name == 'ASSET':
            # Accumulate amounts for the same account
            if acc_key in asset_accounts:
                asset_accounts[acc_key] += pay.amount
            else:
                asset_accounts[acc_key] = pay.amount
            asset_total += pay.amount
            
        elif debit_acc.head_root.account_group.account_head.name == 'LIABILITY':
            if acc_key in liability_accounts:
                liability_accounts[acc_key] += pay.amount
            else:
                liability_accounts[acc_key] = pay.amount
            liability_total -= pay.amount
            
        elif debit_acc.head_root.account_group.account_head.name == 'EQUITY':
            if acc_key in equity_accounts:
                equity_accounts[acc_key] += pay.amount
            else:
                equity_accounts[acc_key] = pay.amount
            equity_total -= pay.amount
        # except:
        #     pass
    # Convert accumulated accounts to list format
    for acc_key, amount in asset_accounts.items():
        payment_list_asset.append({acc_key: amount})

    for acc_key, amount in liability_accounts.items():
        payment_list_liability.append({acc_key: amount})

    for acc_key, amount in equity_accounts.items():
        payment_list_equity.append({acc_key: amount})



    # Initialize dictionaries to store accumulated values for each account
    asset_accounts = {}
    liability_accounts = {}
    equity_accounts = {}

    # Initialize lists for final results
    receipt_list_asset = []
    receipt_list_liability = []
    receipt_list_equity = []
    # Process all receipts
    receipts_obj = Receipts.objects.filter(Q(branch=homebranch)& Q(receiptdate__gte=startdate)
        & Q(receiptdate__lte=enddate))
    for receipt in receipts_obj:
        credit_acc = receipt.creditaccount
        acc_key = credit_acc.title.replace(" ", "_")
        try:
            acc_head = CoASubAccounts.objects.filter(title=credit_acc).first().head_root.name
            
            # Process based on account type
            if credit_acc.head_root.account_group.account_head.name == 'ASSET':
                # Accumulate amounts for the same account
                if acc_key in asset_accounts:
                    asset_accounts[acc_key] += receipt.amount
                else:
                    asset_accounts[acc_key] = receipt.amount
                asset_total -= receipt.amount
                
            elif credit_acc.head_root.account_group.account_head.name == 'LIABILITY':
                if acc_key in liability_accounts:
                    liability_accounts[acc_key] += receipt.amount
                else:
                    liability_accounts[acc_key] = receipt.amount
                liability_total += receipt.amount
                
            elif credit_acc.head_root.account_group.account_head.name == 'EQUITY':
                if acc_key in equity_accounts:
                    equity_accounts[acc_key] += receipt.amount
                else:
                    equity_accounts[acc_key] = receipt.amount
                equity_total += receipt.amount

        except:
            pass
    # Convert accumulated accounts to list format
    for acc_key, amount in asset_accounts.items():
        receipt_list_asset.append({acc_key: amount})

    for acc_key, amount in liability_accounts.items():
        receipt_list_liability.append({acc_key: amount})

    for acc_key, amount in equity_accounts.items():
        receipt_list_equity.append({acc_key: amount})





    # Initialize dictionaries to store accumulated values for each account
    asset_accounts = {}
    liability_accounts = {}
    equity_accounts = {}

    # Initialize lists for final results
    journal_list_asset = []
    journal_list_liability = []
    journal_list_equity = []

    cash_list = ['CASH ACCOUNT']

    # Process all receipts
    journals_obj = Journals.objects.filter(Q(branch=homebranch)& Q(journaldate__gte=startdate)
        & Q(journaldate__lte=enddate))

    for index,journal in enumerate(journals_obj):

        credit_acc = journal.creditaccount
        debit_acc = journal.debitaccount
        credit_acc_key = credit_acc.title.replace(" ", "_")
        debit_acc_key = debit_acc.title.replace(" ", "_")

        # if credit_acc in cash_list:
        #     credit_acc_head = credit_acc
        # elif CoASubAccounts.objects.filter(title=credit_acc).first():
        #     credit_acc_head = CoASubAccounts.objects.filter(title=credit_acc).first().head_root.name
        # else:
        #     credit_acc_head = credit_acc

        # if debit_acc in cash_list:
        #     debit_acc_head = debit_acc
        # elif CoASubAccounts.objects.filter(title=debit_acc).first():
        #     debit_acc_head = CoASubAccounts.objects.filter(title=debit_acc).first().head_root.name
        # else:
        #     debit_acc_head = debit_acc
        
        if credit_acc.head_root.account_group.account_head.name == 'ASSET':
            if credit_acc_key in asset_accounts:
                asset_accounts[credit_acc_key] -= journal.amount
            else:
                asset_accounts[credit_acc_key] = -journal.amount
            asset_total -= journal.amount

        elif credit_acc.head_root.account_group.account_head.name == 'LIABILITY':
            if credit_acc_key in liability_accounts:
                liability_accounts[credit_acc_key] += journal.amount
            else:
                liability_accounts[credit_acc_key] = journal.amount
            liability_total += journal.amount

        elif credit_acc.head_root.account_group.account_head.name == 'EQUITY':
            if credit_acc_key in equity_accounts:
                equity_accounts[credit_acc_key] += journal.amount
            else:
                equity_accounts[credit_acc_key] = journal.amount
            equity_total += journal.amount

        if debit_acc.head_root.account_group.account_head.name == 'ASSET':
            if debit_acc_key in asset_accounts:
                asset_accounts[debit_acc_key] += journal.amount
            else:
                asset_accounts[debit_acc_key] = journal.amount
            asset_total += journal.amount

        elif debit_acc.head_root.account_group.account_head.name == 'LIABILITY':
            if debit_acc_key in liability_accounts:
                liability_accounts[debit_acc_key] -= journal.amount
            else:
                liability_accounts[debit_acc_key] = -journal.amount
            liability_total -= journal.amount

        elif debit_acc.head_root.account_group.account_head.name == 'EQUITY':
            if debit_acc_key in equity_accounts:
                equity_accounts[debit_acc_key] -= journal.amount
            else:
                equity_accounts[debit_acc_key] = -journal.amount
            equity_total -= journal.amount


    for acc_key, amount in asset_accounts.items():
        journal_list_asset.append({acc_key: amount})

    for acc_key, amount in liability_accounts.items():
        journal_list_liability.append({acc_key: amount})

    for acc_key, amount in equity_accounts.items():
        journal_list_equity.append({acc_key: amount})


    # For Assets
    list_asset_total = []
    asset_keys = set()

    # Update asset_keys set to include journal entries
    for rec_item in receipt_list_asset:
        asset_keys.update(rec_item.keys())
    for pay_item in payment_list_asset:
        asset_keys.update(pay_item.keys())
    for journal_item in journal_list_asset:
        asset_keys.update(journal_item.keys())

    for key in asset_keys:
        dict = {}
        rec_value = next((item[key] for item in receipt_list_asset if key in item), 0)
        pay_value = next((item[key] for item in payment_list_asset if key in item), 0)
        journal_value = next((item[key] for item in journal_list_asset if key in item), 0)
        final = pay_value - rec_value + journal_value
        dict[key] = format_negative_value(round(final, 2))
        list_asset_total.append(dict)

    # For Liabilities
    list_liability_total = []
    liability_keys = set()

    # Update liability_keys set to include journal entries
    for rec_item in receipt_list_liability:
        liability_keys.update(rec_item.keys())
    for pay_item in payment_list_liability:
        liability_keys.update(pay_item.keys())
    for journal_item in journal_list_liability:
        liability_keys.update(journal_item.keys())

    for key in liability_keys:
        dict = {}
        rec_value = next((item[key] for item in receipt_list_liability if key in item), 0)
        pay_value = next((item[key] for item in payment_list_liability if key in item), 0)
        journal_value = next((item[key] for item in journal_list_liability if key in item), 0)
        final = rec_value - pay_value + journal_value
        dict[key] = format_negative_value(round(final, 2))
        list_liability_total.append(dict)

    # For Equity
    list_equity_total = []
    equity_keys = set()

    # Update equity_keys set to include journal entries
    for rec_item in receipt_list_equity:
        equity_keys.update(rec_item.keys())
    for pay_item in payment_list_equity:
        equity_keys.update(pay_item.keys())
    for journal_item in journal_list_equity:
        equity_keys.update(journal_item.keys())

    for key in equity_keys:
        dict = {}
        rec_value = next((item[key] for item in receipt_list_equity if key in item), 0)
        pay_value = next((item[key] for item in payment_list_equity if key in item), 0)
        journal_value = next((item[key] for item in journal_list_equity if key in item), 0)
        final = rec_value - pay_value + journal_value
        dict[key] = format_negative_value(round(final, 2))
        list_equity_total.append(dict)



    grouped_assets, grouped_liabilities, grouped_equity = process_account_lists(
                        list_asset_total, list_liability_total, list_equity_total
                )

    grouped_assets = process_grouped_accounts(grouped_assets)
    grouped_liabilities = process_grouped_accounts(grouped_liabilities)
    grouped_equity = process_grouped_accounts(grouped_equity)

    data = Sale.objects.filter(Q(branch=homebranch)& Q(invoicedate__gte=startdate)
        & Q(invoicedate__lte=enddate)).order_by("-pk")

    saleid_set = set()
    sale_obj = [
        sale
        for sale in data
        if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
    ]


    statuses = [
        'Unassigned',
        'Unacknowledged',
        'In Progress',
        'QC Failed',
        'Completed',
        'QC Passed(Ok)',
        'CNP Inprogress(Ok)',
        'CNP Pending(Ok)',
        'CNP Completed(Ok)',
    ]
    # Build the query
    service_obj = Service.objects.filter(
        Q(branch=homebranch) &
        Q(memodate__gte=startdate) &
        Q(memodate__lte=enddate) &
        (
            Q(status='Delivered(Ok)') |
            (
                # Q(amountrecieved__gt=0) &
                Q(finalamount__gt=F('amountrecieved')) &
                Q(status__in=statuses)
            )
        )
    )



    accounts_receivable_total = 0

    cust_dict={}
    for item in sale_obj:
        if item.duebalance != 0:
            if item.customerid in cust_dict.keys():
                cust_dict[item.customerid] += item.duebalance
                asset_total += item.duebalance
                accounts_receivable_total += item.duebalance
            else:
                cust_dict[item.customerid] = item.duebalance
                asset_total += item.duebalance
                accounts_receivable_total += item.duebalance

    for item in service_obj:
        if item.duebalance != 0:
            cust_id = Customers.objects.filter(unique_id=item.customerid).first().id
            if cust_id in cust_dict.keys():
                cust_dict[cust_id] += item.duebalance
                asset_total += item.duebalance
                accounts_receivable_total += item.duebalance
            else:
                cust_dict[cust_id] = item.duebalance
                asset_total += item.duebalance
                accounts_receivable_total += item.duebalance

    accounts_receivable_total = format_negative_value(round(accounts_receivable_total,2))

    cust_dict = {f"{Customers.objects.filter(id=key).first().firstname}_{Customers.objects.filter(id=key).first().lastname}":value for key,value in cust_dict.items()}

    account_receivable_list = [cust_dict]
    
    data = BranchPurchase.objects.filter(
        Q(branch=homebranch)
        & ~Q(purchase_type="transfer")
        & ~Q(purchase_type="stockadd")
         & Q(invoicedate__gte=startdate)
        & Q(invoicedate__lte=enddate)
    ).order_by("-pk")
    purchaseid_set = set()
    purchase_obj = [
        purchase
        for purchase in data
        if (
            purchase.purchaseid not in purchaseid_set
            and not purchaseid_set.add(purchase.purchaseid)
        )
    ]

 
    sup_dict = {}
    accounts_payable_total = 0
    for item in purchase_obj:
        if item.duebalance != 0:
            sup_id = Suppliers.objects.filter(id=item.externalsupplier.id).first().id
            if sup_id in sup_dict.keys():
                sup_dict[sup_id] += item.duebalance
                liability_total += item.duebalance
                accounts_payable_total += item.duebalance
            else:
                sup_dict[sup_id] = item.duebalance
                liability_total += item.duebalance
                accounts_payable_total += item.duebalance

    sup_dict = {f"{Suppliers.objects.filter(id=key).first().name}":value for key,value in sup_dict.items()}
    account_payable_list = [sup_dict]


    accounts_payable_total = format_negative_value(round(accounts_payable_total,2))

    ###################################################

    sale_tax_payable = 0
    for item in sale_obj:
        # if item.duebalance == 0:
        sale_tax_payable +=item.totaltax
    liability_total += sale_tax_payable



    purchase_tax_receivable = 0
    for item in purchase_obj:
        # if item.duebalance == 0:
        purchase_tax_receivable +=item.totaltax
    asset_total += purchase_tax_receivable


    service_tax_payable = 0
    for item in service_obj:
        # if item.duebalance == 0:
        servicerefnum = item.servicerefnumber
        serv_disc_obj = ServiceDiscountDetails.objects.filter(servicerefnumber=servicerefnum).first()
        if serv_disc_obj:
            servicetax=serv_disc_obj.servicetaxtotal_afterdiscount
            sparetax=serv_disc_obj.sparetaxtotal_afterdiscount
            totaltax = servicetax + sparetax
            service_tax_payable += totaltax
        else:
            service_tax = item.totaltax
            spare_tax = 0
            spare_obj = SpareParts.objects.filter(servicerefnumber=servicerefnum)
            if spare_obj:
                for sub_item in spare_obj:
                    spare_tax += (sub_item.price * (float(sub_item.salegst) / 100))
            totaltax = service_tax + spare_tax
            service_tax_payable += totaltax

    liability_total += service_tax_payable

    purchase_return_tax = 0
    data = PurchaseReturn.objects.filter(Q(status='Processed') & Q(branch=homebranch) & Q(createddate__gte=startdate)
        & Q(createddate__lte=enddate))
    purchase_return_set = set()
    purchase_return_obj = [
        purchase
        for purchase in data
        if (
            purchase.purchasereturnid not in purchase_return_set
            and not purchase_return_set.add(purchase.purchasereturnid)
        )
    ]

    for ret in purchase_return_obj:
        purchase_return_tax += ret.totaltax
    asset_total -= purchase_return_tax 

    


    sale_return_tax = 0
    data = SaleReturn.objects.filter(Q(branch=homebranch)& Q(createddate__gte=startdate)
        & Q(createddate__lte=enddate))
    sale_return_set = set()
    sale_return_obj = [
        sale
        for sale in data
        if (
            sale.salereturnid not in sale_return_set
            and not sale_return_set.add(sale.salereturnid)
        )
    ]

    for ret in sale_return_obj:
        sale_return_tax += ret.totaltax
    liability_total -= sale_return_tax
    
    # print("tax payable",sale_tax_payable,service_tax_payable,sale_return_tax)
    total_tax_payable=((sale_tax_payable+service_tax_payable)-sale_return_tax)
    total_tax_payable = format_negative_value(round(total_tax_payable,2))
    ##################################################

    ################## Retained earning ############################
    retained_earnings = func_get_placcount_for_balancesheet(startdate,enddate,request)
    
    if retained_earnings['pnl'] == 'Profit':
        equity_total += retained_earnings['balance']
    else:
        equity_total -= retained_earnings['balance']
        retained_earnings['balance'] = f"({retained_earnings['balance']})"
    ################################################################


    ################### closing stock ############################
    closing_stock_value = func_get_opening_closing_stock_for_balancesheet(startdate,enddate,request)
    asset_total += closing_stock_value
    ##############################################################


    total_tax_receivable = purchase_tax_receivable - purchase_return_tax
    total_tax_receivable = format_negative_value(round(total_tax_receivable,2))




    # def transform_ledger_data(ledger_data):
    #     transformed_data = {}
    #     for ledger_name, ledger_info in ledger_data.items():
    #         ledger = AccountLedger.objects.get(name=ledger_name)
    #         group = ledger.account_group
    #         group_name = group.name
    #         if group_name not in transformed_data:
    #             transformed_data[group_name] = {
    #                 'total': '0.00',
    #                 'data': []
    #             }
    #         transformed_data[group_name]['data'].append({
    #             'title': ledger_name,
    #             'total': ledger_info['total'],
    #             'data': ledger_info['data']
    #         })
    #         group_total = sum(float(item['total']) for item in transformed_data[group_name]['data'])
    #         transformed_data[group_name]['total'] = f"{group_total:.2f}"
    #     return transformed_data



    def transform_ledger_data(ledger_data):
        # Dictionary to store transformed data
        transformed_data = {}
        
        def parse_number(value):
            # If value is already a number, return it
            if isinstance(value, (int, float)):
                return float(value)
                
            # If value is string, handle parentheses case
            if isinstance(value, str):
                value = value.strip()
                if value.startswith('(') and value.endswith(')'):
                    return -float(value[1:-1])
                return float(value)
                
            return 0.0  # fallback for unexpected types
        
        # Process each ledger
        for ledger_name, ledger_info in ledger_data.items():
            # Get the AccountLedger and its group
            ledger = AccountLedger.objects.get(name=ledger_name)
            group = ledger.account_group
            group_name = group.name
            
            # Initialize group in transformed data if it doesn't exist
            if group_name not in transformed_data:
                transformed_data[group_name] = {
                    'total': '0.00',
                    'data': []
                }
            
            # Add ledger data to group
            transformed_data[group_name]['data'].append({
                'title': ledger_name,
                'total': ledger_info['total'],
                'data': ledger_info['data']
            })
            
            # Update group total using the new parse_number function
            group_total = sum(parse_number(item['total']) for item in transformed_data[group_name]['data'])
            transformed_data[group_name]['total'] = f"{group_total:.2f}"
        
        return transformed_data

    grouped_assets = transform_ledger_data(grouped_assets)
    grouped_liabilities = transform_ledger_data(grouped_liabilities)
    grouped_equity = transform_ledger_data(grouped_equity)

    is_current_assets = False
    if 'CURRENT ASSETS' in grouped_assets.keys():
        is_current_assets = True

    is_current_liabilities = False
    if 'CURRENT LIABILITIES' in grouped_liabilities.keys():
        is_current_liabilities = True

    

    
    context = {'asset':balance_sheet_dict['asset'],'payment_list_asset':payment_list_asset,
    'payment_list_liability':payment_list_liability,
    'payment_list_equity':payment_list_equity,
    'receipt_list_asset':receipt_list_asset,
    'receipt_list_liability':receipt_list_liability,
    'receipt_list_equity':receipt_list_equity,
    'journal_list_asset':journal_list_asset,
    'journal_list_liability':journal_list_liability,
    'journal_list_equity':journal_list_equity,
    'account_receivable':account_receivable_list,
    'account_payable_list':account_payable_list,
    'total_asset':asset_total,
    'total_liability':liability_total,
    'total_equity':equity_total,
    'total_liability_equity':(liability_total+equity_total),
   'sale_return_tax' :sale_return_tax,
    'purchase_return_tax' :purchase_return_tax,
    'service_tax_payable':service_tax_payable ,
    'sale_tax_payable':sale_tax_payable,
    "total_tax_payable":total_tax_payable,
    'purchase_tax_receivable':purchase_tax_receivable,
    'startdate_text':startdate_text,
    'enddate_text':enddate_text,
    'retained_earnings':retained_earnings,
    'closing_stock_value':closing_stock_value,
    "accounts_payable_total":accounts_payable_total,
    "total_cash_in_hand":total_cash_in_hand,
    "accounts_receivable_total":accounts_receivable_total,
    "total_tax_receivable":total_tax_receivable,
    'list_asset_total':list_asset_total,
    'list_liability_total':list_liability_total,
    'list_equity_total':list_equity_total,
    'grouped_assets':grouped_assets,
    'grouped_liabilities':grouped_liabilities,
    'grouped_equity':grouped_equity,
    "is_current_assets":is_current_assets,
    "is_current_liabilities":is_current_liabilities

    }

    return render(request,'balancesheetnew.html',context)








def process_account_lists_placcount(income_list, expense_list):
    """
    Process lists of financial accounts, group them by head_root, and sort them.
    
    Args:
        asset_list: List of asset dictionaries
        liability_list: List of liability dictionaries
        equity_list: List of equity dictionaries
    
    Returns:
        tuple: Three dictionaries (assets, liabilities, equity) grouped by head_root
    """
    def process_single_list(account_list):
        # Dictionary to store results grouped by head_root
        grouped_accounts = {}


        for account_dict in account_list:
            for key, value in account_dict.items():
                # Convert key from underscore format to original title format
                original_title = key.replace('_', ' ')
                
                try:
                    # Query the CoASubAccounts model to get the head_root
                    sub_account = CoASubAccounts.objects.get(title=original_title)
                    head_root = sub_account.head_root.name
                    
                    # Initialize the list for this head_root if it doesn't exist
                    if head_root not in grouped_accounts:
                        grouped_accounts[head_root] = []
                    
                    # Add the account to its head_root group
                    grouped_accounts[head_root].append({
                        'title': original_title,
                        'value': value
                    })
                    
                except CoASubAccounts.DoesNotExist:
                    print(f"Warning: No CoASubAccounts entry found for title: {original_title}")
                    continue
        
        # Sort accounts within each head_root group by title
        for head_root in grouped_accounts:
            grouped_accounts[head_root].sort(key=lambda x: x['title'])
            
        return grouped_accounts

    grouped_income = process_single_list(income_list)
    grouped_expense = process_single_list(expense_list)

    return grouped_income, grouped_expense
    




@login_required
def placcountnew(request):

    if request.method == 'POST':
        startdate = request.POST.get('startdate')
        enddate = request.POST.get('enddate')
        startdate = datetime.strptime(startdate, "%d-%m-%Y").date()
        enddate = datetime.strptime(enddate, "%d-%m-%Y").date()
    else:
        startdate = date.today()
        enddate = date.today()

    startdate_text = startdate
    enddate_text = enddate

    branch=request.user.userprofile.branch



    income_total = 0
    expense_total = 0

    #Opening stock Closing stock section

    # Convert dates to datetime objects with time component
    start_datetime = timezone.make_aware(datetime.combine(startdate, datetime.min.time()))
    end_datetime = timezone.make_aware(datetime.combine(enddate, datetime.max.time()))

    # Calculate total opening stock
    additions_before_start = StockTransaction.objects.filter(
        created_date__lt=start_datetime,
        transactiontype='Add',
        branch=branch
    ).aggregate(total=Sum('quantity'))['total'] or 0

    subtractions_before_start = StockTransaction.objects.filter(
        created_date__lt=start_datetime,
        transactiontype='Sub',
        branch=branch
    ).aggregate(total=Sum('quantity'))['total'] or 0

    opening_stock = additions_before_start - subtractions_before_start

    # Calculate stock changes during the period
    additions_during_period = StockTransaction.objects.filter(
        created_date__gte=start_datetime,
        created_date__lte=end_datetime,
        transactiontype='Add',
        branch=branch
    ).aggregate(total=Sum('quantity'))['total'] or 0

    subtractions_during_period = StockTransaction.objects.filter(
        created_date__gte=start_datetime,
        created_date__lte=end_datetime,
        transactiontype='Sub',
        branch=branch
    ).aggregate(total=Sum('quantity'))['total'] or 0

    stock_change = additions_during_period - subtractions_during_period

    # Calculate closing stock
    closing_stock = opening_stock + stock_change

    

    #Opening stock Closing stock section (STOCK VALUE)

    # Convert dates to datetime objects with time component
    start_datetime = timezone.make_aware(datetime.combine(startdate, datetime.min.time()))
    end_datetime = timezone.make_aware(datetime.combine(enddate, datetime.max.time()))

    additions_before_start_transactions = StockTransaction.objects.filter(
        created_date__lt=start_datetime,
        transactiontype='Add',
        branch=branch
    ).values('purchase_rate', 'quantity')
    
    additions_value_before_start = sum(
        transaction['purchase_rate'] * transaction['quantity']
        for transaction in additions_before_start_transactions
    )
    
    subtractions_before_start_transactions = StockTransaction.objects.filter(
        created_date__lt=start_datetime,
        transactiontype='Sub',
        branch=branch
    ).values('purchase_rate', 'quantity')
    
    subtractions_value_before_start = sum(
        transaction['purchase_rate'] * transaction['quantity']
        for transaction in subtractions_before_start_transactions
    )



    opening_stock_value = additions_value_before_start - subtractions_value_before_start

    expense_total += opening_stock_value


    additions_during_period_transactions = StockTransaction.objects.filter(
        created_date__gte=start_datetime,
        created_date__lte=end_datetime,
        transactiontype='Add',
        branch=branch
    ).values('purchase_rate', 'quantity')
    
    additions_value_during_period = sum(
        transaction['purchase_rate'] * transaction['quantity']
        for transaction in additions_during_period_transactions
    )
    
    subtractions_during_period_transactions = StockTransaction.objects.filter(
        created_date__gte=start_datetime,
        created_date__lte=end_datetime,
        transactiontype='Sub',
        branch=branch
    ).values('purchase_rate', 'quantity')
    
    subtractions_value_during_period = sum(
        transaction['purchase_rate'] * transaction['quantity']
        for transaction in subtractions_during_period_transactions
    )

    
    stock_change_value = additions_value_during_period - subtractions_value_during_period

    # Calculate closing stock value
    closing_stock_value = opening_stock_value + stock_change_value

    income_total += closing_stock_value



    #Purchase Expense

    data = BranchPurchase.objects.filter(
        Q(branch=branch)
        & ~Q(purchase_type="transfer")
        & ~Q(purchase_type="stockadd")
        & Q(invoicedate__gte=startdate)
        & Q(invoicedate__lte=enddate)
    ).order_by("-pk")
    purchaseid_set = set()
    purchase_obj = [
        purchase
        for purchase in data
        if (
            purchase.purchaseid not in purchaseid_set
            and not purchaseid_set.add(purchase.purchaseid)
        )
    ]

    purchase_expense = 0
    for items in purchase_obj:
        purchase_expense += (items.totalbillingamount-items.totaltax)

    expense_total += purchase_expense 


    data = Sale.objects.filter(Q(branch=branch)& Q(invoicedate__gte=startdate)
        & Q(invoicedate__lte=enddate)).order_by("-pk")
    saleid_set = set()
    sale_obj = [
        sale
        for sale in data
        if (sale.saleid not in saleid_set and not saleid_set.add(sale.saleid))
    ]
    sale_income = 0
    for items in sale_obj :
        sale_income += (items.totalbillingamount-items.totaltax)
    income_total += sale_income



    # service income

    statuses = [
        'Unassigned',
        'Unacknowledged',
        'In Progress',
        'QC Failed',
        'Completed',
        'QC Passed(Ok)',
        'CNP Inprogress(Ok)',
        'CNP Pending(Ok)',
        'CNP Completed(Ok)',
    ]
    # Build the query
    service_obj = Service.objects.filter(
        Q(branch=branch) &
        Q(memodate__gte=startdate) &
        Q(memodate__lte=enddate) &
        (
            Q(status='Delivered(Ok)') |
            (
                # Q(amountrecieved__gt=0) &
                Q(finalamount__gt=F('amountrecieved')) &
                Q(status__in=statuses)
            )
        )
    )
    service_income = 0
    for item in service_obj:
        finalamount = item.finalamount
        servicerefnumber = item.servicerefnumber
        servicedic_obj = ServiceDiscountDetails.objects.filter(servicerefnumber=servicerefnumber).first()
        if servicedic_obj:
            total_tax = servicedic_obj.sparetaxtotal_afterdiscount + servicedic_obj.servicetaxtotal_afterdiscount
            service_income += (finalamount - total_tax)
        else:
            service_tax = item.totaltax
            spare_tax = 0
            spare_obj = SpareParts.objects.filter(servicerefnumber=servicerefnumber)
            if spare_obj:
                for sub_item in spare_obj:
                    spare_tax += (sub_item.price * (float(sub_item.salegst) / 100))
            total_tax = service_tax + spare_tax
            service_income += (finalamount - total_tax)
    income_total += service_income



    purchase_return = 0
    data = PurchaseReturn.objects.filter(Q(status='Processed') & Q(branch=branch)& Q(createddate__gte=startdate)
        & Q(createddate__lte=enddate))
    purchase_return_set = set()
    purchase_return_obj = [
        purchase
        for purchase in data
        if (
            purchase.purchasereturnid not in purchase_return_set
            and not purchase_return_set.add(purchase.purchasereturnid)
        )
    ]

    for ret in purchase_return_obj:
        purchase_return += (ret.nettotal - ret.totaltax)
    # income_total += purchase_return
    expense_total -= purchase_return


    sale_return = 0
    data = SaleReturn.objects.filter(Q(branch=branch)& Q(createddate__gte=startdate)
        & Q(createddate__lte=enddate))
    sale_return_set = set()
    sale_return_obj = [
        sale
        for sale in data
        if (
            sale.salereturnid not in sale_return_set
            and not sale_return_set.add(sale.salereturnid)
        )
    ]

    for ret in sale_return_obj:
        sale_return += (ret.nettotal - ret.totaltax)
    # expense_total += sale_return
    income_total -= sale_return
  

    # Initialize dictionaries to store accumulated values for each account
    income_accounts = {}
    expense_accounts = {}

    # Initialize lists for final results
    payment_list_income = []
    payment_list_expense = []
    # Process all payments
    payments_obj = Payments.objects.filter(Q(branch=branch)& Q(paymentdate__gte=startdate)
        & Q(paymentdate__lte=enddate))
    for pay in payments_obj:
        debit_acc = pay.debitaccount
        acc_key = debit_acc.title.replace(" ", "_")


        # acc_head = CoASubAccounts.objects.filter(title=debit_acc).first().head_root.name
        
        # Process based on account type
        if debit_acc.head_root.account_group.account_head.name == 'INCOME':
            # Accumulate amounts for the same account
            if acc_key in income_accounts:
                income_accounts[acc_key] -= pay.amount
                income_total -= pay.amount
            else:
                income_accounts[acc_key] = -pay.amount
                income_total -= pay.amount
            
        elif debit_acc.head_root.account_group.account_head.name == 'EXPENSE':
            if acc_key in expense_accounts:
                expense_accounts[acc_key] += pay.amount
                expense_total += pay.amount
            else:
                expense_accounts[acc_key] = pay.amount
                expense_total += pay.amount
        # except:
        #     pass
            

    # Convert accumulated accounts to list format
    for acc_key, amount in income_accounts.items():
        payment_list_income.append({acc_key: amount})

    for acc_key, amount in expense_accounts.items():
        payment_list_expense.append({acc_key: amount})


   

    # OTHER INCOME

    # Initialize dictionaries to store accumulated values for each account
    income_accounts = {}
    expense_accounts = {}

    # Initialize lists for final results
    receipt_list_income = []
    receipt_list_expense = []
    # Process all receipts
    receipts_obj = Receipts.objects.filter(Q(branch=branch)& Q(receiptdate__gte=startdate)
        & Q(receiptdate__lte=enddate))

    for receipt in receipts_obj:
        credit_acc = receipt.creditaccount
        acc_key = credit_acc.title.replace(" ", "_")
        # try:
        # acc_head = CoASubAccounts.objects.filter(title=credit_acc).first().head_root.name
        
        # Process based on account type
        if credit_acc.head_root.account_group.account_head.name == 'INCOME':
            # Accumulate amounts for the same account
            if acc_key in income_accounts:
                income_accounts[acc_key] += receipt.amount
                income_total += receipt.amount
            else:
                income_accounts[acc_key] = receipt.amount
                income_total += receipt.amount
            
        elif credit_acc.head_root.account_group.account_head.name == 'EXPENSE':
            if acc_key in expense_accounts:
                expense_accounts[acc_key] -= receipt.amount
                expense_total -= receipt.amount
            else:
                expense_accounts[acc_key] = -receipt.amount
                expense_total -= receipt.amount
        # except:
        #     pass
            
    # Convert accumulated accounts to list format
    for acc_key, amount in income_accounts.items():
        receipt_list_income.append({acc_key: amount})

    for acc_key, amount in expense_accounts.items():
        receipt_list_expense.append({acc_key: amount})



    # Initialize dictionaries to store accumulated values for each account
    income_accounts = {}
    expense_accounts = {}

    # Initialize lists for final results
    journal_list_income = []
    journal_list_expense = []

    cash_list = ['CASH ACCOUNT']

    # Process all journals
    journals_obj = Journals.objects.filter(Q(branch=branch)& Q(journaldate__gte=startdate)
        & Q(journaldate__lte=enddate))

    for journal in journals_obj:
        credit_acc = journal.creditaccount
        debit_acc = journal.debitaccount
        credit_acc_key = credit_acc.title.replace(" ", "_")
        debit_acc_key = debit_acc.title.replace(" ", "_")

        
        # Process credit side
        if credit_acc.head_root.account_group.account_head.name == "INCOME":
            if credit_acc_key in income_accounts:
                income_accounts[credit_acc_key] += journal.amount
                income_total += journal.amount
            else:
                income_accounts[credit_acc_key] = journal.amount
                income_total += journal.amount
                
        elif credit_acc.head_root.account_group.account_head.name == "EXPENSE":
            if credit_acc_key in expense_accounts:
                expense_accounts[credit_acc_key] -= journal.amount
                expense_total -= journal.amount
            else:
                expense_accounts[credit_acc_key] = -journal.amount
                expense_total -= journal.amount

        # Process debit side
        if debit_acc.head_root.account_group.account_head.name == "INCOME":
            if debit_acc_key in income_accounts:
                income_accounts[debit_acc_key] -= journal.amount
                income_total -= journal.amount
            else:
                income_accounts[debit_acc_key] = -journal.amount
                income_total -= journal.amount
                
        elif debit_acc.head_root.account_group.account_head.name == "EXPENSE":
            if debit_acc_key in expense_accounts:
                expense_accounts[debit_acc_key] += journal.amount
                expense_total += journal.amount
            else:
                expense_accounts[debit_acc_key] = journal.amount
                expense_total += journal.amount

    # Convert accumulated accounts to list format
    for acc_key, amount in income_accounts.items():
        journal_list_income.append({acc_key: amount})

    for acc_key, amount in expense_accounts.items():
        journal_list_expense.append({acc_key: amount})

    list_income_total = []
    income_keys = set()

    for rec_item in receipt_list_income:
        income_keys.update(rec_item.keys())
    for pay_item in payment_list_income:
        income_keys.update(pay_item.keys())
    for journal_item in journal_list_income:
        income_keys.update(journal_item.keys())

    for key in income_keys:
        dict = {}
        rec_value = next((item[key] for item in receipt_list_income if key in item), 0)
        pay_value = next((item[key] for item in payment_list_income if key in item), 0)
        journal_value = next((item[key] for item in journal_list_income if key in item), 0)
        final =   rec_value + journal_value + pay_value
        dict[key] = format_negative_value(round(final, 2))
        list_income_total.append(dict)



    list_expense_total = []
    expense_keys = set()

    for rec_item in receipt_list_expense:
        expense_keys.update(rec_item.keys())
    for pay_item in payment_list_expense:
        expense_keys.update(pay_item.keys())
    for journal_item in journal_list_expense:
        expense_keys.update(journal_item.keys())

    for key in expense_keys:
        dict = {}
        rec_value = next((item[key] for item in receipt_list_expense if key in item), 0)
        pay_value = next((item[key] for item in payment_list_expense if key in item), 0)
        journal_value = next((item[key] for item in journal_list_expense if key in item), 0)
        final = pay_value + journal_value +  rec_value
        dict[key] = format_negative_value(round(final, 2))
        list_expense_total.append(dict)


    



    grouped_income, grouped_expense,  = process_account_lists_placcount(
                        list_income_total, list_expense_total
                )
        
    grouped_income = process_grouped_accounts(grouped_income)
    grouped_expense = process_grouped_accounts(grouped_expense)



    def transform_ledger_data(ledger_data):
        # Dictionary to store transformed data
        transformed_data = {}
        
        def parse_number(value):
            # If value is already a number, return it
            if isinstance(value, (int, float)):
                return float(value)
                
            # If value is string, handle parentheses case
            if isinstance(value, str):
                value = value.strip()
                if value.startswith('(') and value.endswith(')'):
                    return -float(value[1:-1])
                return float(value)
                
            return 0.0  # fallback for unexpected types
        
        # Process each ledger
        for ledger_name, ledger_info in ledger_data.items():
            # Get the AccountLedger and its group
            ledger = AccountLedger.objects.get(name=ledger_name)
            group = ledger.account_group
            group_name = group.name
            
            # Initialize group in transformed data if it doesn't exist
            if group_name not in transformed_data:
                transformed_data[group_name] = {
                    'total': '0.00',
                    'data': []
                }
            
            # Add ledger data to group
            transformed_data[group_name]['data'].append({
                'title': ledger_name,
                'total': ledger_info['total'],
                'data': ledger_info['data']
            })
            
            # Update group total using the new parse_number function
            group_total = sum(parse_number(item['total']) for item in transformed_data[group_name]['data'])
            transformed_data[group_name]['total'] = f"{group_total:.2f}"
        
        return transformed_data

    grouped_income = transform_ledger_data(grouped_income)
    grouped_expense = transform_ledger_data(grouped_expense)



    if income_total > expense_total:
        balance = income_total - expense_total
        balance_text = 'Net Profilt (Income > Expenses)'
        pnl = 'Profit'
        final = income_total
    else:
        balance = expense_total - income_total
        balance_text = 'Net Loss (Expenses > Income)'
        pnl = 'Loss'
        final = expense_total

   
    data = {
        # "spare_cost":spare_cost_total,
        'balance':balance,
        'balance_text':balance_text,
        'pnl':pnl,
        'final':final,
        'income_total':income_total,
        'expense_total':expense_total,
        'sale_return_total':sale_return,
        "purchase_return_total":purchase_return,
        "opening_stock_value":opening_stock_value,
         "closing_stock_value":closing_stock_value,
         'purchase_expense':purchase_expense,
         'sale_income':sale_income,
         'service_income':service_income,
         'payment_list_income':payment_list_income,
        'payment_list_expense':payment_list_expense,
        'receipt_list_income':receipt_list_income,
        'receipt_list_expense':receipt_list_expense,
        'journal_list_income':journal_list_income,
        'journal_list_expense':journal_list_expense,
        'startdate_text':startdate_text,
        'enddate_text':enddate_text,
        "grouped_income":grouped_income,
        "grouped_expense":grouped_expense
        }

    return render(request, "placcountnew.html", data)

